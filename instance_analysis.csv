instance_id,complexity_percentage,category,solvability_percentage,reasoning
astropy__astropy-12907,-1,error,-1,Failed to parse response
astropy__astropy-13033,15,easy,85,"The change is confined to a single method in one file (TimeSeries._check_required_columns). It only adds a small helper to format error-message arguments and revises the ValueError text. No algorithms or data structures are altered; the functional behaviour of the class remains identical except for clearer messaging. Understanding the fix requires minimal domain knowledge (just that TimeSeries has a list of required columns). An AI reading the misleading message and the if-block that constructs it could quickly infer that the comparison should include all required columns, not just the first. Crafting the helper to print either a scalar or list is straightforward string manipulation. Because the scope is narrow, the logic is simple, and no interaction with other parts of the codebase is needed, the task is highly solvable by automated tools."
astropy__astropy-13236,20,easy,85,"The patch touches a single file and consists solely of deleting a short conditional block (≈7 lines) that auto-converts structured NumPy arrays into an NdarrayMixin when adding them to an Astropy Table. No new logic, algorithms, or cross-module interactions are introduced. Understanding that this behavior change is desired requires some knowledge of Astropy mixins, but the mechanical change—removing the specified code block—is straightforward. Because the problem statement pinpoints the exact code to be altered and the solution is a simple deletion, an AI system could reliably generate the correct patch with minimal reasoning, leading to a high solvability score despite the need for minor domain context."
astropy__astropy-13398,70,hard,35,"The patch touches five files, introduces an entirely new transformation module, adds a new frame attribute, updates multiple existing transformation functions, and implements non-trivial mathematics for Earth-centred/observed frame conversions and atmospheric refraction. Correctly wiring these transforms into Astropy’s FrameTransformGraph demands familiarity with the library’s internal architecture and with celestial-mechanics conventions (left-handed vs right-handed frames, sidereal time, ERFA refraction coefficients, topocentric vs geocentric aberration). Although the issue description contains a prototype, the final solution is significantly richer: it handles refraction, location propagation, time synchronisation, and edge-case safeguards (e.g., numerical limits for sin/cos altitude). This breadth and the specialised domain knowledge push complexity to the “hard” range. For an AI starting only from the problem statement, reproducing all these nuanced, domain-specific details—especially the correct ERFA calls and matrix orientations—would be challenging, hence a moderate-low solvability estimate."
astropy__astropy-13453,18,easy,87,"The fix consists of adding two straightforward lines to the HTML writer: storing the column objects on the Data object and invoking the helper that applies user-supplied column formatters. No algorithms are introduced, no additional files are touched, and the change mirrors logic that already exists in other writer classes. An AI system reading the bug report could easily search for where formats are handled in other formats, notice the missing call in the HTML path, and replicate it. Domain knowledge needed is minimal—just understanding that _set_col_formats() must be called. Therefore the change is simple (low complexity) and highly solvable."
astropy__astropy-13579,30,medium,60,"The change touches a single method in one file and modifies only three lines, so the code delta is small. However, it requires understanding how SlicedLowLevelWCS substitutes world-coordinate values for the axes that were removed by slicing and why a hard-coded constant (1.) leads to incorrect pixel solutions when the PC matrix couples axes. Fixing the bug involves computing the correct default world coordinates via a call to _pixel_to_world_values_all and using those instead of the placeholder. This demands moderate domain knowledge of astropy’s WCS API and slice semantics but no elaborate algorithmic work, making the overall complexity modest. An AI system could infer the need to pass realistic world values rather than a constant and replicate the patch once the bug is reproduced, but it must understand the intent of the helper routine and axis bookkeeping, so success is not trivial yet still plausible. Hence, medium difficulty and ~60 % solvability."
astropy__astropy-13977,52,hard,46,"The patch modifies a single method in one file, but the change spans ~50 lines and introduces nuanced control flow around numpy’s __array_ufunc__ protocol. It wraps existing logic in a try/except, analyses the *array_ufunc* implementations of every input/output, conditionally returns NotImplemented or re-raises, and still preserves all original behavior for the successful path. Achieving this fix requires solid understanding of numpy’s ufunc dispatch rules, astropy’s Quantity unit-handling, and how Python’s binary operator fall-back works. No algorithmic heavy-lifting is added, but the semantic subtlety and need for deep domain knowledge make it more than a straightforward bug-fix. An AI without intimate knowledge of numpy’s duck-typing intricacies would find it challenging to infer the correct error-handling and compatibility checks, so solvability is below 50%, though not impossible with strong guidance."
astropy__astropy-14096,30,medium,80,"The patch touches a single method in one file and changes just a few lines, so the raw code change is small. However, it requires understanding the subtle difference between __getattr__ and __getattribute__, how Python’s attribute-resolution order interacts with properties, and why re-raising an AttributeError inside __getattr__ can mask the original missing attribute. That nuance elevates it slightly above a trivial typo fix, but the overall fix is straightforward once the cause is understood. Because the symptom and minimal reproduction are clearly described in the problem statement, and the remedy is a well-known pattern (delegate to __getattribute__ to surface the correct exception), an automated system with knowledge of Python’s data-model quirks has a good chance of proposing the same solution. Hence the task is moderate in complexity and highly solvable."
astropy__astropy-14182,35,medium,60,"The change touches a single file and adds roughly twenty lines, extending the existing fixed-width RST writer/reader to honor the generic `header_rows` option already implemented for other formats. No new algorithms are introduced, but the developer must understand how the table writer builds header, border, and data lines and how the reader skips the correct number of header lines. Adjusting `start_line`, choosing the right border line index, and threading `header_rows` through the constructor require familiarity with the internal abstractions yet remain straightforward once the design is understood. For an AI system, discovering where to pass the parameter and updating the offsets is achievable but not trivial—one must read surrounding code and reason about indexing—so solvability is moderate rather than high."
astropy__astropy-14309,15,easy,85,"The change touches a single function in one file, modifying only a handful of lines to avoid an IndexError. The bug is straightforward: `args[0]` was accessed when `args` could be empty. The fix returns the result of a filename-extension check directly, bypassing the faulty access. No complex algorithms or cross-module interactions are involved, so overall code complexity is low (≈15%). Any developer or automated system that reads the traceback and code can infer that the guard around `args[0]` is missing, making the problem easy. Because the failure is deterministic and the corrective logic is obvious, an AI has a high likelihood (≈85%) of generating the correct patch."
astropy__astropy-14365,15,easy,88,"The change touches a single file with only two small edits: adding the re.IGNORECASE flag to a compiled regular expression and comparing strings in a case-insensitive fashion by converting to upper case. No new algorithms, data structures, or cross-module interactions are introduced. The problem statement clearly pinpoints the bug (case sensitivity) and even gives an example that fails, making the required fix obvious. Locating the regex compilation and the literal 'NO' check in the code requires minimal exploration of the module. An AI system with basic understanding of Python regex and string comparison could infer these edits directly from the description, so the task is highly solvable. Overall, the fix is a straightforward, low-complexity bug patch."
astropy__astropy-14369,35,medium,55,"The change affects the unit–parsing grammar for CDS-formatted unit strings. Only two files are modified, and the functional change is limited to replacing one grammar production plus regenerating the parser table. No new algorithms or large-scale refactoring is involved, keeping code churn and architectural impact modest (≈35% complexity).

To discover the bug one must understand how left- vs. right-associative division changes the resulting unit object. Fixing it requires reading the current PLY grammar, spotting the incorrect production, and rewriting it so that division becomes left-associative. This demands some familiarity with parser generators and Astropy’s unit system but does not require deep algorithmic work, so the task is deemed “medium”.

Given the explicit bug description, a concrete failing example, and the fact that the solution is essentially a one-line grammar tweak, an AI system has a reasonable chance of producing the correct fix, though it must know to regenerate—or hand-edit—the parse table as well. Because this subtle parser detail and the need to update the generated file may trip up automated approaches, solvability is estimated at about 55%."
astropy__astropy-14508,20,easy,80,"Only a single helper function in one file is modified (~10 LOC). The change replaces an f-string with Python’s default str() representation, converts the exponent to upper-case, and keeps existing logic that trims the string to 20 characters. No new algorithm or cross-module impact. The domain nuance (FITS card length limit of 20 characters for the value field) is described explicitly in the problem statement, so an AI can infer the need to shorten the representation and keep the decimal/exponent intact. Given the clear bug description, isolated location, and straightforward string manipulation, generating this patch is highly feasible. Complexity is low because there are no structural or algorithmic challenges, only minor logic adjustments."
astropy__astropy-14539,15,easy,80,"The fix consists of a one-line change in a single file: extending an existing condition that detected variable-length array columns from only the 32-bit pointer designator (""P"") to also include the 64-bit designator (""Q"").  No new algorithms or structural changes are introduced, and the adjustment is purely additive.  While some FITS domain knowledge is helpful (knowing that both ""P"" and ""Q"" represent VLAs), the change is almost a direct pattern substitution once the bug is understood.  Therefore the technical complexity is low and the task falls in the “easy” category.  Given the clear symptom in the problem statement (difference arises with a ‘QD’ column) and the small, localized nature of the required code change, an automated system that scans for similar conditions could reasonably infer the missing case, leading to a high likelihood of successful patch generation."
astropy__astropy-14598,35,medium,60,"Only a single file is touched and the diff is just three lines, so the code change itself is small.  However, the bug lives in FITS-header parsing logic: it involves regular-expression matching of a keyword/value/comment field and the special FITS escape rule that a literal quote is represented as a doubled quote inside a string.  Fixing the bug requires (1) realising that blindly replacing ""''"" with ""'"" corrupts the legal representation of the empty string, and (2) noticing that the regex can over-match unless it is anchored to the end of the card.  That demands some domain knowledge of FITS headers and careful reasoning about edge-cases that occur only at certain character counts.  An AI supplied only with the failing example and the source could probably locate the erroneous replace() call and suspect it, but adding the regex end-anchor is less mechanical.  Overall the change is not algorithmically complex but it is more than a typo fix, so the task is moderate in complexity and moderately solvable by automated tools."
astropy__astropy-14995,12,easy,82,"The patch touches a single file and changes just one conditional branch, replacing a check for the operand object being None with a check for its mask attribute being None. This is a straightforward logic fix that does not involve new algorithms, data structures, or cross-module interactions, so the overall complexity is low. The bug is clearly described in the problem statement, including a minimal reproducible example and the exact stack trace, making it easy to identify that the issue arises when an operand exists but lacks a mask. Correcting the conditional requires only basic understanding of how the mask attribute should propagate. An AI system that parses the error message and inspects the surrounding code could plausibly infer this fix, especially given the small search space and explicit hint that v5.2 behaved correctly. Therefore, the task is classified as “easy” with a high likelihood of being solvable automatically."
astropy__astropy-7166,15,easy,85,The change touches a single file and effectively adds one logical condition: properties (data descriptors) are now treated like regular functions when inheriting docstrings. No new algorithms or architectural changes are introduced; understanding that `inspect.isdatadescriptor` identifies properties is sufficient. An AI with basic Python reflection knowledge and awareness of the bug description could infer this fix through pattern matching. Therefore the task is low-complexity and highly solvable.
astropy__astropy-7336,15,easy,85,"The bug is localized to a single conditional statement in one file. The failure is clearly described: when the return type annotation is None, a conversion method is incorrectly invoked. The required fix is to extend the existing condition so that None is treated the same as an empty annotation. This requires minimal code change (one line), no new algorithms, and only basic understanding of Python typing and the decorator’s intent. Given the clarity of the stack trace and problem statement, an AI system can reliably infer the correct adjustment, making the task highly solvable with low complexity."
astropy__astropy-7606,28,medium,82,"The patch touches a single file and changes ~10 lines, making the code alteration itself relatively small. The fix, however, relies on a correct understanding of Python’s data-model semantics: __eq__ should return NotImplemented, not False or raise, when it cannot handle the operand, so that Python can fall back to the reflected comparison or ultimately return False. Recognizing that the original code’s attempt to convert ‘other’ to a Unit object can raise TypeError and that this should be intercepted and mapped to NotImplemented requires some domain insight into both the astropy.unit API and Python operator overloading rules. Thus the task surpasses a trivial patch (simple typo/constant) but remains limited in scope and algorithmic complexity. An AI with basic knowledge of Python equality mechanics and the error trace could feasibly suggest the try/except pattern and NotImplemented return, especially since the problem statement gives a concrete failure scenario and desired behavior (“Should be False”). Hence the solvability is high but not trivial, earning an 82% estimate. Overall, the change falls into the lower end of moderate complexity."
astropy__astropy-7671,30,medium,75,"Only a single file is touched and fewer than 10 functional lines are added. The core change is adding a regex-based sanitiser that strips non-numeric qualifiers (dev, rc, etc.) from the version string before it is passed to distutils.version.LooseVersion, thereby working around a known LooseVersion comparison bug. The logic itself is straightforward and does not require deep architectural knowledge of Astropy, but it does require awareness of Python version-comparison quirks and PEP 440 semantics, which elevates the task above a trivial fix. Given the explicit failure example in the problem statement, an automated agent could reproduce the error locally and infer that normalising the version string or switching to a different parser solves the issue; several workable patches (regex strip, split on non-digits, use packaging.version) are possible, making the search space manageable. Therefore complexity is moderate, and solvability is relatively high."
astropy__astropy-8707,30,medium,85,"The patch spans two source files and adds ~40 lines, mainly to handle Python 3 byte/str distinctions. No new algorithms or data structures are introduced; the change is localized to decoding byte input and adjusting constant types. Understanding ASCII vs unicode in FITS headers and ensuring backward compatibility requires moderate domain knowledge, but the logic itself is straightforward string/bytes handling. The problem statement is explicit about the required behavior (accept both unicode and bytes, decode bytes with latin-1), so the solution space is narrow and well-defined, making it highly achievable for an automated system. Overall complexity is moderate, placing it in the 'medium' category, while the clear requirements and limited scope give it a high solvability score."
astropy__astropy-8872,35,medium,65,"The bug is localized to the dtype-selection logic in the Quantity constructor: float16 values were inadvertently routed through a branch intended for non-float types because the previous predicate relied on numpy.can_cast(np.float32, value.dtype). Fixing it merely required tightening the condition so that only integer (and later object) dtypes trigger the float promotion. The patch touches a single file and fewer than twenty lines, with no algorithmic overhaul or cross-module impact, hence moderate (≈35%) complexity. It still demands an understanding of numpy dtype kinds and of how astropy handles Quantity construction, which moves it beyond a trivial regex change and into the “medium” category. An AI system supplied with the symptom (float16 being upcast) and the surrounding code could plausibly deduce the overly broad condition and refine it, giving a better-than-even solvability likelihood (~65%). However, crafting the exact dtype checks and preserving existing integer/object coercion requires some domain reasoning, preventing a very high solvability score."
django__django-10097,20,easy,85,"The fix consists of a one-line adjustment to a regular expression in a single file. No new functions, algorithms, or cross-module interactions are introduced. The main challenge is understanding that the username/password sub-pattern should exclude the characters "":"", ""@"", and ""/"" and then translating that requirement into a negative character class in the regex. For an AI system, this is a direct mapping from the problem statement to code: replace \S with a more restrictive class ([^\s:@/]). Given the clear description of the bug and expected behavior, plus the minimal scope of the change, the task is straightforward and highly automatable. Some familiarity with regular-expression syntax is required, but no deep domain knowledge or architectural insight is needed."
django__django-10554,60,hard,30,"Although the actual diff is short and affects only two files, it touches the heart of Django’s SQL generation pipeline. Correctly handling ORDER BY clauses in the presence of UNION requires deep understanding of how the ORM maps expressions, aliases, and positional references to SQL. The fix entails detecting when an ORDER BY expression lacks a projection in the SELECT list, dynamically adding that projection, and updating positional indexes—subtle logic that must preserve all existing behaviour across databases. This demands expertise in Django internals, SQL semantics, and compiler.py conventions. An AI working solely from the high-level bug description would struggle to identify the low-level cause and craft a safe solution without extensive integration tests. Therefore the change is reasonably complex (60%) and classified as “hard”, while the likelihood that an AI could autonomously generate the correct patch from the description alone is relatively low (30%)."
django__django-10880,10,easy,90,"The bug is a straightforward string formatting issue: when both DISTINCT and a CASE expression are used in an aggregate, the generated SQL lacks a space, resulting in invalid syntax. Fixing it only requires adding a trailing space to the 'DISTINCT' keyword. The change touches a single line in one file, involves no algorithmic work, and demands only minimal familiarity with SQL and Django’s query compiler. Therefore, complexity is very low. Given the precise problem description that points directly to the missing space and the tiny, localized fix, an automated system or a developer could reliably generate the correct patch with a high probability, yielding a high solvability score."
django__django-10914,5,easy,95,"The fix is a single-line change that replaces a None default with the octal constant 0o644 in Django’s global settings. No algorithms, control flow, or multi-file interactions are involved; only a constant value is updated. The problem statement explicitly spells out the desired change (“Set default FILE_UPLOAD_PERMISSION to 0o644”), so an AI needs minimal context to generate the correct patch. Domain knowledge is limited to understanding Unix file permissions, which is straightforward. Because of the clarity and minimal scope, the task is highly solvable and sits at the very low end of complexity."
django__django-10973,35,medium,80,"The change touches one file and mainly replaces a custom temporary .pgpass-file mechanism with passing PGPASSWORD through subprocess.run’s env argument. No new algorithms are introduced; instead, existing code is simplified (about 40 lines removed, ~5 added). The required knowledge is moderate: familiarity with Python’s subprocess module, environment variable handling, PostgreSQL client behavior, and basic signal management. The problem statement clearly describes what must be done, making the desired patch easy to infer. An AI with code-transformation capability and minimal domain awareness could implement this with high likelihood, so solvability is high. However, it isn’t trivial boilerplate—understanding safety/security implications and retaining signal handling pushes it above ‘easy’, but not into genuinely ‘hard’ territory, resulting in a medium complexity rating."
django__django-10999,20,easy,70,"The change is confined to a single regular expression in one file, replacing three overlapping “-?” modifiers with a single optional sign captured at the start of the time portion. No algorithmic logic or multi-module interactions are involved; only regex syntax knowledge is needed. The problem statement clearly describes the bug, pinpoints the faulty sub-pattern, and even provides the corrected pattern, so an automated system can transform the code with straightforward text manipulation. The main challenge is recognizing how the look-ahead interacts with negative numbers, but this is a localized, well-defined issue. Therefore the task is low in complexity, falls in the 'easy' category, and is highly solvable by an AI given the explicit hint, though not completely trivial (hence 70% rather than >90%)."
django__django-11066,15,easy,85,"The patch touches a single line in one file, changing a method call by adding an existing optional argument (`using=db`). No new algorithms, data structures, or cross-module interactions are introduced. Although it requires awareness of Django’s multi-database API, that knowledge is common for anyone familiar with the framework and can also be inferred from the problem description that explicitly names the fix. Therefore the change is simple and localized (low complexity). Because the desired modification is clearly stated and has only one obvious correct form, an automated system or pattern-matching AI has a high chance of generating the correct solution (high solvability)."
django__django-11087,60,hard,30,"The change is confined to a single file and adds only ~25 lines, but it touches the heart of Django’s cascaded-delete machinery. The patch must respect subtleties of signal dispatching, select_related interaction, and relation introspection, and must calculate the minimal set of columns required for safe deletion. Correctness relies on intimate knowledge of Django’s Collector algorithm, query construction, and model meta-internals; a mistake could silently corrupt data or break signal contracts.

While the problem statement clearly explains the observed failure (UnicodeDecodeError caused by fetching unnecessary columns), devising the precise fix requires understanding why those columns are fetched, how to defer them safely, and when it is illegal to do so (e.g., when delete signals are present). An AI would need to reason about all these edge cases and craft the chain/only logic accordingly, which is significantly harder than a straightforward bugfix. Therefore, the task is complex (60%), categorized as hard, and has a relatively low but non-zero solvability score (30%)."
django__django-11095,15,easy,85,"The change involves adding a single hook method (get_inlines) that simply returns an existing attribute by default, and modifying one line so that get_inline_instances uses this new hook. Only one file is touched with a net change of a few lines and no algorithmic complexity. It requires minimal knowledge of Django’s admin internals and follows a common hook-pattern seen elsewhere in the codebase, so an AI can infer the exact modification from the problem statement alone. The absence of a test patch lowers certainty slightly, but the task is still well-defined and highly solvable."
django__django-11099,10,easy,85,"The fix involves a two-line change in a single file, replacing the regex end-of-line token '$' with '\Z'. No algorithmic work or architectural understanding is needed—just knowledge that '$' accepts a trailing newline in Python regexes. The problem statement explicitly explains both the bug and the exact replacement pattern, so an AI can reliably perform a text substitution after locating the validator definitions. Thus complexity is minimal and solvability is high."
django__django-11119,12,easy,88,"The patch touches a single file and adds one argument to an existing constructor call. No new algorithms or structural changes are introduced. The problem statement explicitly describes the root cause (autoescape flag not forwarded) and implicitly the solution (pass autoescape=self.autoescape when creating the Context). Generating this fix only requires locating the relevant line and understanding that Context accepts an autoescape parameter—basic familiarity with Django templates, not deep architectural insight. Given the clarity of the description and the minimal code modification, an automated system or even simple pattern-matching logic could reliably produce the correct fix, hence the high solvability score. The task is straightforward, with negligible algorithmic or integration complexity."
django__django-11133,15,easy,90,"The fix involves adding `memoryview` to an `isinstance()` check so that Django’s HttpResponse converts memoryview objects to raw bytes the same way it already handles bytes. Only one line in one file is changed, no algorithms or cross-module effects are introduced, and the desired behavior is clearly spelled out in the problem statement. Generating this patch mainly requires recognizing that `bytes(memoryview_obj)` yields the needed data and updating the conditional accordingly. Because the change is minimal, well-scoped, and the required Python behavior is well-known, an automated system could reliably propose the correct modification, leading to a high solvability score and a low complexity rating."
django__django-11138,55,hard,45,"The fix spans three different database backends (MySQL, Oracle, SQLite) and alters both Python-level helpers and SQL generated strings. Although the individual edits are small, they require solid understanding of Django’s timezone handling rules, the DB-specific SQL syntax (CONVERT_TZ, FROM_TZ, SQLite UDFs), and how connection.timezone_name is populated. Propagating the connection time zone into SQLite’s UDFs and changing their call signatures adds hidden coupling that isn’t obvious from the symptom description alone. An implementer must search multiple files, ensure no regressions in non-tz scenarios, and keep behaviour consistent across backends. These cross-cutting, framework-specific adjustments push the task beyond simple pattern replacement. While the bug is clearly described, crafting a comprehensive patch without running Django’s extensive test suite is challenging, giving a moderate likelihood that an AI could succeed but not high certainty."
django__django-11141,38,medium,62,"The change touches only one method in a single file and removes a guard that incorrectly rejected namespace-style migration packages. No new algorithms are introduced; the fix is essentially deleting an obsolete check and slightly adjusting the logic that classifies apps as migrated/unmigrated. Nevertheless, the developer must understand Python’s packaging rules (difference between __file__ and __path__, implicit namespace packages) and how Django’s migration loader uses those attributes. That domain insight elevates the difficulty above ‘easy’, but the code modification itself is short and isolated, so overall complexity is moderate. An AI that parses the problem statement—where the cause (unused __file__ check) and desired behaviour are explicitly described—could reasonably infer that the check should be removed and the migrated/unmigrated classification updated, giving a better than even chance (~62%) of producing the correct patch."
django__django-11149,40,medium,45,"The change touches a single core framework file (django.contrib.admin.options) and modifies permission-checking logic for auto-created many-to-many through models. Although only ~40 lines are altered, understanding why view-only users could edit inlines demands knowledge of Django’s permission model, the special case of implicitly generated through tables, and how the admin resolves permissions. Implementing the fix involves writing a helper to map from the implicit model back to the actual target model and updating four permission methods consistently. No complicated algorithms are needed, but the patch must integrate with Django’s existing permission codename utilities and uphold the guarantee that ‘change’ implies ‘view’. An AI could infer the need to tighten permission checks from the description, yet identifying the correct place to intervene and the nuances of related/add/change/delete logic without failing other edge cases is non-trivial, giving a moderate solvability score."
django__django-11163,10,easy,85,"Only one line of code is modified in a single file. The fix replaces a truthiness check with an explicit None comparison, a common Python pattern to distinguish between an empty list and the absence of a value. No algorithmic changes, data structure adjustments, or multi-module interactions are involved. The required domain knowledge is minimal: understanding how Python evaluates empty sequences as False and knowing the expected behavior of Django’s model_to_dict helper. The problem statement explicitly points out the faulty line and suggests the correct condition, so an automated system or a developer can implement the patch with little effort. Therefore, the task is low in complexity, falls into the ""easy"" category, and is highly solvable given the clarity of the requirement."
django__django-11179,15,easy,90,"The fix consists of adding a single line that sets the primary-key attribute of a model instance to None after it has been fast-deleted. Only one file is touched and no algorithmic changes are involved; the change is a straightforward state update following the deletion. Although basic familiarity with Django’s ORM internals is helpful, the required domain knowledge is minimal because the problem statement explicitly points to the exact line to modify and describes the expected behaviour. Therefore the task is low in complexity and highly solvable by an automated system."
django__django-11206,18,easy,82,"The fix touches a single function in one file and adds about 8 lines of straightforward logic. It only requires checking whether the absolute value of the Decimal is smaller than 10^-decimal_pos and, if so, replacing it with zero. There is no intricate algorithm, no interaction with other parts of the framework, and no need for deep architectural insight. An AI model that understands basic string/Decimal manipulation and the semantics of decimal_pos could infer this solution from the clearly stated problem description and examples, especially because the desired behavior (render the value as 0.00… when it is too small) is explicitly spelled out. Therefore the task is low-complexity (≈18%), falls in the ""easy"" category, and has a high likelihood of being solved correctly by automated code generation (≈82%)."
django__django-11211,20,medium,55,"The patch touches a single file and adds only three lines of functional code, so the code-change itself is simple (≈20% complexity). However, deciding to override UUIDField.get_prep_value to coerce incoming strings to Python UUID objects requires understanding how Django’s GenericForeignKey, prefetch_related, and field preparation pipeline interact—knowledge that is not obvious from the symptom alone. Therefore the task is classified as “medium”: the fix is tiny once the root cause is known, but finding that root cause calls for moderate framework expertise. From an automated-repair perspective, the clear bug description and the small search space give a reasonable chance for an AI to guess the solution, yet the need for specific Django internals knowledge lowers the probability. An estimated 55% solvability reflects this balance: feasible but far from trivial."
django__django-11239,15,easy,90,"The patch touches a single file and adds a handful of straightforward lines that pull additional SSL-related parameters from the database connection dictionary and expose them as environment variables before spawning the psql shell. No algorithmic work, data structure changes, or multi-module interactions are required. Understanding that psql reads its SSL settings from environment variables is minor domain knowledge and well-documented. Because the problem statement explicitly lists the missing parameters and states that the fix is trivial, an AI could confidently pattern-match the existing handling of password to replicate it for the four SSL parameters. The solution space is very small and unambiguous, leading to high solvability with low complexity."
django__django-11265,55,hard,40,"Although the final fix touches only a single file with a small diff, the change occurs deep inside Django’s ORM query-generation layer. Correctly repairing the bug requires understanding how the ORM builds sub-queries, propagates FilteredRelation metadata via the private _filtered_relations mapping, and later optimizes the resulting JOIN tree in trim_start(). Simply reproducing the stack-trace message is easy, but identifying that exclude() creates a fresh Query object which silently loses filtered-relation information—and that join-trimming must also respect filtered-relation INNER JOINs—demands intimate knowledge of Django internals. There are no algorithmically heavy additions, yet the conceptual coupling between filtered relations, alias maps, join types, and subquery generation elevates difficulty. An automated system relying mainly on pattern matching would likely copy the _filtered_relations attribute (the obvious hint in the user’s analysis) but could miss the second, subtler change preventing incorrect join trimming, leading to silent logical errors. Hence the task is complex (≈55%), falls in the “hard” category, and an AI has a moderate but less-than-even chance (≈40%) of producing the full, correct patch from the problem description alone."
django__django-11276,22,easy,88,"The change touches a single module and primarily consists of removing a hand-rolled escape/unescape implementation and delegating to the Python stdlib html.escape()/html.unescape(). No new algorithms or cross-module interactions are introduced, and the behavioral difference (&#39; vs &#x27;) is documented in the problem statement. Implementing the fix requires minimal code edits: import the html module, delete a mapping constant, update two function bodies, and replace a few call sites. An AI system only needs basic knowledge of the stdlib and string handling to generate this patch, making the task highly solvable. The low line count and absence of complex logic keep the overall complexity small."
django__django-11292,20,easy,90,"Only one file is modified with about a dozen lines changed. No new algorithms or deep architectural knowledge are required—just wiring an existing stealth option into the public CLI. The tasks (adding an argument, adjusting a constant set, and tweaking one conditional) are straightforward and largely mechanical once the developer understands Django’s management-command pattern. An AI could reliably infer all necessary edits from the problem statement because the desired behavior (expose --skip-checks) is explicitly described. The main challenges are minor: knowing to drop skip_checks from base_stealth_options and updating execute() to access the option safely. Overall complexity is low and the solution space is narrowly constrained, so solvability is high."
django__django-11299,30,medium,65,"The patch touches a single file and consists of adding one argument to a recursive call, so the code change itself is small. However, it sits in Django’s core query-construction logic and affects how CheckConstraint SQL is generated, which requires understanding of ORM internals, the difference between Col and SimpleCol, and how the simple_col flag must propagate through nested Q objects. Identifying that the bug stems from the flag being lost during recursion demands reading several layers of code and understanding the interaction between AND/OR connectors, giving the task moderate complexity rather than trivial. Because the problem description is clear, reproducible, and pinpoints the symptom, and the fix is localized once the root cause is found, an automated system with access to tests and code could plausibly discover the missing parameter. Therefore the solvability is judged better than average but not trivial."
django__django-11333,-1,error,-1,Failed to parse response
django__django-11400,45,medium,60,"The fix touches three core files (admin filters and two model field modules) and changes several functions that interact across the Django admin and ORM layers. While no sophisticated algorithms are introduced, understanding why an empty order_by() call removes Meta.ordering and how to preserve/override it requires moderate knowledge of Django’s internals. The solution introduces a small helper, propagates ordering correctly, and adjusts queryset construction to avoid wiping out default ordering. This cross-cutting awareness elevates complexity beyond a simple typo but remains short of major architectural work. Given the clear problem description that points to the exact faulty lines and explains the intended behavior, an AI with reasonable Django knowledge could deduce the required changes, though it must recognize the subtle effect of order_by(*())—making the task achievable but not trivial."
django__django-11433,30,medium,70,"The change touches a single function in one file and only adds a concise condition to an existing if-statement. No new algorithms or structural refactoring are involved, so overall technical complexity is low-to-moderate. However, understanding why the additional check is needed requires familiarity with Django’s ModelForm construction rules, default model values, widget behavior for omitted data, and the meaning of `empty_values`. That domain context lifts the task slightly above a trivial patch, placing it in the “medium” category.

For an automated system, the specification is fairly clear: defaults should only be preserved when the field is omitted AND the cleaned data is empty; otherwise, cleaned_data should overwrite the default. Once the relevant code path is located, adding the extra condition is straightforward. The presence of a well-defined boolean logic issue, limited code surface, and deterministic fix make it quite solvable, leading to a solvability estimate of about 70%."
django__django-11451,15,easy,90,"The change touches one file and adds only two lines that introduce an early-return guard. No new algorithms, data structures, or cross-module interactions are involved. The required domain knowledge is minimal: understanding that neither username nor password should be null before hitting the database. The problem statement is explicit about both the bug (unnecessary query) and the desired fix (shortcut when either credential is None), so an automated system can map the requirement directly to code. Edge-case considerations and timing-attack mitigation are acknowledged but do not complicate the implementation. Consequently, the task is straightforward, and an AI with basic comprehension of Python and Django conventions could reliably generate the correct patch."
django__django-11477,15,easy,80,"Only one line is modified in a single file. The fix consists of filtering out dictionary entries whose value is None, preventing optional but unmatched named capturing groups from being passed downstream. No new algorithm or cross-module interaction is introduced; it’s a straightforward conditional removal. An engineer (or an AI) only needs to understand that re.Match.groupdict() sets None for unmatched optional groups and that those should be removed before using the kwargs. This requires basic familiarity with Python’s regex API and Django URL resolvers, but no deep framework knowledge. Because the required change is minimal and the incorrect behaviour is well described, the likelihood that an automated system could propose the correct patch is high."
django__django-11490,35,medium,50,"Code-wise, the fix is a single-line addition in one file, so algorithmic and structural complexity is low. However, understanding why that line is necessary requires moderate knowledge of Django’s ORM internals—specifically how Query objects get mutated during UNION/VALUES processing and why shared state across compilers causes subsequent values()/values_list() calls to behave incorrectly. An AI must recognize that the correct remedy is to clone the Query to avoid side-effects, not simply reset or clear attributes. This demands insight into object mutability patterns and the requirement that combined queries stay independent. While the change itself is small, deducing it from the symptom described in the problem statement is non-trivial but still achievable with logical reasoning and familiarity with Django, leading to a medium difficulty rating and a solvability probability of about 50%."
django__django-11532,45,medium,65,"The patch touches six files across three subsystems (email construction, URL/email validation, and HTML utilities). While these are distinct areas of Django, the actual code change is conceptually simple: introduce a helper function that converts any non-ASCII domain to its IDNA Punycode form and call this helper where domains are handled. No new algorithms or deep refactoring are required; the fix is primarily a systematic replacement of repetitive try/except blocks with a shared utility.

Complexity is moderate because a developer must know every place in the framework where domain names are encoded, understand the interaction between email headers, message encoding, and validators, and ensure the change doesn’t break existing behavior. However, the logic itself is straightforward and does not involve complex data structures or performance concerns.

From an automated-repair standpoint, the problem statement is explicit about the root cause (non-ASCII hostnames crashing when encoded with latin-1) and even suggests the remedy (convert domain names to Punycode). An AI system with semantic search could locate all occurrences of direct .encode('idna') or missing handling and replace them with a common helper. Tests in Django’s suite would quickly guide the search for remaining failures. Therefore, while the breadth of edits adds some difficulty, the clear guidance and simple implementation give the task a good chance of being solvable by an advanced AI."
django__django-11551,40,medium,75,"The fix touches only one function in a single file (~30 lines), so the code change size is moderate, not a large-scale refactor. However, understanding the correct logic requires familiarity with Django’s admin validation rules, the interaction between getattr/hasattr, model._meta.get_field(), and Python descriptor behavior (fields that raise on class access). That domain knowledge makes the issue more than a trivial tweak but still far from algorithmically complex.  

Generating the correct patch is helped enormously by the problem statement: it explains the regression, enumerates all edge-case permutations, and even presents a working reference implementation. An AI given this description could largely transpose the suggested code, so the solvability is high. Without that explicit guidance it would be harder, as reproducing every admin.E108/E109 edge case from scratch would require deep Django expertise and extensive testing.  

Therefore, the task falls into the mid-range for complexity (40%) and is categorized as ""medium"". Because the statement is clear and almost prescriptive, an automated system has roughly a 75% chance of producing the correct patch."
django__django-11555,20,easy,85,"The patch touches a single function in one file and adds only three straightforward lines. It introduces a simple type check to bypass further processing when the ordering item is already an OrderBy expression. There are no algorithmic changes or interactions with other modules; the adjustment is purely defensive logic. While some familiarity with Django’s ORM internals (knowing what OrderBy represents) is useful, the core problem is directly signaled by the traceback (‘object has no attribute…’ on an OrderBy instance) so a pattern-matching fix is feasible. Therefore, the change is relatively simple (≈20% complexity), solvable by recognizing an unexpected type and handling it, and highly likely to be generated by an AI given failing tests and the clear stack trace."
django__django-11603,10,easy,95,"The patch alters a single file and adds just two lines to enable an existing flag (allow_distinct) on Avg and Sum aggregate classes. No algorithms or cross-module changes are involved. Understanding the fix only requires knowing that Django’s Aggregate base class already implements DISTINCT handling when allow_distinct is True. The problem statement explicitly describes the necessary change, so an automated system could directly map the requirement to setting the flag. Given the clarity and minimal code delta, the task is straightforward and highly solvable."
django__django-11728,35,medium,60,"Only one file is touched and fewer than 30 lines change, so the raw code change is small. The bug is an off-by-one and early-break issue inside two helper loops that walk a regex pattern to detect balanced parentheses. Fixing it requires understanding how the loop tracks bracket depth and when to record the substring; this is more involved than a typo but far from a major refactor. The main challenge is reasoning about nesting and indexing while ensuring the final group at the end of the pattern (with no trailing '/') is still captured. An AI with access to failing tests or a clear reproduction (as described in the problem statement) could bisect the function, recognize the premature break, and adjust the slice and break point. It doesn’t demand deep Django internals, only moderate familiarity with regex parsing and Python string slicing. Therefore the task sits in the lower-middle of the complexity scale and is reasonably achievable for automated repair, though not trivial."
django__django-11734,55,hard,30,"Although the actual code change is only a few lines, it spans three core ORM modules and touches low-level query-construction paths (field preparation, lookup preparation, and query splitting). Fixing this bug requires understanding how OuterRef objects propagate through annotations, Exists subqueries, exclude(), and negated Q() expressions in Django. The developer must know where an OuterRef can be mistakenly converted to a literal value and how that interacts with multi-column relations and split_exclude(). These are subtle, undocumented corners of Django’s internals. An AI would first have to reproduce the crash, trace the query compilation stages, and then identify the three independent places where OuterRef handling was wrong—something that is more reasoning-intensive than pattern matching. Consequently, while the change set itself is not large, the conceptual complexity is high, leading to a ‘hard’ rating and a relatively low probability that an AI could craft the exact fix without extensive internal knowledge or guidance."
django__django-11740,40,medium,65,"The fix touches only a single file with a handful of lines, so the code-change size is small, but it sits in Django’s migration autodetector – an internal, non-trivial component. Understanding why a dependency list must be added to AlterField operations requires knowledge of Django’s migration graph semantics and how AddField previously handled foreign-key dependencies. An automated system could plausibly deduce the missing call by comparing code paths for AddField and AlterField, especially if a failing test or exception highlights the unresolved relation, but it still needs framework-specific insight. Therefore the task is more involved than a simple pattern substitution (medium complexity) yet still reasonably approachable for an AI with access to the codebase and error output. Hence, moderate complexity (40%) and a better-than-even likelihood (65%) that an AI could generate the patch."
django__django-11749,35,medium,60,"The change touches a single file and adds roughly ten lines, so the code delta is small. However, fixing the bug requires understanding how Django’s call_command funnels keyword arguments into argparse, and knowing that options inside a mutually-exclusive group marked `required=True` must also be forwarded even if the individual option itself isn’t `required`. That demands some familiarity with both Django’s management-command helper and Python’s argparse internals, but no large-scale refactor or intricate algorithm is needed. An AI provided with the bug description and failing scenario could, with reasonable effort, deduce that the missing case involves `parser._mutually_exclusive_groups`; leveraging that structure to collect all options belonging to required groups is straightforward set comprehension logic. Thus the overall complexity is moderate, and the task is solvable, though not trivial, giving a mid-range solvability score."
django__django-11790,12,easy,88,"The patch touches a single file with only three lines added and modifies no other parts of the system. The required change is conceptually straightforward: re-add the maxlength HTML attribute that was lost in a previous refactor. Implementing this fix only requires basic familiarity with Django forms (knowing that widget.attrs controls rendered attributes) and understanding how to retrieve the max_length from the User model’s username field. There are no intricate algorithms, cross-module side effects, or data migrations involved, so the overall complexity is low. Because the problem statement explicitly identifies the missing attribute and references the earlier regression, an AI can infer the exact code addition with minimal exploration, leading to a high likelihood of generating the correct solution."
django__django-11815,30,medium,75,"The fix touches a single serializer method, replacing logic that previously serialized an Enum by its value with logic that serializes it by name. Only a few lines are changed and no new abstractions or algorithms are introduced, keeping code-level complexity low. However, understanding why the change is necessary requires moderate familiarity with Django’s migration serialization mechanism and Python’s Enum semantics—specifically, how values can be translated and therefore become unstable, whereas names remain constant. An AI equipped with the problem statement can infer that the solution is to reference the Enum member via its name (`Status['GOOD']`) instead of instantiating it by value, making the scope of the fix clear and isolated. Given this clarity and the limited code surface, an automated system has a good chance of generating the correct patch, though it still needs to know Django’s serializer factory is no longer required in this branch. Hence, complexity is moderate, and solvability is fairly high."
django__django-11820,35,medium,65,"The change is confined to a single method in one file (~6 new lines). It addresses a specific edge case: ordering strings that contain the alias ""pk"" in a lookup chain. The core logic fix is to recognize that ""pk"" is not a real field name and should be mapped to opts.pk before continuing traversal; additionally, traversal must stop if the resolved field is not relational. Understanding this requires moderate familiarity with Django’s model-checking internals and how Meta.ordering is validated, but no large-scale refactor or complex algorithm is involved. Therefore, complexity is moderate. Given a clear problem description that pinpoints the failing scenario (E015 on '__pk'), an AI with knowledge of Django is reasonably likely to synthesize the correct guard clause, yielding a better-than-even chance of success, though some insight into the validation traversal is needed, so solvability is not near certain."
django__django-11848,30,medium,65,"Only one file and a handful of lines are changed, so the code-base impact is small. The required adjustment, however, is more than a trivial constant swap: it has to implement the RFC rule of mapping two-digit years based on the current year and a 50-year window. That demands some date-arithmetic reasoning (deriving the current century, deciding when to subtract 100), but no deep architectural knowledge of Django.

An AI system that understands the English problem statement could craft this logic with moderate effort—the rule is explicitly described, and the modification is localized—so the solvability is well above average. Still, choosing a correct formula that handles edge cases (e.g., at century boundaries) introduces some room for error, preventing a near-certain solvability score.

Hence the change is moderately complex (30%), categorized as ""medium"", and has a roughly two-thirds chance (65%) of being automatically produced correctly."
django__django-11880,20,easy,85,"The bug is localized to a single method and the fix involves adding one line that deep-copies a dictionary to prevent shared mutable state. No algorithmic changes, no API surface impact, and only one file is touched. An AI system only needs to understand that mutable default attributes must be copied when cloning objects. The problem statement explicitly identifies the root cause and directs attention to the missing copy of error_messages, so the search space is very small. Therefore the change is low complexity (≈20%), belongs to the 'easy' category, and is highly solvable (≈85%) by automated tools or pattern-matching approaches."
django__django-11885,65,hard,40,"The fix touches two core Django modules and rewrites a non-trivial part of the deletion cascade algorithm. It introduces new data structures (defaultdicts), changes several public method signatures, batches fast deletes by model, constructs OR predicates with functools.reduce and Q objects, and adjusts select_related handling. Understanding and correctly modifying this code requires knowledge of Django’s ORM internals, query construction, and bulk operation limits, which elevates overall complexity. While the problem statement clearly describes the desired outcome (merge multiple DELETE statements into one per table), the path to reach that goal is intricate; an AI must navigate several inter-dependent concerns (signal listeners, batching, keep_parents, fast delete eligibility, etc.). Without dedicated tests in the prompt, the search space remains large and subtle bugs are easy to introduce, keeping the solvability moderate rather than high."
django__django-11951,15,easy,85,"The change touches one file and replaces a single assignment with two straightforward lines that mirror existing logic elsewhere in the codebase (bulk_update). No new algorithms or architectural considerations are introduced; it’s a simple guard to ensure the provided batch_size doesn’t exceed the backend-calculated maximum. Understanding requires only minimal familiarity with Python and basic comparison operators, plus noticing the analogous pattern already present in another method. Because the problem statement clearly describes both the bug and the desired fix (even providing the exact line and strategy), an automated system could reliably generate the correct patch. The simplicity of the change and explicit guidance drive a low complexity score and high solvability estimate."
django__django-11964,18,easy,92,"The patch adds a __str__ method to the Choices base class so that converting a Choices enum member to string yields its underlying value instead of the default Enum representation. Only one file is touched and the logic is a one-liner; no algorithms or cross-module considerations are involved. The required insight is simply understanding Python's Enum default __str__ and realizing it must be overridden to match Django’s expected behaviour in templates/API serialization. Because the fix is localized, obvious from the failing assertion in the description, and doesn’t require deep knowledge beyond basic Python/Django enums, an automated system has a high likelihood of generating the correct code."
django__django-11999,20,medium,80,"Only one file is touched and the functional change is to wrap the automatic creation of get_FIELD_display() in a hasattr() guard so the framework doesn’t overwrite a user-defined method. The algorithmic work is trivial (an if statement), but understanding where to put it requires familiarity with Django’s model field contribution process and Python’s attribute resolution order. Hence the change is slightly above a pure typo fix, but still far from complex.    

An AI given the bug report would likely search for where Django adds get_FIELD_display and notice the unconditional setattr; adding the existence check is straightforward, so the solvability is high. No broad architectural impact or cross-file interactions are involved, but some framework knowledge is necessary, placing the task in the “medium” bracket with low overall complexity."
django__django-12039,18,easy,85,"The fix touches one module and changes only a handful of lines. No new algorithms or architectural work is necessary—just correct string concatenation logic so that an extra space is inserted only when a non-empty suffix is present. Understanding the bug requires reading a small helper class and recognizing that col_suffixes may contain empty strings, but this is straightforward once the faulty output is reproduced. An AI system could reliably infer that the solution is to guard the suffix join with an emptiness check, especially given the clear examples in the problem statement. Test coverage is not provided here, yet the scope is limited and the correct adjustment is obvious, leading to a high solvability score."
django__django-12050,30,medium,85,"The fix touches a single function in one file and replaces a hand-rolled loop with a generic comprehension that rebuilds the iterable using type(value). The change is small and algorithmically straightforward, but it does require awareness of Django’s expression-resolution mechanics and understanding why preserving the concrete iterable type matters for certain ORM fields. Therefore the technical complexity is moderate (≈30%). An AI reading the problem statement could directly infer that the solution is to return the same iterable type instead of always converting to tuple, making the task highly solvable (≈85%), yet it still falls into the 'medium' category because some familiarity with Django’s internals is beneficial."
django__django-12125,25,medium,85,"The change consists of a one-line modification in a single file, replacing __name__ with __qualname__ when building the import path for a class value being serialized. While the code diff is minimal, recognizing that __qualname__ is required to correctly represent inner classes demands a working knowledge of Python’s data model and Django’s migration serializer. The problem statement is explicit and reproduces the bug clearly, so an engineer (or an AI) can infer the exact location and nature of the fix with little ambiguity. Given the limited scope, absence of algorithmic complexity, and straightforward unit-test expectations, overall complexity is low-to-moderate, and the likelihood of an AI generating the correct patch is high."
django__django-12143,15,easy,90,"The fix touches a single function in one file and only adds a call to re.escape() around a user-supplied string before it is interpolated into a regular-expression pattern. No new logic, branching, or multi-module interaction is introduced. An engineer (or an AI) needs to recognize that unsanitized interpolation into regex can cause unintended matching and data loss, and that re.escape() is the standard remedy. That knowledge is common and easy to apply. Because the required change is localized, well-described in the problem statement, and does not involve intricate algorithmic work or deep understanding of Django internals, the task is straightforward and highly automatable."
django__django-12155,30,medium,85,"The change touches two modules with ~20 lines modified, replacing a flawed custom docstring-trimming routine with Python’s built-in inspect.cleandoc. The logic fix is conceptually simple (skip the first line / dedent correctly) but requires awareness of PEP 257 rules and the existence of cleandoc, so it rises above a trivial typo but remains moderate in scope. An AI given the bug report would have strong guidance—the report pinpoints the offending line and even proposes the correct logic—making generation of a correct patch likely. Therefore complexity is modest, the task is medium difficulty, and solvability is high."
django__django-12193,25,medium,80,"The bug is caused by an in-place mutation of the attrs dictionary inside CheckboxInput.get_context(). Fixing it only requires creating a new dict that copies the existing attrs and forces 'checked': True. The change touches a single file and alters just a few lines, with no algorithmic challenges. However, one must understand Python’s reference semantics and Django’s widget initialization flow to realize why later widgets inherit the mutated dict, so it is slightly beyond a trivial typo fix. Given the explicit problem description pointing to the offending code line, an AI with basic Python and Django knowledge can reliably generate the patch, resulting in a high solvability percentage."
django__django-12209,30,medium,65,"Only a single conditional clause is modified, so the code change itself is tiny and algorithmically trivial. However, identifying that the optimization must be disabled when Model.save() is called with raw=True demands understanding of Django’s model-saving workflow, the purpose of the raw flag, and how loaddata relies on it. This domain insight elevates the task above a pure ‘typo fix’. An automated system supplied with a failing test that mimics fixture loading could plausibly discover that adding the “not raw” guard satisfies all cases, but the search space of alternative fixes (e.g., adjusting force_insert, tweaking state flags, etc.) is not negligible. Therefore overall complexity is moderate (≈30%), the task category is “medium”, and an AI repair tool with adequate context and tests has a better-than-even chance (≈65%) of finding this one-line fix."
django__django-12262,18,easy,80,"The change affects a single line in one file and involves adding an additional membership check (kwonly) to an existing conditional. No new algorithms or structural redesign is required; it's essentially a guard‐condition adjustment. Understanding Python’s keyword-only argument semantics and Django’s tag parsing is helpful, but the fix can largely be deduced from the error description and existing code structure. Because of the minimal scope and clear intent, the task is low in complexity and fits the “easy” category. An automated system with basic comprehension of the surrounding code and the exception message could likely generate the correct patch, hence a high solvability score."
django__django-12273,40,medium,45,"The actual code modification is small (one file, +3 lines) and contains no sophisticated algorithm, which keeps raw code complexity low. However, understanding why those lines are necessary requires non-trivial knowledge of Django’s multi-table inheritance model, specifically how child objects share a primary key with their parent through an implicit OneToOneField. The developer must notice that BaseModel._set_pk_val should update every parent link’s underlying field whenever the pk is changed so that parent and child remain consistent. Identifying this subtle inconsistency and knowing the correct meta APIs to access parent links goes beyond simple pattern matching, placing the task in the “medium” category and around 40 % complexity.

For an AI system, the bug description gives a reproducible scenario and pinpoints the failing behavior (resetting pk to None on a subclass doesn’t propagate), but it does not explicitly state which internal method is wrong. The solution space is narrow—only a few spots in the ORM deal with pk assignment—yet selecting the exact hook and writing the correct loop over _meta.parents demands framework-specific insight. Without extensive Django internals knowledge hard-coded into the model, many AI systems would struggle, yielding a solvability estimate of roughly 45 %."
django__django-12276,30,medium,65,"The change affects a single file and only adds/removes a handful of lines. No new algorithms are introduced; the fix simply moves an override (use_required_attribute) from the subclass (ClearableFileInput) to its parent (FileInput) so that the HTML 'required' attribute is suppressed when an initial file already exists for any FileInput-based widget. 

Despite its small size, the patch requires understanding of Django’s form/widget inheritance hierarchy and how the 'required' attribute is determined at render time. An engineer (or AI) must realize that the logic belongs in the base class rather than the subclass to cover all cases. That knowledge pushes the task above a trivial pattern-matching fix, but the scope is still limited, with no cross-module impact or complex dependencies.

Given a clear problem statement and a contained change area, an AI with moderate framework knowledge has a good chance of producing the correct patch, though it must reason about inheritance and side-effects across widgets. Hence the solvability is placed in the mid-60s."
django__django-12304,10,easy,92,"The patch touches a single file and adds one line that sets an attribute to prevent Django’s template engine from invoking enum classes. No algorithms or multi-module interactions are involved, and the problem statement explicitly points out the required fix (adding do_not_call_in_templates = True). Generating this change requires minimal domain knowledge: understanding that Django’s template system skips callables marked with this attribute. Because the task is small, well-scoped, and the solution is effectively spelled out in the description, an automated system has a very high likelihood of producing the correct patch. Hence low complexity, an “easy” category, and a high solvability score."
django__django-12308,25,easy,80,"The fix touches one file and adds five straightforward lines, introducing a special-case branch for JSONField. No algorithmic work or multi-module interaction is involved, keeping inherent complexity low (~25%). While a bit of Django ORM/admin knowledge is required (knowing about JSONField.get_prep_value and how display_for_field is used), the change is largely a pattern of ""detect specific field type, transform value, else fall back"", so it falls in the ""easy"" bucket. The problem statement explicitly hints at the desired solution (call prepare_value / get_prep_value and fall back on json.dumps handling), so an AI has clear guidance. Only minor creativity is needed to wrap the call in a try/except for TypeError. Given that the scope is tiny, the requirements are clear, and the solution space is narrow, an AI’s chance of producing the correct patch is high (~80%)."
django__django-12325,45,hard,35,"Although the final diff is only a few lines, it touches Django’s core metaclass logic for model creation and multi-table inheritance (MTI). Understanding why adding a parent_link filter in django/db/models/base.py and removing a runtime ImproperlyConfigured check in django/db/models/options.py fixes the issue requires deep knowledge of Django’s model field resolution, automatic primary-key discovery, and OneToOneField semantics. The bug manifests only when multiple OneToOneFields exist, one of which is the MTI parent link, so an accurate fix demands tracing how _meta.parent_links is populated during class construction. An AI must navigate a large, complex framework, identify the improper interaction, and know that only fields marked parent_link should participate. Without explicit tests, reproducing and validating the behaviour is harder. Therefore the task is hard (domain-specific, not a simple pattern change) and moderately complex, but still solvable given clear examples in the problem statement; hence a solvability estimate of roughly one-third."
django__django-12406,35,medium,60,"The change affects two framework-core files and introduces a small, well-scoped behavioral tweak: suppressing the automatic ""blank/-------"" choice for RadioSelect widgets when the related model field is declared with blank=False. Although knowledge of Django’s ModelChoiceField construction pipeline is necessary, the required code modifications are straightforward (propagating the blank attribute and extending an existing conditional). No new algorithms are introduced, and the control flow remains simple, keeping complexity moderate. An AI system could reasonably infer the needed fix from the concise problem statement because the desired outcome is clearly described, and the area of code to adjust (formfield generation for ModelChoiceField) is limited and well-known in Django. However, it still requires understanding several interacting components (ModelForm → formfield() → ModelChoiceField → widget behavior), so generating the exact patch is not trivial. Absence of explicit tests reduces feedback signals, slightly lowering solvability."
django__django-12419,8,easy,90,"The patch modifies a single setting constant in one file, changing SECURE_REFERRER_POLICY from None to 'same-origin'. No algorithms, cross-module interactions, or deep framework knowledge are required—just understanding that the default should be updated for better security. Because the problem statement explicitly states the desired new value, an automated system can confidently generate the correct one-line change, making solvability very high. The lack of accompanying tests slightly lowers solvability but the task remains straightforward. Overall this is a trivial constant update with minimal complexity."
django__django-12663,40,medium,60,"The change affects only one file with a two-line modification, so the code delta itself is small. However, understanding why `select.field` is wrong and `select.target` (falling back to `.field`) is correct requires knowledge of Django’s internal `Col` expression, foreign-key preparation, and how `output_field` is used during lookup preparation. Identifying that the crash is due to `get_prep_value()` receiving a `SimpleLazyObject` instead of a `User` PK and tracing that back to `output_field` demands moderate familiarity with the ORM internals, but no large algorithmic redesign. An AI with access to the traceback, the failing scenario, and the codebase could plausibly infer that `.target` holds the proper `Field` for FK columns and craft this small fix, yet it still needs some domain insight, so the solvability is not trivial but reasonably attainable."
django__django-12708,20,easy,80,"The fix changes a single function call in one file, adding an extra key ('unique': False) to the kwargs so that _delete_composed_index filters out the unique constraint when dropping an index_together entry. No new algorithms or cross-module interactions are introduced; it’s a straightforward bug fix that hinges on understanding the meaning of the existing helper and the shape of its filter argument. An AI system equipped with the stack trace and a minimal mental model of Django’s constraint flags could infer that both the index and unique constraints were being matched and that specifying unique=False would resolve the ValueError. The problem statement is clear about the failure scenario, so generating the correct patch should be highly achievable. Overall complexity is low, so the task falls in the “easy” category with high solvability."
django__django-12713,25,medium,80,"The patch touches a single method in one file and only adds a guard clause (`if 'widget' not in kwargs`) around the existing widget-selection logic. No algorithms or cross-module interactions are introduced. However, it requires awareness of Django admin’s formfield customization conventions and consistency with the analogous `formfield_for_foreignkey()` implementation, so it is slightly above a trivial edit. An AI that sees the problem statement ('Allow overriding widget …') and the surrounding code pattern can infer that preventing the automatic override when a custom widget is already supplied is the fix, making the task highly solvable. Lack of accompanying tests lowers certainty a bit, but the change scope is clear and contained."
django__django-12741,15,easy,85,"The change touches only two files and involves removing an unused parameter and updating the call-sites accordingly. No new algorithms, data structures, or deep framework alterations are required—just adjusting a function signature and substituting a constant value (self.connection.alias) in one place. The required domain knowledge is minimal: understanding how Django’s DatabaseOperations interacts with transactions. For an automated system, the failure would likely surface as a TypeError about an unexpected argument count, leading directly to the fix of dropping the parameter. Because the specification is explicit and the diff is mechanical, it is highly solvable by an AI-driven repair system with pattern-matching capabilities, yielding a low complexity and high solvability score."
django__django-12754,45,hard,40,"The fix touches only one file and adds ~10 lines, so the code delta is small, but it lives in Django’s migration autodetector – a subsystem that reasons about model state transitions and operation dependencies. To devise the correct patch, you must: (1) understand how Django orders migration operations, (2) recognize the clash that occurs when a field is simultaneously removed from a base model and added to a child model, and (3) know how to express an inter-operation dependency so the RemoveField executes before the CreateModel. This requires deep framework knowledge rather than generic programming skills. The algorithmic work is modest (set arithmetic to identify overlapping field names) yet the conceptual problem is subtle.

An AI that only sees the high-level bug description would have to locate the relevant part of the autodetector, infer why the current dependency graph is insufficient, and craft the correct additional dependencies with the right tuple shape. Without extensive prior understanding of Django’s internal APIs, that is challenging, especially because there is no accompanying test patch to guide TDD. Thus solvability by automated repair is limited (≈40%). The task is therefore classified as “hard” even though the textual change is brief."
django__django-12774,35,medium,65,"The fix touches a single method in one file (~10 added lines) and introduces straightforward list-comprehension logic. No new algorithms or cross-module refactors are required, so inherent code complexity is low–moderate. However, correctly addressing the bug needs knowledge of Django’s model metadata API: understanding that UniqueConstraint objects live in Meta.total_unique_constraints, that single-field constraints imply field-level uniqueness, and that in_bulk() must therefore accept those fields. An AI must (1) parse the error message, (2) realize that .unique alone is insufficient, (3) locate total_unique_constraints, and (4) filter to length-1 constraints—concepts that demand some framework familiarity but little algorithmic creativity. Because the requirement is clearly described and the change is localized, the task is reasonably solvable, though not trivial, giving it a mid-60s solvability estimate."
django__django-12858,30,medium,65,"The bug is localized to Django's model ordering validation logic and is fixed by a three-line change in a single file, adding a call to fld.get_lookup() alongside fld.get_transform(). While the patch itself is short, understanding why lookups must be accepted (and how Django distinguishes transforms from lookups) requires some familiarity with Django’s ORM internals and the previous regression (#29408). Therefore the task is more than a trivial typo fix but doesn’t involve sophisticated algorithms or multi-module refactoring. An AI given the problem statement could reasonably infer that lookups should be treated like transforms in this context, but it still needs domain knowledge of the relevant API functions, making the solution moderately achievable but not guaranteed."
django__django-12965,30,medium,60,"The code change is physically very small (one file, two added lines) and involves no new algorithms, keeping raw complexity low. However, understanding why adding `self.query.get_initial_alias()` fixes the regression requires knowledge of Django’s query compiler internals—specifically how `alias_map` is populated and how `single_alias` decides whether to emit a plain DELETE or a DELETE with a sub-select. That domain insight moves the task beyond a trivial typo fix into the moderate range. 

For an AI, the bug description is clear about the undesired SQL output and hints that the logic deciding between the two SQL forms is faulty. Mapping that to the exact missing step (ensuring the base table alias is registered before counting aliases) is achievable but not obvious; it demands familiarity with Django ORM internals or good pattern-matching against similar historical fixes. Without unit tests provided, iterative feedback is limited, reducing confidence somewhat. Consequently, solvability is moderate rather than high."
django__django-13012,22,easy,58,"The patch touches a single file and adds just three lines: a trivial delegating method that forwards get_group_by_cols() to the wrapped expression. No new algorithms, data structures, or multi-module interactions are introduced, so intrinsic code complexity is low. The bug fix does, however, rely on understanding how Django’s ORM decides which expressions belong in the GROUP BY clause; once it is clear that ExpressionWrapper must expose the same grouping behavior as its inner expression, the solution is straightforward. An AI system equipped with the problem description, error message, and access to Django’s code could discover that the absence of get_group_by_cols() causes constants to be grouped and can infer delegation as the fix. While this requires some framework-specific insight, the change is localized and pattern-like, making successful generation more than a coin toss but not guaranteed. Hence low-to-moderate complexity (22%), classified as ""easy"", with a solvability likelihood of roughly 58%."
django__django-13023,15,easy,90,"The change touches a single line in one file, adding two additional exception classes (TypeError, ValueError) to an existing except clause. No new logic, algorithms, or interactions with other parts of the codebase are introduced. Understanding the fix only requires recognizing that non-decimal inputs such as dicts raise TypeError/ValueError when passed to decimal.Decimal and translating those to Django’s ValidationError. Therefore, the task is simple and largely pattern-based.

Because the problem statement is clear—""DecimalField.to_python() should raise ValidationError instead of TypeError for dict input""—an AI need only modify the except list to include the extra exceptions. This is a straightforward conditional/exception-handling adjustment with an unambiguous single-line solution, giving a high likelihood of automated generation.

Domain knowledge needed is minimal: basic Python exception handling and familiarity with Django field validation, both common in typical training data. Consequently, complexity is low and solvability is high."
django__django-13028,30,medium,45,"The actual change is only a 3-line conditional guard in one file, so code-wise it is simple. However, understanding why the guard is necessary requires grasping Django ORM internals: a model instance that happens to have a Boolean field called ""filterable"" is mistakenly treated as an Expression object and the ORM blocks it. Realizing that the check should only run for genuine Expression objects (those implementing resolve_expression) involves reading and reasoning about the framework’s query builder. That pushes the task beyond a trivial typo fix into the moderate range. For an AI, reproducing this reasoning from the description alone is challenging—the failure scenario is subtle, no unit test is provided, and it depends on the interaction between model field names and the ORM’s filterable flag. Still, the final patch is concise and mechanically straightforward once the root cause is identified, so the solvability is not extremely low."
django__django-13033,40,medium,35,"The patch touches a single function in one file with a small diff (5 added lines, 1 modified), so the code change volume is moderate. However, it requires understanding Django's SQL compiler, the logic determining implicit ordering, and subtle differences between a fully qualified lookup path versus a field's attribute name. The main challenge is recognizing that when resolving an order_by clause that ends with ""_id"" on a self-referential FK, the comparison must use the last lookup piece rather than the whole lookup string to avoid appending the related model’s default ordering. This subtlety is non-trivial and demands familiarity with Django internals and query planning, but it doesn’t involve complex algorithms or large-scale refactoring, so overall complexity is around 40%. 

For an AI given only the symptom description, deducing the exact conditional change is difficult: it must trace the ORM path resolution, spot the incorrect equality check, and update it without breaking other cases. No guiding test patch is provided, reducing feedback for iterative search. While possible, the search space is large and bounded by nuanced framework behavior, so estimated solvability is 35%."
django__django-13089,15,easy,85,"The fix touches one file and adds a straightforward None-check before using cursor.fetchone()[0]. No algorithms or architectural elements are modified; it’s a classic defensive-programming patch (3 new lines, 3 removed). Understanding required is limited to knowing that fetchone() can return None when the SELECT yields no rows and that trying to subscript None triggers the reported traceback. There are no cascading effects across the code base. Because the back-trace pinpoints the exact failing line and the solution is a common pattern (guard against None), an AI system supplied with the failing test or stack trace would likely generate the correct conditional deletion statement. Therefore the task is low in complexity, falls in the ""easy"" bucket, and is highly solvable."
django__django-13109,30,medium,70,"The change touches a single line in one file and replaces _default_manager with _base_manager. Code-wise this is very small, but it requires knowledge of Django’s manager hierarchy and how model validation is expected to work in forms. Understanding that _default_manager may include custom filters while _base_manager never does is a piece of framework-specific domain knowledge, but it isn’t algorithmically complex. Because the problem statement clearly describes the undesired behavior and even suggests the exact fix, an automated system equipped with failing tests would have a good chance of applying this change. Therefore complexity is low-to-moderate (30%), the task is categorized as ""medium"" (needs framework understanding, not just syntax), and solvability is fairly high (70%) given explicit guidance and the minimal code delta."
django__django-13112,35,medium,60,"The patch touches a single method in one core Django file, changing ~5 lines. The logic change is conceptually simple—only lowercase the model part of an 'app_label.ModelName' string instead of the whole string—but understanding where to do this requires familiarity with Django’s migration serialization process and how app labels work. No new algorithms or multi-file coordination are needed, so overall complexity is moderate. An AI that can reproduce the error from the description and search the relevant code paths could plausibly derive the fix, but it still needs framework-specific insight (why lowercasing the entire dotted path is wrong), so solvability is neither trivial nor extremely hard."
django__django-13121,65,hard,35,"The patch touches 4 core modules across 3 back-ends and Django’s expression engine, removing an abstract date_interval_sql layer and re-architecting how timedelta literals are represented in expression trees. The fix requires deep knowledge of Django’s ORM internals (expression resolution, compiler, backend feature flags) and SQL capabilities of different databases. It isn’t an isolated bug: the solution demands understanding that mixing DurationField and non-native duration back-ends must route through Value(...) instead of a custom DurationValue plus backend-specific interval SQL. This multi-file, cross-layer adjustment elevates complexity to ~65% and fits the “hard” category. Given only the symptom (InvalidOperation during annotation) and no guiding tests, an AI would struggle to infer the need to delete DurationValue, adjust _combine(), tweak DurationExpression.compile(), and remove backend date_interval_sql, so the likelihood of generating the exact patch is low (~35%)."
django__django-13128,60,hard,30,"Although the final patch touches only a single file and introduces fewer than 50 net lines of code, it changes the point in Django’s expression-generation pipeline where type coercion is performed (moving logic from as_sql to resolve_expression and adapting DurationExpression). Correctly doing this requires: 1) intimate knowledge of Django’s ORM internals (CombinedExpression, DurationExpression, TemporalSubtraction, connection feature flags, the two-phase compilation of resolve_expression → as_sql); 2) understanding why the original FieldError is raised during type resolution, not SQL compilation; and 3) ensuring compatibility with back-ends that do or do not have native duration support. These subtle framework details make the task conceptually complex even though the diff is small. An AI that only sees the high-level symptom (“mixed types error”) would have to trace deep call stacks to identify the right insertion point, predict all edge cases (duration vs temporal, feature flags), and avoid regressions, which is unlikely without extensive domain knowledge and runtime experimentation. Consequently the change ranks as hard (≈60 % complexity) and the probability an automated system could synthesize the exact fix from the brief problem statement is low (≈30 %)."
django__django-13158,45,hard,38,"The patch changes just a few lines in a single file, but those lines sit deep in Django’s ORM query-building machinery. Understanding why Query.set_empty() must also mark each sub-query produced by union(), and why Query.clone() must deep-clone combined_queries, requires knowledge of how the ORM composes SQL, how WHERE clauses are stored, and how cloning prevents shared mutable state. The algorithmic work is simple, yet identifying the exact omissions and their side-effects is non-trivial and touches core framework behavior. For an automated system, the failing scenario (none() returning all rows after a union) is quite specific and not easily inferred from the public API alone; it demands reading internal code paths and deducing state interactions. Therefore the change size is moderate, but the conceptual difficulty is high, leading to a ‘hard’ classification with a complexity score of 45%. Because the bug is subtle and the fix relies on architectural insight rather than pattern matching, an AI without strong internal-code understanding has a limited (≈38%) chance of arriving at the precise solution solely from failing tests and the high-level description."
django__django-13195,40,medium,78,"The fix touches three files and adds ~20 lines, but it does not introduce new algorithms or deep refactoring. The main task is to thread a new parameter (`samesite`) through `HttpResponse.delete_cookie()` and update callers so the attribute is preserved, plus slightly adjust the `secure` flag logic. This requires understanding HTTP cookie rules (SameSite=None must be Secure) and Django’s helper methods, but the change is localized and straightforward once those rules are known. Because the problem statement explicitly states the missing behavior and even sketches out an almost-correct code snippet, an automated system with code-search and pattern-matching abilities has a good chance of synthesizing the final patch. The lack of accompanying tests lowers certainty somewhat, but overall the scope is clear and isolated."
django__django-13212,35,medium,70,"The patch touches a fair number of locations (≈70 call-sites across two core modules) but the actual logic change is uniform and straightforward: whenever a ValidationError is raised inside built-in validators, it must now include params={'value': value}. No new algorithms, data structures, or architectural changes are introduced—just a repetitive parameter addition and a few related param dictionary updates. Understanding where to add the param requires familiarity with Django’s validation flow and the ValidationError API, but once that concept is grasped the fix is essentially mechanical search-and-replace.

Complexity is therefore moderate (35%). Multiple files and contextual knowledge of Django are involved, yet the individual edits are simple.

An AI system with the failing tests would likely see AssertionErrors complaining about the absence of %(value)s substitution and deduce that every ValidationError in validators must supply the value. The change pattern is consistent, so programmatic reasoning or regex replacement is feasible, giving a relatively high solvability score (~70%). The main challenges are locating every relevant raise statement and ensuring no behavioural side effects, but this doesn’t demand deep architectural insight or novel algorithms."
django__django-13279,20,easy,85,"Only one file is modified and fewer than 15 lines are added. The change is a simple conditional branch that invokes an existing legacy implementation when a specific setting value ('sha1') is detected, plus extraction of that legacy logic into a helper. No new algorithm or cross-module refactor is required. Although some familiarity with Django’s session format helps, the problem statement explicitly guides the fix (""use the legacy encode() when DEFAULT_HASHING_ALGORITHM == 'sha1'"") making the required patch quite straightforward. Therefore the task is low in complexity and highly solvable by an automated system that can follow pattern-matching and small logic insertion instructions."
django__django-13297,35,medium,55,"The change touches a single Django core file and replaces the use of SimpleLazyObject with django.utils.functional.lazy so the lazily-evaluated object keeps the original value’s type. Only a few lines are modified, and no new algorithm is introduced, so the raw code change is small. However, knowing that SimpleLazyObject changes the object’s type and that lazy(…, type(value)) is the correct alternative requires moderate knowledge of Django’s lazy utilities and the framework’s deprecation mechanisms. An AI needs to (1) reproduce the bug, (2) understand why database lookups fail with SimpleLazyObject, and (3) identify the correct framework helper to preserve type while still deferring evaluation, which is less obvious than a simple typo fix. The problem statement is clear about the failure mode but does not explicitly mention django.utils.functional.lazy, so some reasoning and Django-specific insight are necessary. Consequently, while achievable, the task is not trivial, leading to medium complexity and a moderate (≈55%) likelihood that an automated system could infer the correct fix."
django__django-13315,40,medium,65,"The fix touches only one function in a single file and adds roughly ten lines, so the code-change volume is small. However, it requires an accurate understanding of how Django’s limit_choices_to, Q objects, query joins, and the ORM’s Exists/OuterRef constructs interact. The core challenge is recognizing that the duplicate rows stem from the JOIN introduced by a complex Q filter and that switching to an Exists subquery (or any deduplication strategy) eliminates the duplicates without altering the semantics of the filter. This demands moderate domain knowledge of the Django ORM but no large-scale architectural work or complex algorithms. 

From an automated-generation perspective, the bug is well-described (“duplicate options when limit_choices_to is a Q object involving a join”), and a straightforward remedy such as appending .distinct() or wrapping the filter in an Exists clause would satisfy likely tests. An AI system with understanding of Django patterns could plausibly arrive at such a solution, though selecting the specific Exists/OuterRef idiom is less obvious. Therefore, the task is moderately complex but still reasonably solvable with a 65 % likelihood."
django__django-13343,25,medium,70,"The change affects a single Django core file with only a handful of lines added/modified. The logic is straightforward: remember the original callable before invoking it and later use this reference during deconstruction. No algorithms or cross-module refactoring are involved, keeping the technical complexity low. However, a developer must understand Django’s field deconstruction process and why migrations should serialize the callable rather than its evaluated result, which places the task slightly above a trivial fix. An AI given the clear problem statement could plausibly infer the need to store the callable and reference it later, so the likelihood of automatic generation is fairly high, though not guaranteed without explicit tests to guide it."
django__django-13344,40,medium,45,"The fix touches four middleware modules and several subclasses, but the actual change is conceptually simple: ensure each subclass calls the MiddlewareMixin constructor (super().__init__(get_response)). This requires recognizing that omitting the parent constructor prevents the mixin from wrapping async views properly, causing the first middleware to see an unresolved coroutine. While only ~30 lines change, understanding the root cause demands knowledge of Django’s async middleware flow and how MiddlewareMixin adapts the callable. An AI must inspect the class hierarchy, notice the missing super call, and replicate the remaining attribute initialization correctly, which is harder than a pure string replacement yet not architecturally heavy. Therefore complexity is moderate. The solvability is also moderate: the bug is clearly described, but pinpointing every affected middleware class without running the full framework could be challenging, giving roughly a 45% chance an automated system fixes it from the description alone."
django__django-13346,45,hard,55,"The change touches only one file and adds roughly 25 lines, but it lives inside Django’s ORM compilation layer and must deal with differences between SQLite, MySQL (including MariaDB), and Oracle. Implementing a new Lookup class (KeyTransformIn) requires understanding of how JSONField key transforms are rendered to SQL, how RHS parameters are substituted, and the quirks of each backend’s JSON functions. This is non-trivial domain knowledge and goes beyond simple pattern matching, hence the “hard” classification and a mid-range complexity score.

From an AI perspective, the failing tests would signal that the __in lookup is not registered for KeyTransform. Detecting that a missing lookup registration is the root cause is feasible, but crafting the exact backend-specific SQL (JSON_EXTRACT, JSON_UNQUOTE, JSON_QUERY/JSON_VALUE) is harder and requires consulting existing patterns in the codebase. Because similar logic already exists for Exact/Numeric lookups, an AI with sufficient code-base context could copy and adapt that pattern, so the solvability is above 50% but still far from certain."
django__django-13363,20,easy,85,"The change affects a single file and only replaces two occurrences of a hard-coded timezone resolution with a call to an existing helper method (self.get_tzname()). No new logic, data structures, or cross-module interactions are introduced. The required insight is simply to realize that TruncBase already supplies get_tzname(), making the fix a straightforward substitution. Because the problem statement explicitly points out the incorrect line and references the correct helper function, an automated system or developer can map the specification to the patch with minimal codebase knowledge. Therefore, complexity is low and the solution is highly discoverable, yielding a high solvability score."
django__django-13401,35,medium,80,"Only a single file is touched and roughly 20 lines are altered, so the code-base impact is limited. However, the change affects fundamental behaviour of Django Field comparison, requiring understanding of how abstract models share Field instances, how creation_counter is used for ordering, and how equality/hash/ordering interact to avoid regressions. The algorithmic logic to preserve backward-compatible ordering while disambiguating by model is slightly subtle but not intricate. The problem statement explicitly outlines what to do: modify __eq__, __hash__, and __lt__, and even hints at the ordering strategy. Because the requirements are clear and the surface area small, an AI system has a strong chance of producing the correct patch, though it still needs ORM/domain awareness and careful handling of hasattr(model). Hence complexity is moderate, and solvability is high though not trivial."
django__django-13406,35,medium,65,"The change touches only one file and adds two straightforward lines, so the code delta itself is small. However, understanding why those lines are necessary requires moderate familiarity with Django’s internal queryset mechanics—specifically how _iterable_class is decided and how values()/values_list() switch it to ValuesIterable. The bug manifests only after pickling/unpickling and re-assigning the query, which resets _iterable_class to the default ModelIterable, so the fix re-applies the correct iterable when values_select is present.

An engineer (or an AI) must trace the flow of pickling, recognize that the iterable class isn’t restored, and know that ValuesIterable is the correct choice. This is domain-specific knowledge but not algorithmically hard. Therefore, complexity sits in the lower-middle range.

Because the problem statement is clear, reproducible, and the fix is localized, an automated system stands a fair chance of synthesizing the patch once it inspects the relevant code path, yet it still requires understanding of Django internals, so solvability is moderate-to-high but not trivial."
django__django-13410,15,easy,92,"The patch affects a single file and only a handful of lines. It replaces a naïve equality check on the return value of fcntl.flock with a try/except pattern that correctly interprets success (no exception) versus failure (BlockingIOError). No new algorithms or architectural changes are introduced. The domain knowledge required—understanding how fcntl.flock behaves—is minor and explicitly stated in the problem description. Because the issue and its correct solution are clearly spelled out, an automated system or developer could reliably generate the fix. The absence of accompanying tests slightly reduces certainty but does not materially complicate the task, as the functional change is straightforward and isolated."
django__django-13417,30,medium,70,"The fix is limited to a single method in one file, adding a straightforward guard clause (not self.query.group_by) to an existing conditional. While the code change itself is small, it requires knowledge of how Django builds SQL queries, the interaction between Meta.ordering, default_ordering, GROUP BY, and the QuerySet.ordered property. An AI system must locate the relevant property, understand the semantics described in the problem statement, and recognize that GROUP BY removes implicit ordering. This demands moderate framework familiarity but no complex algorithms. Therefore the change is of moderate complexity (≈30%) and falls into the “medium” category. Given the clear problem description, the solution space is narrow (essentially adding a single condition), so an AI has a relatively high chance (~70%) of producing the correct patch."
django__django-13449,40,medium,45,"The change touches only one file and adds ~20 lines, so the surface area is small. However, it requires understanding Django’s SQL compilation process, the purpose of SQLiteNumericMixin, the behavior of window functions, and how DecimalField casting is handled for SQLite. The key challenge is realizing that the automatic numeric cast applied to DecimalField must wrap the entire window expression and that this can be achieved by temporarily switching the internal expression’s output field to FloatField and re-using the existing mixin logic. While the bug description clearly pinpoints the faulty SQL and hints at the needed cast placement, crafting the correct fix still needs non-trivial framework insight, so the task is moderate in complexity. An AI could plausibly infer the fix from the error message and existing mixin patterns, but without intimate knowledge of Django’s compiler internals it would be difficult, leading to a moderate (≈45%) likelihood of automated solution."
django__django-13512,20,easy,85,"The fix touches only two files with an import addition and replacing two calls to json.dumps by adding the flag ensure_ascii=False. No algorithms are modified; it's a straightforward parameter change that prevents Unicode escaping. Understanding the issue requires minimal Django knowledge and basic familiarity with json.dumps behavior. Because the problem statement clearly describes the undesired ASCII escaping and even hints at the solution, an AI system could infer the necessary change with high confidence. Overall, the change is small and isolated, leading to low complexity and high solvability."
django__django-13513,40,medium,80,"Only one file is touched and fewer than 50 lines are modified, keeping structural impact moderate. The core change is adding support for the __suppress_context__ flag when walking an exception chain, something that requires knowledge of Python’s PEP 415 but no complex algorithms. The refactor (new helper method and generator) is straightforward and does not alter overall flow dramatically. An AI supplied with the problem statement is strongly guided toward the right fix—the statement even shows the corrected logic explicitly—so the task is highly solvable. The main challenge is navigating existing Django debug-view internals and ensuring the new helper is called everywhere, which pushes the task above “easy” but still within “medium” difficulty."
django__django-13516,12,easy,88,"The fix touches a single file and adds only four straightforward lines: a flush() proxy method that delegates to the wrapped stream if it supports flush. No algorithms or multi-module interactions are involved; one merely mirrors existing patterns already used for isatty(). The problem description clearly states that flush() is missing and what the expected behavior is, so an implementer (human or AI) can directly infer the need for this passthrough method. Required domain knowledge is minimal Python I/O understanding and a cursory familiarity with Django’s management command wrapper. Because the scope is tiny, the change is obvious, and there are no complicated edge cases, an AI system has a high likelihood of producing the correct patch given the statement, yielding a high but not perfect solvability score (tests or style nuances might still trip it)."
django__django-13551,30,medium,85,"The fix touches a single file with only a few lines added, keeping overall code changes small. However, it requires understanding how Django’s PasswordResetTokenGenerator works, why including mutable user attributes (password, last_login) in the hash invalidates old tokens, and why the email field must also be added to cover the described edge-case. That domain-specific security knowledge places the task above the most trivial category, but the implementation itself is a straightforward string concatenation once the requirement is known. The problem statement is clear, the scope is narrow, and no additional tests or multi-module interactions are needed, so an AI with knowledge of Django could reliably generate the correct patch. Hence, moderate complexity, medium difficulty, and a high likelihood of successful automated generation."
django__django-13568,35,medium,55,"The change touches a single file with only a few lines added, so the code-change size is small. However, it requires understanding how Django’s model meta API exposes uniqueness (the .unique field attribute vs total_unique_constraints) and how the auth system check is triggered. An implementer must know that UniqueConstraint entries appear in Model._meta.total_unique_constraints and that a single-field UniqueConstraint should satisfy auth.E003. This is moderately complex framework knowledge but the algorithm itself is simple (a boolean check with any()). Given a clear problem statement that explicitly describes the needed behavior, an automated agent with Django familiarity could plausibly generate this fix, though it needs the specific Meta API detail. Lack of tests in the prompt lowers certainty but the solution space is narrow and well defined. Hence medium complexity, moderate solvability."
django__django-13569,40,medium,70,"Although the final patch is only three new lines in a single file, producing that fix requires understanding Django’s query compilation pipeline, specifically how expressions contribute to GROUP BY generation. You must recognize that ORDER BY(Random) introduces an Expression object whose default implementation returns itself for grouping, and that overriding get_group_by_cols() to return an empty list prevents RANDOM() from leaking into GROUP BY. This demands moderate knowledge of Django ORM internals but involves no intricate algorithm or multi-module refactor. Therefore the change complexity is moderate (≈40%). Given the clear problem description, clear reproduction steps, and the localized nature of the fix, an automated system with insight into Django’s expression methods could plausibly derive the solution, so solvability is fairly high (≈70%), but not trivial because the correct override method and its semantics must be known."
django__django-13590,35,medium,75,"Only a single function in one file is touched and the logic adjustment is limited to recognizing when the original iterable is a namedtuple and unpacking the generator into positional arguments. The fix involves about five new lines, no new abstractions, and no side-effects outside this small code path. Nevertheless, the developer must understand Python’s namedtuple construction semantics and how Django’s query value resolution reconstructs iterables, which lifts it slightly above a trivial change. The problem statement pinpoints the failing call site and the exact cause (iterator passed to namedtuple constructor), making the corrective action largely mechanical once that fact is known. Given this clarity and the contained scope, an automated system with knowledge of Python data-model details could likely synthesize the patch, yielding a fairly high solvability score, while the need for framework insight and Python nuance keeps the complexity and category from being ‘easy’. "
django__django-13658,15,easy,90,"The change touches a single file and only modifies the instantiation of CommandParser by passing an existing variable (self.prog_name) as the prog argument. There is no algorithmic work, no interaction with other components, and no side-effects beyond correcting the help/usage string. Understanding the fix only requires recognizing that %(prog)s expands to the provided prog value and that ManagementUtility already calculated the correct program name. This is a straightforward parameter wiring issue, typical of a simple bug fix, so complexity is low (≈15%). Given the explicit problem statement that literally shows the desired code snippet, an automated system could reliably apply the patch; thus solvability is very high (≈90%). Minimal domain knowledge of argparse/Django is needed, so the task falls in the ""easy"" category."
django__django-13670,10,easy,90,"The bug is isolated to a single method in one file. The issue is well-described: `str(self.data.year)[2:]` fails for years with fewer than four digits. The required fix is to always return the last two digits of the year padded with leading zeros. Implementing this only needs a basic string-formatting change (`'%02d' % (year % 100)`). There are no side effects, algorithmic challenges, or cross-module dependencies. An AI system can infer the solution directly from the problem statement without deep knowledge of Django internals, so the task is highly solvable. The minimal code modification and straightforward logic place the complexity in the lowest quartile."
django__django-13741,20,easy,70,"The change touches a single file with about a dozen lines modified. It leverages an existing Django forms feature (the `disabled` parameter) and removes now-redundant code (`bound_data`, `has_changed`, and `clean_password`). No new algorithms or cross-module interactions are introduced; it is essentially a configuration tweak plus cleanup. An engineer (or AI) familiar with Django form mechanics can infer that setting `disabled=True` automatically prevents changes and makes the custom cleaning logic unnecessary. Because the requirement is explicit and narrowly scoped, and because the patch is straightforward, the problem falls in the low-complexity, high-solvability range. The main domain knowledge needed is understanding how disabled fields behave in Django, which is common framework knowledge, not deep architectural insight."
django__django-13786,30,medium,65,"The change affects a single method in one file and adds only a handful of lines, so the raw code complexity is low. However, to recognize the bug and craft the fix an engineer (or AI) must understand how Django’s migration-squashing logic is supposed to mirror the semantics of AlterModelOptions, including the special ALTER_OPTION_KEYS rule that treats omitted keys as deletions. That requires moderate framework-specific knowledge, pushing the task beyond a trivial pattern substitution but not into algorithmic complexity. The fix itself is straightforward dictionary manipulation once the rule is understood. Given the clear problem description that pinpoints the offending line and describes the expected behavior, an automated system has a fair chance of producing the correct solution, though it must know to reference ALTER_OPTION_KEYS and replicate the pop logic. Therefore the task is categorized as medium difficulty with roughly two-thirds likelihood of successful automated generation."
django__django-13794,15,easy,85,"The fix consists of adding two straightforward dunder methods (__add__ and __radd__) to Django’s Promise class so that lazy translation objects can be concatenated with regular strings. Only one file is touched and fewer than 10 lines are added; no algorithmic changes or multi-module interactions are involved. The required Python knowledge (operator overloading and lazy object casting) is elementary for a Django contributor. The problem statement clearly explains the symptom and its cause, making it easy to infer the solution. Consequently, an AI system with basic familiarity with Python data-model methods could reliably propose this patch."
django__django-13807,30,medium,80,"The patch touches a single file and only a handful of lines. No new algorithms or data structures are introduced; the fix simply ensures that dynamically-inserted table and column names are quoted through the already-available backend helper (self.ops.quote_name). Technically the change is straightforward, but it does require awareness of SQL-identifier quoting rules and familiarity with Django’s database-backend utilities, so it is slightly beyond a trivial typo fix. 

The main challenge for an automated system is to notice that every occurrence of an unquoted identifier inside the affected method must be wrapped with quote_name to avoid syntax errors with reserved words. Because the problem statement explicitly highlights the failing SQL, pinpoints the offending lines, and even notes ""due to missing back ticks around %s"", an AI has clear guidance on what needs to be patched. No broader architectural concerns or cross-file impacts are involved, and existing helper functions do the heavy lifting. This clarity makes the task highly solvable, though not completely trivial, leading to an estimated 80% success probability."
django__django-13809,15,easy,90,"The patch touches a single file and adds only a handful of straightforward lines: (1) registering a new command-line flag and (2) guarding an existing function call with an if-statement. No new algorithms, data structures, or interactions with other Django subsystems are introduced. Understanding Django’s management-command argument handling is helpful but rudimentary. Because the requirement is precisely stated (“Add --skip-checks to runserver”) and the change is largely boilerplate, an AI system can map the spec to the necessary argparse addition and the conditional almost mechanically. There is minimal risk of side effects or edge-case handling, and alternative correct solutions are limited, so generating the right patch is highly likely."
django__django-13810,40,medium,80,"The change touches a single file and only adds a handful of lines, so surface-level complexity is low. However, the defect involves subtle control-flow and state interaction: `handler` was being mutated before it was certain the middleware would be kept, which poisoned the remaining middleware chain in an ASGI context. Fixing this requires understanding Django’s middleware loading loop, the `MiddlewareNotUsed` signalling mechanism, and how synchronous/async adaptation works. That domain knowledge bumps the complexity above a trivial typo fix but still keeps it below large-scale architectural work. 

The patch itself is straightforward once the issue is understood—introduce an `adapted_handler` temporary and only commit it to `handler` when the middleware instance is successfully created. Because the problem statement explicitly describes the bug, pinpoints the relevant code section, and explains the undesired side effect, an automated system or developer has clear guidance. Therefore, the likelihood of an AI producing the correct fix is relatively high, though it still needs to reason about exception flow and variable scope."
django__django-13820,30,medium,70,"Only one file is modified with a net change of a few lines. The fix consists of refining a conditional to distinguish between regular packages without __file__ (possible in frozen environments) and true PEP-420 namespace packages. Algorithmically this is trivial—just add an isinstance() check—so the code complexity is low. However, forming the correct predicate requires understanding Python’s import mechanics, PEP-420, and how Django’s migration loader interprets packages, which elevates the task above a pure pattern-matching exercise. An AI equipped with the problem statement (which explicitly describes the required change) can generate the patch with high likelihood, because the scope is well-defined and the logic is straightforward. Lack of accompanying tests reduces guidance slightly, but overall the solution space is small and clearly directed by the description."
django__django-13821,10,easy,92,"The change consists of updating a version threshold constant in a single function to raise an error for unsupported SQLite versions. No algorithms or multi-file interactions are involved, and the intent is explicitly stated in the problem description (""Drop support for SQLite < 3.9.0""). Implementing the fix only requires editing two numeric literals and adjusting the accompanying error message. This is simple pattern substitution with minimal domain knowledge; an automated system can reliably detect and apply the change. Therefore, complexity is very low and solvability is very high."
django__django-13837,30,medium,70,"The patch modifies a single function in one file with only a handful of lines changed, so the code delta is small. However, it requires awareness of how Python sets __main__.__spec__ when the interpreter is invoked with the –m switch and how that information can be used to reconstruct the original command-line. That import-system knowledge is somewhat specialized but still well documented and widely known among experienced Python developers. No significant algorithmic work or cross-module refactoring is involved, but the developer must avoid regressions for other execution modes and deal with edge cases such as directory/zip execution (empty parent). Thus the task is more than a trivial edit but far from architecturally complex.

For an AI, the specification gives a very clear description of the desired behavior, explains exactly why the old heuristic is wrong, and points to the Python documentation that should be used. With that guidance, producing the correct conditional based on __main__.__spec__.parent is straightforward, so solvability is reasonably high though not guaranteed (the AI must recall/consult the import spec rules and generate the right truthiness check)."
django__django-13925,30,medium,70,"The fix alters a single function in one file with only a few lines of additional guard logic. No new algorithms or cross-module refactors are introduced, keeping raw code complexity low. However, correctly identifying the condition to skip the warning demands a solid understanding of Django’s model-inheritance internals, specifically that an inherited primary key is represented by an auto-created OneToOneField whose remote_field.parent_link flag is True. Recognizing this subtle distinction between an ordinary auto-created PK and an inherited one is non-trivial, but the required change is still a straightforward boolean clause once the insight is gained. Given the detailed bug report (which explicitly states that the PK is inherited) and Django’s transparent codebase, an AI with code-search abilities could locate the check emitting models.W042 and add the necessary exclusion, so the task is reasonably solvable. Limited scope, clear failure mode, and easy validation drive solvability up; the need for framework-specific insight prevents it from being categorized as “easy.”"
django__django-13933,15,easy,90,"Only a single method in one file is modified and the change is to supply the invalid value through the params argument when raising ValidationError. No new algorithm, no cross-module impact, and Django’s ValidationError API is well-documented, so understanding the fix is straightforward. An AI only needs to notice that other fields in the codebase already pass params={'value': ...} and replicate that pattern here. Because the requirement is explicit in the problem statement and the code context is small, the task is highly solvable with simple pattern matching. Minimal domain knowledge of Django forms is helpful but not deep; complexity remains low."
django__django-13964,30,medium,70,"The patch touches only one file and changes a single conditional, so the raw code modification is small. However, understanding why the condition must use `field.empty_values` instead of simply checking for `None` requires knowledge of Django’s ORM internals—specifically how unsaved values for non-auto primary keys are represented ("""" instead of None) and how `_prepare_related_fields_for_save()` determines when to copy the related object’s primary key onto the parent. That pushes the change above a trivial typo fix but keeps it well below a full architectural alteration, resulting in a moderate 30 % complexity and a “medium” category.

For an AI, the bug description is clear, includes minimal reproducible code, and pinpoints the faulty behaviour: the FK column remains an empty string. Once the AI inspects the surrounding code it can deduce that the comparison to `None` is too narrow and that Django already defines `field.empty_values` for this purpose. Because the fix is localized and conceptually straightforward once the ORM convention is understood, I rate solvability at 70 %. Challenges include locating the exact saving path and knowing about `empty_values`, which demands some framework familiarity but not deep algorithmic work."
django__django-14007,40,medium,60,"The patch touches a single Django core file and adds roughly 15 lines, so the raw code delta is small. However, understanding where to place the fix requires familiarity with Django’s SQLCompiler, how returning_fields are handled on INSERT, and how get_converters/apply_converters are normally invoked for SELECT queries. The algorithmic work is straightforward (gather columns, fetch converters, apply them), but identifying the omission and integrating the existing conversion utilities in the correct execution branch takes moderate framework knowledge and careful reasoning about multiple backend capabilities (bulk-insert, returning columns, last_insert_id). Because the required logic already exists elsewhere in the codebase, an AI could locate and reuse it, giving a better than even chance of success if regression tests highlight the type mismatch. Still, the need to trace execution flow through several abstraction layers and ensure the fix works for all conditional branches makes it non-trivial. Hence, the change is of medium complexity and moderately solvable by automated systems."
django__django-14011,45,medium,40,"The fix touches two files with roughly two dozen new lines, introducing connection-handling logic inside Django’s ThreadedWSGIServer. While the code delta is small, the developer must understand Django’s request lifecycle, the interaction between ThreadingMixIn and database connection management, and the shutdown sequence of LiveServerTestCase. The solution requires knowing that each worker thread needs its own connection copy and that close_request() is the correct hook to close them. This is beyond a simple pattern replacement but doesn’t involve complex algorithms or large refactoring, yielding a moderate (45%) complexity. 

For an AI, identifying the intermittent SQLite ‘database is being accessed’ error as a connection-closing problem, selecting the appropriate override points, and ensuring compatibility with Django’s internal connection handler is challenging because the symptoms manifest only under race conditions. Without explicit tests describing the failure, several plausible fixes exist, so generating the exact patch is difficult. Therefore, the solvability is estimated at 40%, reflecting a non-trivial but not impossible task with sufficient framework knowledge."
django__django-14017,20,medium,60,"Only one file and a single conditional check are modified, so code-level complexity is low. However, choosing the correct condition requires knowing that Django conditional expressions (Exists, Subquery, etc.) expose a `conditional` attribute and that Q._combine should treat them like Q objects. An AI must link the TypeError to the isinstance guard and realize the proper generic criterion, not simply add a __rand__ or special-case Exists. That demands moderate understanding of Django ORM internals but the change itself is mechanically simple. Consequently, the task sits at the boundary of easy and medium: trivial code but non-obvious insight. Given a clear bug report and typical training on Django source, an AI has a fair (≈60%) chance to generate the correct fix."
django__django-14034,40,medium,55,"Only one file is touched and ~10 new lines are introduced. The fix is a conditional that checks whether the field is a MultiValueField with require_all_fields=False and, if so, assigns the HTML5 ""required"" attribute to each individual sub-widget instead of the parent widget. Algorithmically this is straightforward: no new data structures, loops, or non-trivial logic are added. 

However, understanding why this change is necessary demands moderate familiarity with Django’s form system, specifically how BoundField.build_widget_attrs decides to add the HTML5 required attribute, the semantics of MultiValueField/require_all_fields, and the interaction between parent and sub-widgets. That domain knowledge moves the task beyond a simple typo fix.

For an automated agent, the solution space is fairly narrow (propagating the attribute to subwidgets) but still requires recognizing that the failure comes from BoundField rather than validation logic itself and that MultiWidget must be imported. The absence of a dedicated failing test makes it harder, though the problem statement explains the symptom clearly. Overall that gives a moderate likelihood that an advanced AI, given sufficient Django context, can synthesize the patch."
django__django-14053,40,medium,55,"The change is limited to a single method in one file (~20 added/modified lines) and doesn’t introduce new algorithms or deep architectural shifts, keeping overall complexity moderate. However, correctly fixing the bug requires understanding how Django’s staticfiles pipeline works across multiple passes (distinguishing adjustable vs. non-adjustable files, handling exceptions, and ensuring final hashed names are yielded exactly once). An AI must reason about side-effects such as collectstatic’s counters and downstream consumers, not just remove duplicates naïvely. This domain-specific nuance elevates difficulty above a trivial patch but remains within reach because the problem statement clearly explains the undesired duplicate yields and why only final results should be exposed. Given the clarity of the description and the isolated nature of the fix, an automated system with contextual reasoning has a fair (but not certain) chance of producing the correct solution."
django__django-14089,10,easy,95,"The patch adds a single, straightforward method (__reversed__) to an existing class, touching one file and only three lines of code. No algorithmic changes or cross-module interactions are involved. The requirement is explicitly stated in the problem description and maps directly to a standard Python protocol (__reversed__). An AI system only needs to recognize that delegating to reversed(self.dict) satisfies the contract, making the task highly solvable. Minimal Django or domain knowledge is required beyond understanding that OrderedSet maintains insertion order via an internal dict."
django__django-14122,30,medium,60,"The fix touches only a single function in one file and adds a simple guard (`if not self._meta_ordering:`) to avoid adding implicit Meta.ordering fields to the GROUP BY clause. Code-wise, the change is small and algorithmically trivial, placing it in the lower third of complexity. However, implementing it correctly requires understanding how Django’s query compiler builds GROUP BY and the distinction between explicit `order_by()` calls and implicit `Meta.ordering`. That domain knowledge pushes the task above the purely “easy” tier. 

For an automated system, the problem statement clearly describes the undesired behavior (“Meta.ordering fields must not be included in GROUP BY”) and references previous commits, giving enough clues to locate the relevant code. The solution space is narrow: identify where the GROUP BY list is populated from `order_by` expressions and skip that step when `Meta.ordering` is in effect. Therefore, while some framework insight is needed, the small diff and explicit description make the task moderately solvable, leading to an estimated 60 % likelihood that an AI could generate the correct patch."
django__django-14140,20,easy,90,"The change touches a single file and only removes a few lines that implemented a special-case branch. No new algorithms or structural modifications are introduced; the fix is simply to always treat the children of a Q object as positional args and avoid indexing into a possibly non-subscriptable child. While some knowledge of Django’s Q objects is helpful, the bug and its resolution are clearly described in the problem statement, allowing an automated system to infer the necessary edit with pattern matching and minimal semantic analysis. This yields low complexity and a high likelihood of automated solvability."
django__django-14155,15,easy,90,"Only one small method is modified (≈7 added lines). The fix is straightforward: detect if the view is a functools.partial and alter the string that __repr__ returns. No algorithmic changes, no cross-module impact, and minimal Django-specific knowledge are required—just basic Python introspection with isinstance and repr. An AI seeing the problem statement would likely infer the need to unwrap or display the partial, making the task highly solvable. The absence of tests slightly lowers certainty but the scope is so narrow that generating the correct patch is still very likely."
django__django-14170,40,medium,60,"The bug fix touches two core files in Django’s ORM, adding ISO-8601 awareness to year-range calculations when the __iso_year lookup is used. While the code delta is modest, generating the correct patch requires (1) knowing that ISO week-years don’t align with calendar years, (2) realizing that the BETWEEN optimization must therefore compute different bounds, and (3) wiring this new path into the generic YearLookup logic without breaking regular year lookups. No intricate algorithms are involved, but the solution demands familiarity with Django’s lookup/annotation internals and with date arithmetic (fromisocalendar, boundary microseconds). An AI with context and regression tests could reasonably infer and implement these changes, yet it still involves nuanced framework knowledge and careful edge-case handling, so the overall complexity rates around 40% and the problem sits in the ""medium"" category. Because the spec clearly pinpoints the failure and there is likely targeted test coverage, an AI has a better-than-even chance (~60%) of producing the right fix, but it is far from trivial."
django__django-14238,20,easy,90,"The bug is isolated to a single metaclass method where the code mistakenly checks membership (`subclass in self._subclasses`) instead of using `issubclass()`. Only one line in one file needs to be changed, with no algorithmic complexity or cross-module interactions. While some understanding of Python's `__subclasscheck__` and Django's `AutoField` hierarchy is required, the stack trace and the problem description point directly to the failing check, making the root cause straightforward to identify. An automated system that parses the error, inspects the conditional, and knows to replace a direct membership test with `issubclass()` stands a high chance of succeeding, hence the high solvability percentage. The task is simple pattern-level logic correction rather than deep architectural work, so it is categorized as easy with low overall complexity."
django__django-14311,30,medium,55,"The change touches a single function in one file (7 net new lines) and adjusts the logic that builds the argument list when Django’s autoreloader respawns the process that was started with ""python -m"". Understanding the fix requires knowledge of how Python sets __spec__ for modules executed with -m, the difference between running a package’s __main__.py and a regular module, and how Django’s autoreloader reconstructs the original command line. While the code modification itself is short and contains no advanced algorithms, choosing the correct conditional (distinguishing '__main__' and '*. __main__' cases) demands specific domain insight and awareness of the earlier, incorrect behaviour. An AI given only the bug description and failing tests would need to reason about these Python import subtleties but the scope is tightly focused, making success plausible though not trivial. Hence the task is of moderate complexity and roughly a coin-flip in solvability for an automated system."
django__django-14315,18,easy,85,"The patch touches only two files and changes a total of four lines. No new algorithms or data structures are introduced; the fix is a straightforward conditional adjustment and a defensive return-value change. The core insight is that an empty dict is falsy, so the previous `if env:` guard prevented merging with `os.environ`, causing an empty environment to be passed to `subprocess.run`. Correcting this requires minimal Django-specific knowledge—just awareness of how environment propagation works in Python subprocess calls. Given the clear bug description, an automated system could pattern-match the issue (empty dict vs. None) and generate the fix with high likelihood. Therefore, while the change is important, its technical complexity is low, and the task is highly solvable."
django__django-14349,25,medium,78,"The fix touches a single file and adds only a few lines: define a constant set of unsafe characters and reject any URL containing them before further processing. Algorithmically it’s trivial (membership test and early return). However, understanding why the failure occurs requires recognizing the behavioral change introduced by Python’s bpo-43882 and its impact on Django’s URLValidator. An AI must connect the test failures (missing ValidationError for URLs containing CR/LF/tab) with that upstream change and realize that explicit character filtering is needed. This demands moderate domain insight but no complex coding, so complexity is low-moderate. Because the problem statement clearly explains the cause and even suggests the exact remedy, an automated system has a good chance of producing the correct fix, yielding a high solvability estimate."
django__django-14351,60,hard,35,"Although the actual diff is only ~10 lines in a single file, the change touches Django ORM internals (lookups, sub-query column selection, GROUP BY generation). Fixing the bug requires understanding how Q objects, aliasing, select clauses, and group-by columns interact when an __in lookup is combined with OR conditions. The developer must know that a Subquery incorrectly keeps all default columns and must be trimmed to the PK to satisfy SQL’s one-column requirement, and must be aware of the has_select_fields flag and Query.clear_select_clause()/add_fields(). This depth of framework knowledge and the subtle nature of the failure (only triggered with specific combinations of annotations, IN subqueries, and aggregation) makes the task complex. For an AI working only from the problem statement (with no failing tests) it would be hard to infer exactly where to intervene and how to do so safely, thus a modest solvability score."
django__django-14373,5,easy,95,"The change is isolated to one method in a single file and involves replacing a raw integer return value with a zero-padded string using a simple format specifier ('%04d'). No algorithmic work, cross-module impact, or deep framework knowledge is required—only basic Python string formatting. The problem statement is explicit about the expected behavior (always four digits, leading zeros) so the correct fix is obvious. Therefore the task is low complexity and highly solvable by an AI."
django__django-14376,20,easy,90,"The required change is a straightforward renaming of two keyword arguments ('db' ➔ 'database', 'passwd' ➔ 'password') in the MySQL backend and a follow-up adjustment in the command-line client helper. Only two source files are touched and fewer than 15 lines are modified; no new algorithms, data structures, or deep architectural knowledge are involved. The problem statement clearly describes both the motivation (deprecation in mysqlclient) and the exact replacements needed, so an automated system can rely on simple pattern matching or rule-based substitution to generate the correct patch. Because the scope is tightly bounded and the behaviour is easy to verify (arguments are merely forwarded), the fix is highly solvable by an AI. The main challenge is minor domain knowledge: knowing that connection parameters must match what the driver expects, but this is explicitly stated in the description. Consequently, the complexity is low and the likelihood of automated repair success is high."
django__django-14404,30,medium,60,"The change touches a single method in one file and consists of replacing two uses of request.path_info with request.path (plus an in-line simplification). Algorithmically it’s trivial, but it does require awareness of Django’s FORCE_SCRIPT_NAME / APPEND_SLASH interaction and the semantic difference between path and path_info. An engineer (or an AI) must know that path retains the script-prefix while path_info does not, and that the redirect has to keep the prefix to work behind SCRIPT_NAME. That domain-specific knowledge bumps the difficulty out of the ‘easy’ tier, but the overall change set is still very small and local. Because the problem statement explicitly points out the incorrect field and what the correct value should be, an AI has a reasonable chance of producing the right patch even in the absence of additional tests."
django__django-14434,30,medium,65,"The patch touches a single method in one file and changes only a handful of lines. No new algorithms or data structures are introduced; the fix mainly replaces a Table wrapper object with a plain string when passing arguments and then recreates the Table at the single point where the SQL Statement actually needs it. The main difficulty is recognising that the wrong type is being propagated and that this silently breaks downstream logic (references_column). That requires moderate familiarity with Django’s schema-generation helpers but not an in-depth architectural overhaul.

An automated system could plausibly detect the type mismatch through failing tests or runtime errors and infer that the simplest correction is to pass the raw table name. The change pattern (unwrap, then wrap back where needed) is straightforward once the root cause is identified. Because the problem statement explicitly points out the issue (""an instance of Table is passed … when a string is expected""), the solution space is narrow, which raises the solvability score. However, the AI must still navigate Django internals, so it’s not trivial.

Overall, the change is moderately complex (30%) and requires code-base understanding (medium), but the explicit problem description and localized fix give a better-than-average chance (65%) that an AI could generate the correct patch."
django__django-14493,10,easy,90,"The bug is a classic ‘variable referenced before assignment’ that occurs when a loop with zero iterations skips the variable assignment. The fix is to initialize the variable before the loop, which involves adding a single line in one file. No algorithms are modified and no other subsystems are touched, so the technical and architectural complexity is very low. An AI reading the traceback and code snippet in the problem statement can directly infer the missing initialization, making the task highly solvable. Only minimal familiarity with Python scoping rules and Django’s static-files workflow is required."
django__django-14500,15,easy,85,"The fix touches a single method in one file and simply removes an unnecessary conditional so that the squashed migration itself is always recorded as unapplied. No new logic or algorithms are introduced. Understanding the concept of ‘squashed migrations’ in Django is helpful but not deeply technical; the change is essentially a one-line move of record_unapplied outside an else block. Because the required behavior is clearly described in the problem statement and the modification is mechanically straightforward, an automated system has a high likelihood of producing the correct patch. Hence, low complexity, easy category, and high solvability."
django__django-14534,10,easy,85,"The change touches a single property method in one file, replacing a hard-coded ID construction with returning the already-computed id stored in the widget’s attrs dictionary. There is no algorithmic work, no cross-module impact, and only a single line is modified. An AI only needs to understand that the correct ID is provided via self.data['attrs']['id'] and should be used directly. The problem statement is explicit about both the cause and the desired behavior, making the required patch almost mechanical. Therefore, the task is low complexity (≈10%), falls in the “easy” category, and is highly solvable by automated systems (≈85%)."
django__django-14539,20,medium,60,"The fix touches a single helper function in one file (3 new logical lines), altering how trailing punctuation is split off from an HTML-escaped URL. The underlying logic is simple string slicing; no new APIs or algorithms are introduced, so overall structural complexity is low (≈20%).

However, arriving at the correct slice computations requires understanding that the original code mixed lengths of the escaped and unescaped strings, causing off-by-N errors for entities like ""&lt"". This subtlety pushes the task beyond a trivial pattern replacement into a bug-logic analysis zone, thus the ""medium"" categorization.

From an automated-repair standpoint, the failure can be isolated with a concise failing example, and the faulty slice boundaries are localised, so generating a patch is feasible. Nonetheless, there is still reasoning needed—counting the difference in lengths and adjusting both `trail` and `middle` consistently—so an AI’s success is not guaranteed but plausible, giving a solvability estimate of about 60%."
django__django-14559,25,easy,90,"The patch touches a single method in one file (QuerySet.bulk_update) with minimal lines added; no new algorithms or deep framework restructuring is involved. The change is conceptually simple: accumulate and return the count of rows that the existing update() calls already produce, plus handle the empty-input case by returning 0. This requires only basic familiarity with Django’s QuerySet API and Python control flow. The problem statement is explicit about the desired behavior and even links directly to the relevant code, so an AI can locate and modify the method with high confidence. Therefore, complexity is low (~25%), the task falls in the 'easy' category, and the likelihood of an AI generating the correct fix is high (~90%)."
django__django-14580,15,easy,80,"The change touches a single file and consists of adding one string to a tuple so that the migration writer includes the missing import statement. No algorithms are modified, and no additional interactions with other subsystems are introduced, keeping the overall complexity low (≈15%). Understanding the problem only requires noticing that the generated migration references models.Model without importing models, so the fix is straightforward string manipulation—pattern matching level—thus the task is classified as ""easy."" Given the clear, concrete problem statement and the trivial nature of the required code addition, an AI system has a high likelihood of producing the correct patch (≈80% solvability). The main challenge is recognizing where Django registers imports for special-cased objects, but once located, the solution is obvious; minimal deep framework knowledge is required."
django__django-14608,15,easy,85,"The patch alters a single file with only a couple of lines changed, adding an optional keyword argument to the construction of an ErrorList so it carries an additional CSS class. No algorithms or cross-module interactions are involved; it is essentially a parameter tweak. Understanding that non-form errors in FormSets need the ""nonform"" CSS class mirrors existing behavior of non-field errors in Forms, a clear and well-documented pattern in Django. Therefore the technical complexity is minimal (about 15%). An AI system familiar with Django’s conventions could reliably infer the necessary change from the problem statement, especially because the required behavior already exists elsewhere (pattern matching). The fix is localized, deterministic, and doesn’t require deep architectural insight, giving a high likelihood (~85%) that an automated approach could generate it."
django__django-14631,55,hard,40,"The patch touches core logic in Django’s form processing pipeline, modifying both BoundField and BaseForm behaviour. Although the diff is fewer than 100 lines, it affects multiple interacting concepts: widget value extraction, initial-value handling, disabled fields, file field cleaning, and change-detection semantics. Implementing _has_changed() demands knowledge of how hidden initial fields work and how ValidationError must be handled. Rewriting _clean_fields() and changed_data() to iterate through newly introduced _bound_items(), while preserving all edge cases (files, disabled fields, hidden initial, data preparation), requires a solid grasp of Django internals and careful reasoning to avoid regressions. For an AI system given only the high-level ticket description, reproducing these nuanced interactions and integration details is challenging; there are many opportunities for subtle mistakes that wouldn’t surface without comprehensive tests. Consequently, the task rates as hard with moderate complexity, and the likelihood an AI could produce the exact fix without broader context or extensive tests is relatively low but not impossible."
django__django-14672,20,easy,85,"Only one file and a single line are modified. The fix is to wrap a potentially list-typed attribute in an existing helper (make_hashable) so it becomes tuple-like and hashable. There is no algorithmic work, no cross-module impact, and no new functionality—just a defensive conversion to ensure hashing works. The stack-trace in the problem statement pinpoints the exact spot (`self.through_fields`) causing `TypeError: unhashable type: 'list'`, making the required change easy to infer. While some Django internals knowledge helps, recognising that lists are unhashable and seeing an existing helper already used for other fields is enough. Therefore the change is low-complexity and highly solvable by an AI with modest framework awareness."
django__django-14725,35,medium,55,"The patch touches a single core Django file and adds roughly a dozen lines: an `edit_only` flag is threaded through the two factory helpers and respected in the FormSet `save()` method by skipping `save_new_objects()`. There are no new algorithms or deep refactoring, but the change must be inserted in the correct places of Django’s fairly intricate formset machinery, requiring moderate framework knowledge. An AI seeing failing tests that expect no new objects to be saved could likely infer that bypassing `save_new_objects()` is needed, and adding a parameter to the factories is a straightforward way to expose this behavior. Multiple correct implementations are possible (e.g., validation-time blocking instead of save-time), so some reasoning is required, but the scope is well defined. Hence the task is of medium difficulty, with moderate complexity and a better-than-even chance of automated solvability."
django__django-14752,30,medium,85,"The patch touches a single file and introduces a small refactor: extracting the serialization of each autocomplete result into its own overridable method. No new algorithms are involved; the logic is straightforward CRUD-style view code typical in Django. The main challenge is knowing where to hook the new method and preserving existing behaviour, which requires moderate familiarity with Django’s class-based views but no deep architectural changes. Because the problem statement explicitly describes both the desired refactor and the exact code to move, an AI system has clear guidance and a narrow scope for implementation, making success likely. However, it is more than a trivial typo fix, so it falls in the medium category rather than easy. The absence of accompanying tests slightly reduces confidence but overall the task remains highly solvable."
django__django-14765,12,easy,85,"The change touches a single constructor in one file and only adjusts 5–6 lines of straightforward conditional logic. No new algorithms or cross-module interactions are introduced; it merely replaces a type-checking/conversion block with an assertion and default value. The required domain knowledge is minimal—just understanding Python type checking and default parameter handling. Because the problem statement explicitly describes the desired behavior (assume a set, assert if not, default to empty set), an AI can map the description almost directly to code with little inference. Therefore the task is low in complexity and highly solvable, given clear requirements and an isolated change region."
django__django-14771,30,medium,85,"Only one file is touched and fewer than 10 lines are added. No complicated data structures or algorithms are introduced; the fix simply appends additional command-line arguments when the autoreloader re-executes the Django process. The developer must know that Python stores -X interpreter options in sys._xoptions and that the autoreloader should propagate them, plus handle boolean versus key=value forms. This demands some framework and CPython-specific knowledge, so it is not purely trivial, but the logic itself is straightforward. Because the problem statement explicitly explains what is missing (""pass -X options""), the scope is clear and the change is isolated, making it highly likely an AI could generate the correct patch even without dedicated tests."
django__django-14787,25,easy,80,"The fix touches a single line in one file and involves wrapping an existing functools.partial call with functools.wraps to copy over function metadata. There is no algorithmic difficulty or need for architectural changes; the main requirement is recognizing that partial objects lack __name__, __module__, etc., and that functools.wraps is the standard way to preserve these attributes. An engineer (or an AI) only needs moderate familiarity with Python decorators to deduce the solution once the symptom (AttributeError on __name__) is understood. Because the change is minimal and the intent is clear from the error message, the task scores low on complexity. Given the clear problem statement and the conventional remedy, an automated system has a high likelihood of producing the correct patch, hence the high solvability percentage."
django__django-14792,15,easy,80,"The fix touches only a single helper function in one file, adding a straightforward fallback to timezone.tzname(None) before defaulting to str(timezone). There are no algorithmic changes, no cross-module interactions, and the patch is only a few lines long, so overall technical complexity is low. The main challenge is recognizing that fixed-offset zones should be represented by their numeric offset, which requires some domain knowledge of time-zone behavior, but once understood the modification is trivial. Given a failing test that asserts the correct offset string, an automated system could likely infer that tzname(None) provides the desired value and generate a similar one-liner fix, so the solvability is high though not trivial."
django__django-14855,30,medium,75,"The fix touches a single helper function, replacing a one-line call with the same call plus an extra keyword argument (`current_app`). There are no algorithmic changes, data-structure changes, or cross-module refactors, so code complexity is low. However, the author needs to know how Django’s URL routing works for multiple admin sites and that `reverse()` can receive a `current_app` parameter. That framework-specific knowledge pushes the task beyond a trivial text replacement, warranting a ""medium"" label and a 30 % complexity score. 

Given a clear bug description that explicitly points out the offending line and even proposes the correct fix, an automated system has a good chance of producing the patch, even without tests. The change is localized, deterministic, and syntactically straightforward, so I estimate a 75 % likelihood that an AI could generate it correctly. Remaining risk comes from needing to understand the nuances of Django’s admin site naming, but that information is readily available in the problem statement and Django docs."
django__django-14915,10,easy,85,"The fix consists of adding a __hash__ method that delegates to the underlying value’s hash. Only three new lines in a single file are required and no algorithmic or architectural changes are involved. The error message in the problem statement ('unhashable type: ModelChoiceIteratorValue') makes the root cause obvious: the class overrides __eq__ without defining __hash__, so it becomes unhashable. Implementing __hash__ is a standard Python practice and requires minimal domain knowledge of Django internals. Because the change is small, self-contained, and the required adjustment is well-known, an AI system could infer the solution with high likelihood, especially given the clear exception message. Hence the task is categorized as easy, with low complexity and high solvability."
django__django-14999,30,medium,70,"The fix touches a single Django migrations file and adds a simple conditional check to avoid calling alter_db_table when the old and new db_table names are identical. The change is only a few lines and involves no complex algorithms, keeping the overall complexity low. However, it requires awareness of Django’s migration mechanics and how RenameModel interacts with Meta.db_table, which pushes it slightly above a trivial bug-fix. Because the required logic is concise and the desired behavior is clearly described (""should be a noop when the table name doesn’t actually change""), an automated system with a modest understanding of Django could reasonably infer and implement the solution, leading to a fairly high solvability estimate."
django__django-15022,35,medium,60,"The patch touches only one file and modifies a handful of lines, so code-wise the change is small. However, to arrive at the fix one must understand how Django builds SQL from successive QuerySet.filter() calls, how Q objects work, and how repeated filters introduce duplicated JOINs that hurt performance. That conceptual knowledge lifts the task above a trivial pattern replacement but still keeps it in the moderate range because no new algorithms or large refactorings are needed. Given a clear problem description (""each word adds an unnecessary JOIN"") and the locality of the change, an AI with framework awareness could reasonably derive the solution, though it must know that combining the per-term Q objects into a single filter eliminates redundant joins while preserving semantics. Lack of explicit tests lowers confidence somewhat, but the scope is narrow and well defined, so overall solvability is better than even."
django__django-15037,30,medium,55,"The change touches a single file and adds only about half-a-dozen lines, so the raw code delta is small. However, the fix requires an understanding of how Django’s inspectdb command converts database metadata into model definitions, how relations are represented during introspection, and the meaning of the to_field argument when the foreign key does not reference the primary key. This pushes it beyond a trivial text substitution into moderate territory.

From an AI-generation perspective, the problem statement is reasonably clear: ‘other_id should reference foo(other_id) not the implicit primary key’. Translating that into code means: (1) detect when the referenced column is not the primary key and (2) include to_field in the generated model. The introspection API already exposes get_primary_key_column, so the solution is conceptually straightforward once one explores the existing utilities. Still, an AI must navigate Django’s internal APIs and place the logic at the correct spot, which is non-obvious without codebase familiarity.

Because the scope is narrow and the required logic is simple, an automated system has a fair chance of succeeding, but missing tests and the need for framework knowledge lower the probability somewhat."
django__django-15098,20,easy,75,"Only a single regular-expression pattern in one file needed to be adjusted. The change consists of allowing up to two additional “-<word>” segments after the initial language code, expanding the match from 1 to 3 subtags (language, optional script, optional region). No new files, no algorithmic work, and no side-effects were involved; the main challenge is recognizing that the failing URLs stem from an overly restrictive regex. Once that is understood, extending the quantifier from ? to {0,2} is straightforward. An AI system can locate the regex by searching for language-code parsing logic and modify it with minimal reasoning, so solvability is high, though not trivial because it still requires scanning the framework code base and understanding the purpose of the pattern."
django__django-15103,18,easy,90,"The change touches two files and only requires adding a default value to the element_id parameter and branching the HTML formatting based on whether an id was provided. No new algorithms or deep framework knowledge are needed—just basic Python defaults and string formatting. The problem statement is explicit about the desired behavior (make the argument optional) and gives a hint that no security concerns exist. Therefore the patch is short, conceptually simple, and the search space for correct fixes is very small, resulting in high solvability. The only subtlety is updating both public filter and internal helper to stay in sync, but this is straightforward once the call graph is inspected."
django__django-15104,15,easy,85,"The patch modifies a single line in one file, replacing a hard deletion of a dict key with a pop call that provides a default. The change prevents a KeyError when the key is absent. No algorithmic complexity is introduced, and the necessary fix can be deduced directly from the traceback in the problem statement. The required domain knowledge is minimal—understanding Python dictionaries and the possibility of missing keys. Given the clarity of the error, the reproducible test case, and the straightforward solution pattern, an AI system would have a high likelihood of generating the correct patch."
django__django-15127,30,medium,60,"The fix touches a single file and adds roughly 15 lines of code. No complex algorithms are involved; the solution is primarily wiring: listening to Django’s `setting_changed` signal and updating a cached module-level constant. However, it does require specific knowledge of Django’s settings override mechanism, the `messages` framework internals (`LEVEL_TAGS`, `get_level_tags`), and how `AppConfig.ready()` is used to register signal handlers. An AI must infer that the stale cache is the root cause and that a signal listener is the canonical remedy. While that is moderately challenging, the scope is narrow, the requirements are clear, and no extensive test scaffolding is needed, yielding a medium difficulty with a fair chance of automated solvability."
django__django-15128,60,hard,65,"The bug occurs deep inside Django’s ORM query-construction logic, involving alias collision when combining QuerySets. Although the change touches only one file (~40 LOC), it manipulates internal data structures (alias_map, subq_aliases) and introduces a new parameter to an existing method, requiring careful understanding of how table aliases are generated, propagated, and renamed during query combination. Correctly fixing the issue demands solid knowledge of Django’s SQL compiler, join promotion rules, and the invariants enforced by change_aliases(). That places the task in the ‘hard’ category with moderate-high complexity.

On the other hand, the problem statement is quite explicit: it supplies a minimal failing example, pinpoints the exact assertion that fails, explains the root cause, and even suggests a concrete strategy (bumping the rhs prefix and excluding the base alias). These clues greatly narrow the solution space, making it feasible for an AI to synthesize a correct patch without needing exhaustive tests, hence a solvability estimate of about 65%."
django__django-15161,20,easy,80,"The patch touches a single file and only adds six decorator lines to existing classes. No algorithms are modified; it merely specifies explicit import paths so that Django’s migration system can generate shorter, cleaner code. While basic awareness of Django’s @deconstructible decorator is required, the change itself is mechanical and straightforward once the requirement is understood. Because the problem statement clearly describes the needed behavior (use simplified paths like models.F()), an automated system could reliably locate similar expression classes and apply the same decorator pattern. The limited scope, low line count, and absence of intricate logic make the task easy, and therefore highly solvable by an AI given the specification."
django__django-15252,35,medium,60,"The change affects a single method in one file (django/db/migrations/executor.py) and consists of a small conditional guard (~10 lines) that skips creating the django_migrations table when there are no migrations to apply. Although the code delta is small, it touches Django’s migration machinery and must respect the router logic, so a reasonable understanding of how MigrationExecutor, MigrationRecorder, and database routers interact is required. No new algorithms are introduced; the fix is largely about adjusting control-flow. Therefore the complexity is moderate (≈35%).

For an AI, the task is neither trivial pattern matching nor deep algorithmic work. The bug is clearly described—“don’t create the migration table on non-default DBs when allow_migrate() forbids it”—and the minimal fix follows directly once the call hierarchy is understood. Given sufficient context and failing tests, an AI could infer that the call to ensure_schema() must be conditional, making the solvability moderate-high (≈60%). The main challenges are locating the right insertion point and ensuring existing behavior is preserved when a plan exists, but no extensive domain-specific creativity is necessary."
django__django-15268,40,medium,60,"The change touches only one file and adds roughly a dozen lines, so the code-diff size is small. However, it modifies the generic reduction logic used by Django’s migration optimiser, which requires understanding how operations decide whether later operations can be skipped or coalesced. The solution introduces a new can_reduce_through() hook and special-cases interactions between AlterUniqueTogether and AlterIndexTogether so that an optimiser pass can collapse a remove-add pair into a single add operation. While the algorithmic complexity is low, the developer must grasp Django’s migration architecture and the subtleties of model/constraint references. This elevates the task above simple pattern-matching but does not reach ‘hard’ territory because the behaviour is well scoped and the required changes are conceptually straightforward once the issue is identified. An AI supplied with clear failing tests and the problem description would likely succeed, but some intimate knowledge of Django migrations is helpful; hence the solvability estimate is moderate-to-high rather than near-certain."
django__django-15277,15,easy,90,"The patch touches a single field constructor in one file and changes two lines: it adds a guard so that MaxLengthValidator is only appended when max_length is not None. No algorithmic complexity, no cross-module impact beyond preventing an unnecessary validator. The problem statement clearly explains the bug, provides timing evidence, and hints at the exact fix by referencing BinaryField’s pattern, making the solution largely mechanical. An AI system need only recognize that CharField.__init__ must replicate the conditional logic; this is straightforward pattern matching. Therefore the task is low-complexity (≈15%), fits the “easy” category, and is highly solvable (≈90%) given the explicit guidance in the description."
django__django-15278,40,medium,60,"Only one file and ~10 LOC were modified, indicating limited surface-area impact, but the fix touches Django’s schema-editing layer which is highly specialized. The key issue is that SQLite does not allow ALTER TABLE … ADD COLUMN when the column contains a PRIMARY KEY, UNIQUE, or DEFAULT constraint. The original code already detected DEFAULT and NOT NULL cases; the patch extends this to also treat primary_key and unique the same way, forcing Django to rebuild the table instead of issuing a simple ALTER. 

Complexity is moderate: the algorithmic change is simple (add two boolean checks) but it requires knowledge of both SQLite DDL limitations and Django’s migration machinery. There are no cross-file interactions or heavy algorithms, hence not high complexity. 

From an automated-repair standpoint, the stack-trace clearly points to “Cannot add a UNIQUE column” so an AI could infer that uniqueness triggers the failure and that the existing branch for defaults/NOT NULL can be extended. The fix pattern is repetitive and localized, making it reasonably discoverable, but it does require awareness that Django’s _remake_table path is the correct remedy. Given typical training on Django code, an AI stands a fair chance (≈60%) of producing this patch when supplied with the failing tests and error message."
django__django-15280,35,hard,40,"Although the patch touches only a few lines in a single file, the bug sits deep inside Django’s ORM prefetch-ing machinery. Fixing it requires understanding how deferred fields, relation caching, and nested prefetch_related/Prefetch interact. The actual change (skip setattr() when the relation is already cached) is simple, but recognizing that unconditional assignment overwrote an already-prefetched instance demands detailed knowledge of Django’s internals and subtle runtime behaviour. For an automated system, the search space is large and the correct guard condition is non-obvious, giving a moderate probability of success if comprehensive failing tests are available, but far from guaranteed."
django__django-15315,15,easy,80,"Only a single method in one file is modified: the __hash__ implementation of Django's Field class. The change removes the dependence on mutable attributes (model metadata) and returns to hashing solely by creation_counter. There are no algorithmic challenges, no multi-file interactions, and no need for deep architectural changes—just understanding that object hashes must remain constant for dictionary/set correctness. An AI given the clear problem statement (hash changes after model assignment, revert to previous behavior) can reasonably infer that removing model-dependent parts from the hash fixes the issue, so the task is highly solvable. However, minimal Django internals knowledge is still required, keeping solvability below 100%."
django__django-15368,20,easy,90,"The patch touches a single file and changes only two small sections: an import line and a conditional inside bulk_update. No new algorithms or structural refactoring are involved, and the required knowledge is limited to understanding Django’s query expression interface (objects exposing resolve_expression). The problem statement itself pinpoints the faulty type check and even suggests two alternative fixes, essentially providing the solution blueprint, so an automated system has a high chance of generating the correct patch. Overall, the change is straightforward (low complexity) but does require recognizing the duck-typing pattern used in Django, hence categorized as easy. Given the explicit description and narrow scope, the probability of an AI producing the right fix is very high."
django__django-15375,35,medium,55,"The patch modifies a single file with only three lines of actual logic, so the code change itself is small. However, diagnosing the bug requires understanding Django’s ORM internals—specifically how aggregate expressions are wrapped in Coalesce when a default is supplied and how the is_summary flag controls SQL generation inside subqueries. The key fix is to propagate the is_summary attribute from the original aggregate to the newly created Coalesce expression; otherwise the query compiler omits the select list, producing the malformed ‘SELECT FROM …’ SQL. An engineer (or AI) must trace the failing query, inspect expression flags, and notice that is_summary is lost during wrapping. This demands moderate framework knowledge, but once identified, the implementation is straightforward. Therefore, the task’s intrinsic complexity is moderate, and while not trivial, an AI with access to the codebase and failure example has a reasonable (≈55%) chance of arriving at the correct minimal fix."
django__django-15380,18,easy,78,"The patch modifies a single line in one file, replacing the key used to access the to_state model dictionary. The crash stems from referencing the *old* model name after a rename; switching to the current model name is all that is required. No intricate algorithm or cross-module coordination is involved, making the change low in complexity (≈18%). An engineer—or an AI system—can deduce the fix directly from the traceback and the surrounding code logic, so the task is highly solvable (≈78%). Basic familiarity with Django migrations helps, but deep system knowledge is not necessary, so the task falls into the ""easy"" category."
django__django-15382,-1,error,-1,Failed to parse response
django__django-15467,15,easy,90,"The change affects a single file and only modifies one logical line, replacing an unconditional assignment with a conditional that preserves a pre-supplied value. No new algorithms or architectural considerations are introduced; it is a straightforward guard against overwriting a parameter. Understanding the fix requires minimal Django domain knowledge (knowing what empty_label represents) and basic Python dict handling. The problem statement is explicit about both the bug and the desired behavior, even showing the exact line to edit, so an automated system has a high likelihood of producing the correct patch. The absence of accompanying tests slightly lowers confidence but the required change is deterministic and isolated, keeping solvability very high."
django__django-15499,35,medium,65,"The change touches a single Django migrations module and adds one additional optimization rule: when a CreateModel operation is immediately followed by an AlterModelManagers on the same model, they can be merged into a single CreateModel containing the managers. The algorithmic addition is straightforward pattern-matching, no new data structures or intricate logic. 

Complexity is moderate because although the code diff is small, a contributor must understand how Django’s migration optimizer works, what AlterModelManagers represents, and how to preserve semantics when combining operations. This requires some framework-specific knowledge, pushing it beyond an ‘easy’ patch but far from a large architectural overhaul. 

From an automated-generation perspective, the task is achievable: the problem statement explicitly says that CreateModel + AlterModelManagers should reduce to CreateModel, mirroring existing logic already present for AlterModelOptions. An AI could identify the existing block that handles AlterModelOptions and replicate it for AlterModelManagers with minimal adjustments. Therefore solvability is above average, though not near certain because it still demands familiarity with model attributes (e.g., managers parameter) and correct placement in the reducer logic."
django__django-15503,45,hard,40,"Although the diff touches only a single file and fewer than 30 lines, the change corrects subtle behaviour across three different SQL back-ends. To craft the fix the developer needed to understand how Django compiles JSON paths, why compile_json_path treats integers as array indices, how has_key/has_keys build their paths, and how the lookups are reused by KeyTransformIsNull and JSONExact. The solution introduces a hook (compile_json_path_final_key), overrides it in a new subclass, and rewires several call sites so that numeric keys are quoted only when needed. This conceptually intricate but small patch therefore scores mid-range on raw complexity but high in required domain expertise, placing it in the “hard” category. For an AI, locating the precise fault and realising that only the final path segment should be treated differently is non-trivial; without explicit tests in the prompt the search space is large, so the likelihood of synthesising the exact patch is moderate to low."
django__django-15525,35,medium,40,"The patch itself is tiny (three lines added/modified in a single file), so algorithmic and code-size complexity is low. However, recognizing what to change requires understanding how Django’s serialization process, model state, natural keys, and multi-database routing interact. The bug arises because Model(**data) defaults to the ""default"" DB when computing natural_key(), so foreign-key lookups are issued to the wrong database. The fix sets obj._state.db before calling natural_key(). An AI must connect the stack-trace failure to this subtle state flag—a piece of framework-specific knowledge that is not obvious from general Python patterns. The problem statement gives the error trace and context, but without explicit mention of _state.db. Therefore the overall task is moderately complex and not purely pattern-based, placing it in the ""medium"" category. While the change is concise, the domain insight required lowers the likelihood that an AI would discover the exact fix unaided, so solvability is estimated at 40%."
django__django-15554,65,hard,35,"The fix touches the heart of Django’s ORM join planner. Although only one file is edited, the change adds a new parameter that is threaded through five different, tightly-coupled internal methods (join, build_filter, build_filtered_relation_q, setup_joins, and their callers). Understanding why a join alias must not be reused when different FilteredRelation conditions apply requires deep knowledge of how Django represents SQL joins, how alias reuse works, and how filtered relations are compiled. The solution introduces conditional reuse logic and switches between structural equality (==) and semantic equality (equals) depending on context – a subtle distinction that avoids unwanted alias merging while retaining existing optimisation behaviour elsewhere.

The problem statement gives a high-level symptom (only one JOIN produced) but not the root cause, the call stack, or the exact place to intervene. An AI system would have to explore the ORM internals, formulate a hypothesis about alias reuse, design a minimally invasive flag that propagates through several layers, and update all call sites consistently. This requires non-trivial reasoning about side effects, optional parameters, backwards compatibility, and test expectations.

Therefore, the patch is quite complex (65%) and belongs to the “hard” category. The likelihood that an AI could deduce and implement this precise fix from the description alone is relatively low (≈35%), because it demands framework-specific insight and coordinated multi-site edits rather than a localised change."
django__django-15561,35,medium,60,"The fix touches only two files and fewer than 30 lines: it introduces a class-level tuple of attributes that don’t influence the database schema and re-uses it inside the schema editor. No new algorithms or architectural refactors are involved, only moving an existing hard-coded list and appending the missing “choices” entry. However, a solver must understand where Django decides whether a field alteration requires SQL, notice that the ‘choices’ attribute is handled incorrectly, and realize that this list is duplicated and should live on the Field class. This requires moderate familiarity with Django’s migration internals but no complex logic. Given the clarity of the bug description and the relatively isolated nature of the change, an automated system with code-base awareness has a decent chance of inserting ‘choices’ into the exemption list or, as the patch does, centralizing the list. Still, identifying the exact location (_field_should_be_altered) and ensuring the change is generic across all backends requires more than trivial pattern matching."
django__django-15563,65,hard,30,"Although only ~20 lines were changed across two files, the fix touches the core of Django’s ORM SQL-generation pipeline (sql/compiler.py and sql/subqueries.py). Correctly solving the bug requires deep knowledge of how UpdateQuery pre-selects primary keys, how multiple-table inheritance forms primary-key chains, and how related_updates are dispatched to the parent tables. The developer had to:
- Detect that a single list of primary keys is insufficient when some parents aren’t on the PK chain.
- Introduce an index mapping to pull the right column from the SELECT, build a per-model dict of ids, and propagate that to the follow-up UpdateQuery objects.
- Preserve the fast path behaviour for databases that support UPDATE … FROM.
These subtleties go far beyond pattern matching; they need intimate understanding of Django’s internal data structures (Query, PathInfo) and database semantics. An AI limited to the public problem statement and standard tests would struggle to discover this multi-step flaw and craft the correct, backwards-compatible adjustment, hence the relatively low solvability score."
django__django-15569,15,easy,90,"The patch adds a single line invoking an existing helper (cls._clear_cached_lookups()) inside RegisterLookupMixin._unregister_lookup so the behavior mirrors register_lookup. Only one file and one logical change are involved, no new algorithms or data structures are introduced, and the necessary method already exists. Understanding that the cache must be cleared is highlighted explicitly in the problem statement, so an AI can map the requirement to the fix with minimal codebase knowledge. Thus complexity is very low, classified as easy, and the likelihood an AI generates the correct solution is high because the task is localized, deterministic, and test-driven."
django__django-15572,18,easy,78,"The patch touches a single file and adds two simple guard conditions (checking `if dir` / `if directory`) to filter out empty strings when iterating over configured template directories. No new abstractions, algorithms, or cross-module interactions are introduced. The required insight is recognizing that an empty string was unintentionally converted to the project root, so skipping falsey paths restores expected behavior.

Complexity is low because:
- Only two lines are modified.
- Logic change is a straightforward conditional check.
- No additional tests, migrations, or configuration changes are required.

Solvability for an AI is fairly high: the bug description explicitly states that empty strings should be ignored. Given that information, adding a truthiness filter is an obvious fix with very small surface area and minimal risk of side effects. Still, some understanding of Django’s template loader internals and pathlib handling is helpful, so solvability is not maximal but remains well above average."
django__django-15629,60,hard,35,"The fix touches five core Django modules (generic schema editor, SQLite-specific schema editor, field definition logic, and backend feature flags). It adds new decision branches that detect collation changes, decide when to drop/re-create foreign keys, and propagate the new collation to related (FK) columns. Although the individual code snippets are not algorithmically complex, they require a solid understanding of Django’s migration engine, database DDL nuances across backends, and the interaction between model fields, schema editing, and foreign-key constraints. An AI must reason about subtle state held in db_parameters, know that collations must match on PK/FK pairs, and update several call sites consistently. The problem statement describes the symptom (FK creation fails) and shows the correct SQL, but it doesn’t spell out where in Django the fix should live, so discovering the right insertion points demands deep framework knowledge. Therefore the change is moderately complex (≈60%) and fits the “hard” category. Given these challenges and the need for coordinated edits across multiple files, an AI has a limited but non-negligible chance (~35%) of generating the exact patch from the description alone."
django__django-15695,15,easy,85,"The fix touches a single file and adds only three lines that perform a simple guard-clause check. No new algorithms or deep framework changes are introduced; it is a straightforward logical condition preventing a duplicate rename. The main challenge is recognizing that re-applying the operation when the names are identical should be a no-op, which can be inferred directly from the crash message describing a duplicate index. Therefore, the overall technical complexity is low. An AI given the problem description and failing test/log output would likely deduce that the solution is to skip the rename when the old and new names match, so the solvability is high."
django__django-15731,20,easy,90,"The change affects a single file with only a few lines modified: adding an import of functools.wraps and decorating an inner function. No new algorithms or architectural changes are introduced. The required insight is that functools.wraps sets the __wrapped__ attribute, which inspect.signature relies on, so metadata copying is automatic. While some understanding of Python introspection and Django’s manager/queryset relationship helps, the problem statement explicitly points to the cause and suggests the solution, making it straightforward for an automated system. With minimal code footprint and a clearly described fix, complexity is low and the likelihood that an AI could generate the correct patch is high."
django__django-15732,45,medium,35,"The change touches a single core framework file (django/db/backends/base/schema.py) but modifies several interconnected helper functions that deal with DDL generation and constraint discovery. The fix introduces a new helper (_unique_constraint_name), changes the default-name logic when creating unique constraints, and adjusts the constraint-deletion path to ignore primary-key constraints and to handle back-ends that allow multiple constraints on the same columns. 

Complexity is moderate (≈45%). It is not just a one-line patch; it requires understanding how Django names constraints, how the schema editor searches for them, and how different database back-ends behave. Still, it is contained in one file and involves ~30 new/changed lines without algorithmic heavy lifting. 

Category marked ""medium"" because the solution demands familiarity with Django’s migration machinery and database specifics but no deep algorithmic innovation. 

Solvability for an AI from only the bug description is fairly low (≈35%). The description identifies the symptom but not the internal expectation of exactly one constraint, nor the naming conflict that must be resolved. Determining that the fix should a) exclude primary_key constraints, b) prefer the default unique_together name when multiple matches exist, and c) modify the naming helper requires non-obvious, framework-specific insight. Without extensive existing unit tests or explicit acceptance criteria, an AI would likely struggle to converge on the precise set of changes needed to satisfy all edge cases."
django__django-15741,12,easy,90,"The fix consists of adding a single line that converts the incoming format_type parameter to a plain string. Only one file is touched and no algorithms are involved, keeping overall complexity very low. The main insight is recognizing that Django’s lazy translation objects must be coerced to str before using them as attribute names; this is standard knowledge for anyone familiar with Django’s i18n utilities. The problem statement explicitly describes the failure scenario and hints at the solution (“format_type may be lazy”), so an automated system or a developer can directly infer that str() conversion is needed. Since the required change is minimal, localized, and the correct solution is unique and obvious, the task is highly solvable by pattern-matching or simple reasoning, leading to a high solvability percentage."
django__django-15814,35,medium,90,"The fix is a one-line change in a single file, so the code modification itself is simple. However, understanding why that line is needed requires moderate familiarity with Django’s ORM internals—specifically how proxy models, select_related(), and only() interact, and the role of _meta.concrete_model in resolving the real (non-proxy) model. That domain knowledge moves the task out of the “easy” tier into “medium” complexity (~35%).

From an automated-repair perspective the problem is highly solvable (~90%) because the bug report explicitly pinpoints the offending line and even states the exact replacement that makes the query work. An AI system following the report has a clear, deterministic path to the correct patch, and no alternative implementations are likely. Test coverage is not provided here but the behavioral description is precise and the change is isolated, making it straightforward to validate.

Overall, the task is of moderate complexity but very high solvability given the explicit hint in the problem statement."
django__django-15851,10,easy,90,"The patch consists of re-ordering two lines in a single function so that optional parameters are appended to the psql command before the database name, matching PostgreSQL’s CLI expectations. No new logic, data structures, or cross-module interactions are introduced. The problem statement explicitly states the required change (“args list just need to be constructed in the proper order, leaving the database name for the end”), making the fix straightforward pattern manipulation. Consequently, the technical complexity is minimal, and an AI system could infer and apply the fix with high likelihood, leading to a high solvability score."
django__django-15863,10,easy,90,"The patch alters a single line in one file, switching from repr() to str() when converting the input value prior to creating a Decimal. This is a straightforward fix: repr() produces a representation like ""Decimal('…')"" which cannot be parsed back into a Decimal, whereas str() yields the plain numeric string that preserves precision. No additional logic, algorithms, or cross-module interactions are involved. The bug is clearly described in the problem statement with a minimal working example, making it evident what needs to change. An AI system would likely detect that str() is the correct replacement once the failure scenario is reproduced, so solvability is high. The task is simple enough that it falls in the lower end of the complexity scale."
django__django-15916,40,medium,65,"The change touches a single core Django file (forms/models.py) and adjusts roughly twenty lines, mainly removing earlier override logic and centralizing the retrieval of formfield_callback through the Meta Options object. While the diff itself is small, understanding why those particular places must be edited requires knowledge of Django’s ModelForm metaclass mechanics and how modelform_factory builds a new form class. No new algorithms are introduced, but subtle framework-level interactions (metaclass attribute precedence, factory parameter propagation) must be reasoned about. Therefore the complexity is moderate, not trivial. For an AI the task is solvable because the problem statement clearly explains the undesired behaviour and shows a concise expected outcome, and the necessary code touch points are limited and isolated. However, it still demands familiarity with Django’s internal API and comprehension of metaclass flow, so the likelihood of an automatically generated correct fix is not extremely high but better than chance—estimated at roughly two-thirds."
django__django-15930,35,medium,65,"The change is confined to a single method in one file, adding ~5 lines of straightforward logic, so structural complexity is low. However, it requires familiarity with Django's ORM compilation pipeline and the special-case behavior where a Q object matching everything compiles to an empty string in a WHERE clause. Recognizing that this empty string is illegal inside a CASE WHEN expression and must be replaced by a literal predicate (TRUE) involves moderate domain knowledge of SQL as well as Django internals, thus qualifying as medium difficulty. The problem statement is clear, reproducible, and includes the failing SQL, making the solution space narrow and increasing solvability. An AI with context of the compiler structure can spot the empty condition and substitute a Value(True), so the likelihood of automatic repair is better than average but not trivial, leading to an estimated 65% solvability."
django__django-15957,65,hard,30,"The fix touches deep internals of Django’s ORM. Although only one file is modified, the change introduces ~30 lines that rely on advanced ORM concepts: compiler-generated ordering, window functions (RowNumber()), custom lookups (GreaterThan / LessThanOrEqual), and manipulation of Query limits. Implementing _filter_prefetch_queryset requires understanding how slicing is represented at the SQL compiler level and how Prefetch interacts with QuerySet filtering. Converting slice limits into a window function predicate is non-obvious and demands solid SQL knowledge alongside Django internals. An AI would need to reason about low_mark/high_mark, remove limits, replicate ordering, and build a compound Q object—steps that go far beyond pattern matching. Because the problem description only states that sliced querysets raise an AssertionError, it gives no hint that a window function solution is required, leaving a large design space. Consequently, the task is complex (≈65%) and falls into the “hard” category, with a relatively low likelihood (≈30%) that an AI could infer and implement the correct patch unaided."
django__django-15973,35,medium,60,"The fix touches a single line in one core Django file, so the code change itself is small. However, identifying the root cause requires understanding how Django’s migration autodetector builds dependency graphs for relations, notably the difference between the target model (remote_field.model) and an explicit through model (remote_field.through) for ManyToMany fields across apps. The bug only manifests when the through model is given as a string from another app, making the stack-trace non-trivial to interpret. An AI must reason about Django internals and realize that resolve_relation() must receive the through model, not the remote target. This needs moderate framework knowledge but no complex algorithmic work, so complexity is moderate (≈35%) and placed in the “medium” category. Because the patch is concise once the issue is understood, an AI with access to the error trace, problem description, and source could plausibly infer the correction, but the lack of direct tests and the necessity of framework insight lower the certainty. Hence solvability is estimated around 60%."
django__django-15987,10,easy,85,"The bug fix involves a single‐line change in one file, converting Path objects to strings before membership checking. No new algorithms or cross-module interactions are required, and domain knowledge is limited to understanding that Path objects do not compare equal to their string representations. Such type-coercion issues are common and can be detected by straightforward reasoning or pattern matching. Therefore, the technical complexity is low. Given a failing test that demonstrates duplication detection with Path instances, an AI could infer that coercing to str resolves the issue, yielding a high likelihood of automatic repair. The task is categorized as easy and highly solvable."
django__django-16032,55,hard,32,"Although the textual diff is small (≈20 lines across two core ORM modules), the change touches the heart of Django’s query-building machinery. Understanding why an __in subquery suddenly returns ten columns instead of one requires knowledge of how QuerySet.annotate(), alias(), clear_select_clause(), and the _set_values() logic collaborate to build the SELECT list that the SQL compiler will generate. 

Key challenges:
• Identifying that the wrong SELECT clause is carried into the RHS subquery only when alias() follows annotate(), a subtle state-management issue.
• Realizing that the old computed has_select_fields property prevented accurate clearing and that a mutable flag is required.
• Knowing that set_values() must set this flag and that clear_select_clause() should be avoided in this particular path.

Such insights depend on deep familiarity with Django’s ORM internals, not just surface API use. Therefore, while the fix is concise, it is architecturally delicate, justifying a ‘hard’ rating and a complexity score above 50.

For an automated system, the failing symptom (""sub-select returns 10 columns"") and the provided test give some guidance, but the root cause is buried in state flags and interaction between multiple QuerySet methods. Without extensive learned knowledge of Django internals, an AI would likely struggle to synthesize the exact flag introduction and method adjustments. Hence the solvability estimate is kept low (≈32%)."
django__django-16082,15,easy,85,"The fix consists of adding a single constant (Combinable.MOD) to an existing tuple that lists arithmetic operators whose expressions must have their output_field resolved. Only one file and one logical line of code are touched, with no algorithmic change or deep refactor. The conceptual change is straightforward once the location of the operator list is found. An AI system given the bug description (that MOD behaves inconsistently compared to the other arithmetic operators) can deduce that modulo should be included alongside ADD, SUB, MUL, and DIV. The main challenge is navigating Django’s expression resolution code to find the relevant operator mapping, but the required domain knowledge is minimal and pattern-based, making the task highly solvable."
django__django-16100,35,medium,60,"The change touches a single method in one file and adds roughly a dozen lines that wrap existing logic in a transaction.atomic() block. The algorithmic complexity is low—no new algorithms or data structures are introduced—but some knowledge of Django’s transaction management, the admin list-editable flow, and multi-database routing (router.db_for_write) is required. An AI must recognize the need for atomicity, choose the correct helper, and supply the proper database alias parameter. This goes beyond a trivial text replacement but does not involve large-scale refactoring, so overall complexity is moderate.

From the problem statement, the desired fix (wrap the bulk save in a transaction) is clear, and Django provides a very standard API for it, making the task realistically achievable. However, correctness is sensitive to details like multi-DB support, error handling, and import placement, which lowers the solvability slightly. Without explicit tests, the AI has to infer best practices from the codebase, yet these patterns occur elsewhere, so reuse is possible. Therefore the problem sits in the medium range for both complexity and solvability."
django__django-16116,15,easy,85,"The fix involves a small behavioral change in a single management command: when --check is supplied to makemigrations, the command should exit before writing migration files. The patch only adjusts help text and moves an if-block to call sys.exit(1) prior to file generation. No algorithms or multi-module coordination are required; familiarity with Django’s command flow is enough. Because the requirement is clearly stated (""don't actually write them"") and the necessary code lines are obvious, an automated system could reliably infer the needed reorder, making the task highly solvable. Overall complexity is low due to minimal code modifications and straightforward logic."
django__django-16136,35,medium,65,"The fix touches a single function in one file and adds ~10 lines, so the code change itself is small. However, understanding why the bug occurs requires knowledge of Django’s sync/async dispatch mechanism: when a view is declared async, anything it returns to the dispatcher must be awaitable, otherwise Python raises a TypeError. The developer had to detect that http_method_not_allowed was always synchronous and, for async views, wrap its response in a coroutine before returning it. That domain-specific insight lifts the complexity above trivial pattern-matching but not into algorithmic territory. An AI with access to the traceback, the method implementation, and general knowledge of async patterns could plausibly infer that wrapping the response in an async function solves the issue, so the solvability is moderate-to-high. Lack of formal tests in the prompt reduces guidance, but the error is deterministic and the fix is isolated, keeping overall difficulty manageable."
django__django-16139,30,medium,80,"Only one file is modified with a net change of three lines. The fix is straightforward string formatting that uses the current instance’s primary key so the generated URL is correct regardless of whether the UserAdmin is accessed via its pk or another field. While the code alteration itself is trivial, identifying the need to include the instance.pk in the relative URL requires understanding how Django admin constructs nested URLs when the _to_field parameter is present. Therefore complexity is a bit above a pure typo but still low overall (≈30%). An AI could likely solve this because the problem statement gives an explicit before/after example and even describes the exact code that needs to change, so solvability is high (≈80%). Domain knowledge of Django’s admin URL structure is helpful but not deep; the solution is essentially a small string manipulation, so the task falls into the “medium” category rather than “easy”."
django__django-16145,15,easy,85,"The patch touches a single file and adds a small conditional block (7 lines) to map the shorthand host string ""0"" to ""0.0.0.0"" when constructing the display address. No algorithms or cross-module interactions are involved; it is a direct string-replacement fix. Understanding the existing code flow (building the server-start message) and Python string formatting is sufficient, which makes the change straightforward. The problem statement is explicit about the expected behavior, so an AI can directly map the requirement to the needed code change. Given the minimal scope and clear specification, the task is highly solvable by automated techniques, though absence of dedicated tests means the AI must rely on reasoning rather than failing tests to guide it."
django__django-16255,15,easy,90,"The change affects a single function in one file and consists of replacing a call to max() with one that supplies a default value so that it no longer raises ValueError when the input list is empty. There are no cascading effects, no new abstractions, and no multi-module considerations. Understanding the issue only requires basic Python knowledge (how max() behaves with empty iterables) and a minimal awareness of Django’s sitemap API, which is clearly described in the problem statement. Because the bug, the traceback, and an illustrative fix are all provided, an automated system or developer can confidently craft the correct patch. Consequently, the technical complexity is low and the task is highly solvable."
django__django-16256,35,medium,85,"The fix touches two framework-internal files and adds around a hundred lines, but every addition follows an identical, boiler-plate pattern: define async wrappers (acreate, aget_or_create, aupdate_or_create) that simply call the existing synchronous counterparts via sync_to_async and copy the alters_data attribute. No new algorithms or intricate control flow are introduced. The main difficulty lies in knowing which related-manager classes exist and where to inject the wrappers, which requires moderate familiarity with Django’s ORM internals but no deep algorithmic reasoning. The problem statement itself explicitly describes both the issue and the desired remedy, even showing a miniature diff for guidance, so an automated system could reliably generate the patch by pattern matching and repetition. Therefore, complexity is moderate, the task category is medium, and the likelihood of an AI producing the correct solution is high."
django__django-16263,78,very hard,15,"The patch touches four core ORM modules (expressions, query_utils, sql.query, sql.where) and introduces new recursive reference-tracking logic (get_refs) plus a summarization pathway that propagates through expression resolution, filter building, and aggregation generation. It changes subquery-generation rules, rewrites annotation masking, and must preserve existing behaviour across many query variants (HAVING, QUALIFY, distinct, slicing, combinators). Implementing this demands deep knowledge of Django’s internal query compiler, SQL semantics, and aggregation edge cases. The problem statement gives only the high-level goal of stripping unused annotations from count() queries; it does not hint at the required architectural touch-points or the intricate interplay between annotations, WHERE/HAVING clauses, and subquery decisions. An AI would have to reverse-engineer Django’s internals and foresee numerous subtle failure modes, making the chance of generating an equivalent fix extremely low despite a well-defined objective."
django__django-16315,45,medium,40,"The patch touches two core ORM files (query.py and compiler.py) but changes are limited to ~15 lines. The solution is conceptually straightforward—convert user-supplied field names to Field objects early so their `column` attribute (respecting db_column/mixed-case) can be used when building the ON CONFLICT clause. However, implementing it correctly requires familiarity with Django’s model meta API, the bulk_create/on_conflict code path, and how Query/Compiler interact. An AI must trace where update_fields/unique_fields are later consumed, notice they’re compared to `.column`, and realise the need to transform and pass generators of column names. This demands non-trivial domain insight but no complex algorithmic work. Therefore complexity is moderate (45%), solvability is modest (40%): with clear bug description an advanced AI could infer the missing field->column mapping, yet navigating Django internals without tests makes success uncertain."
django__django-16333,18,easy,88,"The change affects a single method in one file and adds just two lines of straightforward logic: after saving the user instance, invoke self.save_m2m() if it exists. There are no algorithmic challenges, no cross-module interactions, and no refactoring required. Although a bit of Django ModelForm knowledge is needed, the problem statement itself explicitly highlights the missing call, making the required fix almost mechanical. Therefore the technical complexity is low, justifying an 18% complexity score and the 'easy' category. Given the clarity of the specification and the minimal code involved, an automated system has a high likelihood (≈88%) of generating the correct patch."
django__django-16429,15,easy,90,"The patch touches a single file and adds one keyword argument (`tzinfo=d.tzinfo`) to the datetime constructor. No algorithms are altered, no additional files or dependencies are involved, and the change is entirely localized. The required insight is recognizing that the newly-created pivot datetime must preserve the timezone information of the input to avoid subtracting aware and naive datetimes—a common Python datetime pitfall. This is straightforward once the stack trace is understood. Because the problem statement clearly identifies the faulty code section and even hints at the exact fix, an automated system with minimal reasoning about datetime awareness could reliably produce the correction. Therefore the change is low in complexity, categorized as easy, and highly solvable by an AI."
django__django-16454,30,medium,78,"The change touches a single file and adds about ten lines, so the code delta is small. However, to arrive at the fix one must understand how Django wraps argparse, how subparsers inherit parser_class, and why CommandParser needs the called_from_command_line flag to format errors correctly. The solution requires overriding add_subparsers and using functools.partial to inject the missing keyword argument, a conceptually simple but non-obvious maneuver that shows moderate domain knowledge of both Django internals and Python’s argparse API. Because the problem statement explicitly explains the failure scenario and hints at the necessary propagation of extra arguments, an AI with code-base context could likely infer the correct place to intervene; the patch pattern (override method, pass through kwargs, use partial) is standard. Therefore complexity is moderate (30%), category “medium”, and solvability is relatively high (78%) but not trivial due to the need for specific framework insight."
django__django-16485,15,easy,90,"The patch is a one-line change in a single file, adjusting a boundary condition from `p < 0` to `p <= 0`. There are no algorithmic changes, no new functions, and no cross-module interactions, so the technical complexity is low. The problem statement clearly identifies the failing inputs (`'0.00'` and `Decimal('0.00')` with precision 0) and the resulting exception, directly pointing any developer (or automated system) to inspect the branch that handles `p == 0`. Recognizing that the condition must include zero is straightforward pattern-matching logic, requiring minimal knowledge of Python’s `decimal` module or Django’s formatting utilities. Because the failure is fully reproducible and isolated, an AI has a high likelihood of generating the correct fix once it spots the off-by-one comparison, hence the high solvability percentage."
django__django-16493,-1,error,-1,Failed to parse response
django__django-16502,35,medium,60,"The change touches only one file and adds roughly 20 lines, so the code-volume impact is modest; no new algorithms or cross-module refactors are needed. However, the fix lives deep in Django’s development HTTP server and must respect subtle details of the HTTP/1.1 and RFC 9110 specifications (omitting the message body and sometimes the Content-Length header for HEAD requests, while still handling keep-alive logic). Implementing it correctly requires understanding: (1) how Django’s internal WSGI handler streams responses, (2) how headers are finalized and sent, and (3) how HEAD semantics differ from GET. Those protocol nuances elevate the problem above a trivial tweak but don’t make it architecturally complex. For an AI, the problem statement clearly states the desired behavior (“response bodies must not be returned for HEAD requests” and mentions the Content-Length issue), giving enough guidance, but translating that into the exact locations in basehttp.py and preserving all side conditions (persistent connections, headers not yet sent, consuming the iterator) is non-trivial. Therefore the task is moderately complex (35%), requires medium depth understanding, and is reasonably solvable with good context (60%)."
django__django-16527,15,easy,90,"The fix involves modifying a single boolean expression in one file, replacing an existing permission check with another. No new functionality, algorithms, or cross-module interactions are introduced; it is a straightforward logic adjustment. Understanding that “Save as new” represents an add operation and therefore requires add permission is mild domain knowledge, easily inferred from the problem description. Because the change is local, consists of only a few tokens, and the intent is explicitly stated in the problem statement, an AI system has a high likelihood of producing the correct patch. The overall complexity is low, hence an ""easy"" categorization and a high solvability score."
django__django-16560,45,medium,60,"The patch touches two core files and several related classes, introduces a new constructor argument, stores it, propagates it through deconstruct/clone/eq/repr, and uses it when raising ValidationError. There is no new algorithmic logic; most changes are repetitive boilerplate across constraint types. Understanding Django’s constraint system and migration deconstruction is necessary but not deep architectural refactoring. An AI could infer that the new parameter must be forwarded everywhere and included in equality and representation methods, yet remembering all the places (validate(), deconstruct(), __eq__, __repr__, subclass __init__) adds some complexity. Therefore the change is of moderate complexity and reasonably solvable with clear requirements, but not trivial because omissions would break tests."
django__django-16569,15,easy,90,"The patch touches a single line in one module and only adds an additional None-check before comparing the index with an integer. No new algorithms, data structures, or cross-module interactions are introduced. The bug is exposed by a straightforward TypeError that clearly indicates the comparison between NoneType and int, making the root cause easy to diagnose. Domain knowledge of Django formsets helps but is not strictly necessary; general Python experience is enough to understand why the comparison fails and to craft the fix. Because the symptom, cause, and minimal change required are all evident from the exception and the problem description, an automated repair system would have a high chance of producing the correct patch, yielding a high solvability score."
django__django-16595,22,easy,90,"The change affects a single method in one file and consists of extending an existing isinstance() check to include AlterField alongside RemoveField. No new algorithms are introduced, and the logic is straightforward once the bug is identified. Understanding Django’s migration optimizer helps, but the problem statement clearly explains the missing condition and even suggests the exact fix, reducing required domain expertise. Because of the minimal code delta, clear specification, and deterministic nature of the solution, an automated system has a high likelihood of generating the correct patch."
django__django-16612,15,easy,90,"The fix touches a single file with a 3-line modification, replacing a hard-coded path redirect with Django’s built-in get_full_path() helper to preserve the query string. No new algorithms or structural changes are involved; the developer only needs to know that request.path omits the query string and that get_full_path(force_append_slash=True) exists. The problem statement clearly describes the bug, the expected vs. actual behavior, and even points to the offending line, drastically narrowing the solution space. Therefore, complexity is low, the task is categorized as easy, and an AI system familiar with Django’s Request API has a very high likelihood of generating the correct patch."
django__django-16631,40,medium,45,"The patch touches two core authentication modules, introduces a new helper and alters the session-verification flow to iterate over SECRET_KEY_FALLBACKS. Although the code delta is small (~30 added lines across 2 files), it requires understanding how Django derives the session auth hash, where salted_hmac is used, and why cycling the session key is needed once an old secret validates. This security-oriented logic is not obvious from superficial pattern matching, but it does not demand heavy algorithmic work or large-scale refactoring, placing it in the moderate complexity range. An AI system could plausibly infer that fallback secrets must be tried when the primary secret fails, yet must also remember to update the stored hash afterwards; without explicit tests or documentation cues this nuance is easy to miss, so the likelihood of producing the exact fix is below 50%, though not implausible."
django__django-16642,12,easy,88,"The fix consists of adding two key-value pairs to an existing dictionary inside a single file; no algorithms, control-flow changes, or multi-module interactions are involved. The task is straightforward once one understands that the missing encodings returned by mimetypes.guess_type are 'br' (Brotli) and 'compress' (for .Z files) and that they need MIME mappings. Minor domain knowledge about MIME types is helpful but easily discoverable. Because the symptom, root cause, and required change are explicitly described in the problem statement, an AI system can confidently generate the correct patch with minimal context, leading to a high solvability estimate. However, a small amount of reasoning is still needed to link the .Z extension to the 'compress' encoding string, so the solvability is not 100%."
django__django-16661,40,medium,55,"The fix touches a single method in one file and adds only a few logical clauses, so the code-change footprint is small. However, deciding what to add requires understanding Django’s ModelAdmin.lookup_allowed internals, how multi-table inheritance is represented in _meta.parents, how primary-key ForeignKeys interact with auto_field, and how the admin determines whether a relation prefix should be considered ‘safe’. That domain knowledge goes beyond simple pattern matching but doesn’t involve new algorithms or large-scale refactoring, putting overall complexity in the moderate range (≈40%).

Given a failing test that pinpoints the scenario and a detailed problem description, an automated system has a reasonable chance of deriving the needed guard conditions, especially if it can inspect runtime state to see why the original check misfires. Still, crafting the exact combination of three extra predicates (exclude parent pointers, auto_field, and foreign keys targeting the PK) is non-obvious and may require iterative experimentation, so solvability is estimated at about 55%. Therefore the task is categorized as “medium”: it needs some framework insight but remains an isolated, well-scoped bug fix."
django__django-16662,15,easy,85,"The fix involves a single-file, few-line modification that changes the sorting key for import statements so that plain ""import"" lines precede ""from … import …"" lines. No deep algorithmic work or architectural understanding is required—just awareness of Python’s tuple-based sorting and the desired ordering rule. The problem statement is explicit about what the ordering should be, making the required change obvious. An AI system can readily craft the lambda that returns a tuple (is_from, module_name), where the first element ensures ""import"" sorts before ""from"". Given the clarity and minimal scope, the task is low in complexity and highly solvable."
django__django-16667,15,easy,90,"The change touches a single file with only two new lines, adding an extra except clause to catch OverflowError alongside the existing ValueError handling. No algorithmic or architectural changes are involved; it’s a straightforward defensive programming fix. The problem statement clearly points to the exact traceback and offending line, so an engineer or an AI only needs to recognize that datetime.date() can also raise OverflowError for huge integers and mirror the existing ValueError handling. Required domain knowledge is minimal (basic Python exception types and Django widget flow). Given the explicit stack trace and minimal code changes, an AI system has a high likelihood of producing the correct patch."
django__django-16801,30,medium,80,"The change touches only one file and alters a few conditional checks (≈10 lines). No new algorithms or cross-module refactors are introduced, keeping technical complexity fairly low. However, it requires understanding Django’s model lifecycle and how ImageField uses the post_init signal, which is beyond trivial pattern matching, hence classified as medium (30%).

From the problem statement it is immediately clear what needs to happen: register the post_init handler only when width_field or height_field are defined, and adjust the follow-up guard accordingly. The description even states the expected behavior and performance outcome, so an automated system with modest framework knowledge could reliably craft the condition change. Given the limited scope, unambiguous requirement, and absence of tricky edge cases, the likelihood that an AI could synthesize the correct patch is high (~80%).

The main cognitive load lies in knowing which condition to tighten and ensuring the early-return logic in update_dimension_fields stays consistent. This demands some domain insight but no deep algorithmic work, keeping overall complexity moderate while solvability remains high."
django__django-16819,30,medium,60,"The actual fix is only a handful of lines in a single file: override AddIndex.reduce() so that an immediately-following RemoveIndex for the same name cancels the operation. While the code change itself is simple, a solver must understand how Django’s migration optimiser works, recognise that many other Operation subclasses implement a similar reduce() pattern, and replicate that pattern for AddIndex. That requires some familiarity with Django internals but not deep algorithmic work. Because the pattern is well established in neighbouring classes, an automated system that scans the codebase can infer the right implementation, giving a moderate probability of success. The absence of explicit tests in the prompt lowers confidence but the requirement is clear and the solution space is small, so the task remains reasonably solvable."
django__django-16877,22,easy,88,"The required change is the addition of a single template filter that iterates over a sequence and runs Django’s existing conditional_escape() on each element. Only one file is touched and about ten new lines are added; there is no intricate logic, state handling, or multi-module interaction. The only domain knowledge needed is knowing how to register a template filter in Django and that conditional_escape() provides the escaping. Because the problem statement explicitly describes the desired behavior, gives an example, and essentially outlines the implementation approach, an AI system can reliably map the description to code with minimal ambiguity. Therefore, the task is low in complexity and highly solvable."
django__django-16899,10,easy,90,"The change only involves modifying the wording of one error-message string in a single file. No algorithms, data structures, or cross-module interactions are affected. An AI needs to read the problem statement, locate where the original string is built, and insert the missing field name. That is straightforward text manipulation that requires minimal domain knowledge of Django admin checks. Because the scope is tiny, clearly defined, and easily testable, the likelihood that an automated system could generate the correct patch is very high."
django__django-16901,30,medium,70,"The change touches a single file with only a few lines added, and it corrects a logical error rather than introducing new architecture. Understanding that n-ary XOR evaluates to true for an odd number of true operands (parity) and that the previous fallback incorrectly required exactly one true operand is the key insight. Implementing the fix is straightforward: wrap the summed CASE expressions in a modulo-2 operation and compare the result to 1, but only when more than two operands are present (for two operands the original sum==1 is still correct). While small, the fix requires awareness of SQL expression construction within Django’s ORM and how different databases handle XOR, giving it moderate, not trivial, complexity. The problem statement is clear and provides concrete failing examples, so an AI with access to the codebase and basic math/SQL knowledge has a good chance of generating the correct patch, though it must notice the need to retain the special case for two operands. Hence complexity ~30%, category ‘medium’, and solvability ~70%."
django__django-16938,35,medium,60,"The change touches two files and adds a small piece of logic: insert a select_related() call before only('pk') when iterating through a many-to-many relation during serialization. While the code delta is minimal, identifying the correct fix requires understanding Django’s QuerySet API, how select_related and only interact, and why their combination causes a FieldError with a custom manager. An automated system could reasonably find the problematic pattern (only('pk') on an m2m queryset) from the stack-trace in the problem description, grep for it in the source, and try adding select_related(), making the task moderately complex but still achievable. No new algorithms or deep refactoring are required, but some framework-specific knowledge is essential, pushing complexity above simple typo-level yet not into hard architectural work."
django__django-16950,35,medium,45,"The code change affects a single method in Django’s formset logic, adding a conditional guard that prevents clearing a UUIDField’s default value when saving an inline object. Although only a few lines are modified, understanding why those lines are wrong requires knowledge of how Django inlines propagate key values, how default generators (like uuid.uuid4) work, and the subtle distinction between a model’s primary key and an alternative unique field used by a ForeignKey.

Complexity is moderate (≈35%) because the fix is short and not algorithm-heavy, yet touches a deep, widely-used framework path where side effects must be considered. The patch has to respect existing behaviour for regular primary keys while solving the UUID edge case, so some architectural awareness is needed.

From an AI standpoint, generating this exact fix is challenging. The bug report explains the symptom (UUID becomes NULL) but not the internals causing it. An automated system would have to trace how admin formsets null-out default values and infer the correct safe condition. With no guiding tests, multiple plausible fixes exist (e.g., don’t set to None at all), so hitting the precise maintainer-accepted guard logic is unlikely, yielding a solvability estimate of ~45%.

Overall, the task is medium difficulty: requires domain insight but limited code changes."
django__django-17029,12,easy,92,"The patch modifies a single file with the addition of one straightforward line that invalidates an LRU cache. There is no algorithmic complexity, no cross-module interaction, and no deep architectural change—just ensuring that all relevant caches are cleared, as promised by the method’s docstring. An AI system can infer the correct fix directly from the description (which explicitly states what line to add) or by noticing symmetry with the existing cache_clear call for get_models. Required domain knowledge is minimal: understanding Python’s functools.lru_cache and Django’s app registry. Because the change is trivial, the complexity is very low (≈12%). Given the clarity of the problem statement and the simplicity of the solution space, an automated tool has a high likelihood (≈92%) of generating the correct patch."
django__django-17084,35,medium,55,"The fix touches only one core file and adds roughly 10 lines, so the surface-level change is small. However, it requires understanding how Django decides to push an aggregate into a subquery, knowledge of annotations, window functions, and PostgreSQL’s restriction that aggregates cannot nest window functions. The solution follows an existing pattern (refs_subquery) by introducing a new flag (refs_window) and adding it to the subquery-trigger condition, which is conceptually straightforward once the root cause is known. An AI equipped with context of similar patterns in the codebase could plausibly infer this approach, but it still needs framework-specific insight, making the task more than “easy” yet not deeply algorithmic or architecturally disruptive. Hence complexity is moderate (≈35%), categorised as medium difficulty, and solvability is moderate (≈55%) because the required change is concise and pattern-based but depends on intimate Django ORM internals that may not be obvious from the problem description alone."
django__django-17087,18,easy,85,"The patch changes a single line in one file, replacing __name__ with __qualname__ to correctly serialize nested class methods used as default values in Django migrations. There is no algorithmic complexity, only understanding Python's attributes for qualified names. Domain knowledge required is minimal (knowing the difference between __name__ and __qualname__ and Django's migration serializer logic). Therefore, the change is straightforward (low complexity) and can be recognized by pattern matching once the bug is described. Given the precise problem statement, an automated system has a high probability of producing the fix, yielding a high solvability percentage."
django__django-7530,15,easy,75,"The change is a one-line fix in a single file. It replaces a call that enumerated every model in the project with a call that fetches only the models belonging to the current app. No new algorithms or cross-file interactions are introduced. The main challenge is recognizing the misuse of apps.get_models() and knowing the correct Django API (get_app_config(...).get_models()). Given the clear problem description and the locality of the bug, an AI with moderate knowledge of Django is likely to produce the correct patch, so solvability is high. Overall complexity is low because the fix is small and conceptually simple."
django__django-9296,10,easy,95,"The change affects a single class in one file and consists of adding four lines that directly mirror the snippet provided in the problem statement. No additional algorithms, edge-case handling, or cross-module interactions are involved. The required functionality—iterating over page numbers and yielding Page objects—is conceptually straightforward, requires no special domain knowledge beyond basic Python iteration, and is explicitly spelled out in the description. Because the desired code is almost verbatim in the statement and there are no tests to trick an automated system, an AI could confidently generate the correct patch with minimal context. Hence, the task is low in complexity and highly solvable."
matplotlib__matplotlib-13989,15,easy,80,"The fix consists of a one-line change in a single file: instead of replacing the entire hist_kwargs dictionary (thereby discarding previously set keys such as the user-supplied range), the patch simply adds/updates the 'density' key. There are no algorithmic changes, no cross-file dependencies, and only basic Python dict manipulation is involved, making the technical complexity very low. 

From an AI-generation standpoint, the bug description clearly states that range=... is ignored when density=True and hints that the regression started with a specific commit. Examining the corresponding code shows that hist_kwargs was being overwritten; recognizing that and switching to an in-place update is straightforward. The search space is small and there is little ambiguity, so an automated system equipped with source access and tests is likely to find the fix, leading to a high solvability score."
matplotlib__matplotlib-14623,40,medium,60,"The patch touches three separate modules (2-D axes, 3-D axes, and ticker utilities) but the actual change is conceptually simple: detect if the user supplied limits in reversed order, pass the absolute order through the validation helpers, then restore the requested order to obtain an inverted axis. Roughly twenty lines of code are added/changed and no new algorithms are introduced; only straightforward conditional swapping and removal of a parameter. Some understanding of Matplotlib’s scaling utilities (nonsingular, limit_range_for_scale) and axis-direction logic is required, but there is no heavy mathematical or architectural work. Therefore the task is moderately complex (≈40%). An AI with access only to the bug description would need to trace why log-scale inversion fails, locate the ordering change inside nonsingular, and apply the swap logic consistently across 2-D and 3-D axes. This requires reading and reasoning over the codebase but remains manageable because the fix pattern is repetitive and localized, leading to an estimated 60% likelihood that a capable automated system could generate the correct patch."
matplotlib__matplotlib-20488,25,easy,85,"The patch touches a single function in one file and changes just three lines of logic. No new algorithms or structural changes are introduced; it simply broadens a conditional to include the zero case and assigns a safe epsilon value for LogNorm, preventing a ValueError. The main challenge is recognizing that LogNorm cannot handle vmin <= 0 and that rounding/precision changes in NumPy could push vmin to exactly zero. This requires modest domain knowledge about logarithmic scaling but not in-depth architectural understanding. Given the clear stack trace, the minimal scope, and the straightforward fix, an AI system with access to the failing test and code context has a high probability of generating the correct solution."
matplotlib__matplotlib-20676,25,medium,60,"The bug is caused by initializing the draggable edge handles of an interactive SpanSelector at the hard-coded extents, which default to 0 and therefore force the axes limits to include 0. The fix replaces those hard-coded values with the current axis bounds obtained via get_xbound / get_ybound. Only one file is touched and roughly five lines are changed, so the code modification itself is simple. However, an engineer (or an AI) must understand Matplotlib’s widget lifecycle, the role of ToolLineHandles, and that the initial handle position triggers autoscaling—knowledge that goes beyond pure pattern matching. Because the patch is concise and the root cause can be inferred by inspecting the offending method, a well-tooled AI with access to the codebase could plausibly discover the solution, but the need to reason about interactive behavior and axis autoscaling keeps solvability from being trivial. Hence: low complexity, medium category, and moderate (60%) likelihood an AI could generate the correct fix."
matplotlib__matplotlib-20826,30,medium,60,"The fix touches a single file (axis.py) and consists of a handful of lines that re-establish the correct values of the gridOn flag when an Axis is cleared. No new algorithms are introduced and the structural impact on the codebase is minimal, keeping overall complexity fairly low (≈30%).

However, to know that gridOn was the culprit one must understand Matplotlib’s tick/grid machinery, how shared axes suppress tick labels, and what _reset_major_tick_kw() had been doing. This moves the task beyond pure pattern matching; some internal-API familiarity and reasoning about rcParams are required, so the problem is categorized as “medium”.

From an automated-repair standpoint, the bug is reproducible with a short script and the visual symptom (extra ticks/labels) maps to the gridOn attribute, which is explicitly set from rcParams elsewhere in the library. An AI with access to the codebase and failing tests that detect the presence of unexpected ticks could locate that the attribute is reset incorrectly in clear() and patch it as shown. While not trivial, there is a single, clear point of failure and the fix is concise, giving an estimated 60 % likelihood that an advanced automated system could generate the correct patch."
matplotlib__matplotlib-20859,20,easy,85,"The fix consists of a very small change in a single file: replace a type check against Figure with one against FigureBase and adjust the import and error message accordingly. No algorithms or broader architectural considerations are involved; it’s essentially correcting a class-hierarchy mismatch. The main knowledge required is that SubFigure inherits from FigureBase, which is clearly hinted at in the bug report itself. Given such explicit guidance, an automated system could reliably locate the failing isinstance check after observing the raised TypeError, infer that SubFigure is not being accepted, and substitute FigureBase. Thus, the task is low in complexity and high in solvability."
matplotlib__matplotlib-21568,30,medium,55,"The change touches a single helper function in one file (dates.py) and adds only a few string-replacement rules. Algorithmically it is trivial, but it requires domain knowledge of how TeX math mode treats punctuation (minus signs, colons, and spaces) and how matplotlib’s usetex path builds axis tick labels. Identifying that the visual regression is caused by TeX symbol spacing and knowing the specific fixes ({:} and converting literal spaces to \;) is non-obvious, yet once understood the code change is straightforward. An AI with access to the codebase and regression images could locate _wrap_in_tex via grep and reason about symbol spacing, so the task is achievable but not guaranteed; crafting the exact TeX replacements involves some trial-and-error. Hence moderate complexity and a slightly better-than-even likelihood of automatic generation."
matplotlib__matplotlib-22719,18,easy,88,"The bug manifests as an unwarranted deprecation warning when an empty array is passed through Matplotlib’s category unit converter. The actual fix is a two-line change: guard the deprecation-warning code paths with a size check (`values.size` / `data.size`). No additional algorithms, data structures, or cross-module interactions are involved. Understanding the issue requires minimal domain knowledge (knowing that an empty NumPy array has `size == 0`) and a quick scan of the traceback to see that the warning originates inside the converter. An AI system with access to the problem statement and code base could pattern-match the edge case (empty input) and add the guard with high confidence, leading to a high solvability estimate. Overall, the change is small, localized, and conceptually simple."
matplotlib__matplotlib-22865,35,medium,65,"The patch touches a single function in one file with ~8 new/modified lines, so the code-change surface is small. The logic fix is straightforward: instead of always dropping the first and last divider segments (slice 1:-1), include them when the colorbar is in an ""extend"" state. While this requires knowledge of how Matplotlib encodes extensions (_extend_lower/upper) and how divider segments are built, no complex algorithm or large-scale refactor is involved. An AI that can inspect the original slice and see it conflicts with the expected behaviour described in the bug report could reason to parameterize the slice bounds, so the overall problem is tractable. However, some understanding of Matplotlib’s internal colorbar layout is necessary, and no tests are provided to guide a data-driven system, so solvability is not trivial. Hence medium complexity and a moderate (≈65%) probability that an automated system could generate the correct patch."
matplotlib__matplotlib-22871,30,medium,68,"Only one file is touched and the fix is limited to a handful of lines, so the absolute code change is small. However, understanding exactly why the year disappears demands moderate domain knowledge of Matplotlib’s date tick-formatting internals and the logic behind when an offset string should be shown. The main challenge is to reason about the interaction between the level‐based loop, unique values per level, and the show_offset flag. The solution is conceptually simple (check whether the month list contains January before suppressing the year), but recognising that specific conditional requirement is not purely syntactic; it needs an understanding of the date representation (January == 1) and the formatter’s intended behaviour. Because the problem statement pinpoints the scenario and the fix is localised, an AI with decent reasoning over the code path has a relatively good chance of generating the fix, although it is not trivial pattern matching. Therefore complexity is low-moderate (≈30%), the task is labelled “medium”, and the likelihood an AI can solve it is fairly high (≈68%)."
matplotlib__matplotlib-23299,20,easy,75,"The change touches a single function in one file, modifies only a couple of lines, and updates the docstring. No new algorithms or structural changes are introduced—just preventing the 'backend' key from being restored when leaving rc_context. The bug report itself pin-points that the figure loss happens after leaving rc_context and invoking get_backend; from that, inferring that backend reset is the culprit is straightforward for someone familiar with matplotlib's rcParams. Implementing the fix (copy rcParams then delete the backend entry) is a simple logic adjustment that an AI could reliably generate once it reasons that the backend should stay unchanged. The main challenge is recognizing the side effect of restoring 'backend' on Gcf, which requires moderate but not deep domain insight, hence the high (but not maximal) solvability score."
matplotlib__matplotlib-23314,15,easy,85,"The fix consists of adding a two-line guard clause at the top of Axes3D.draw(): if the artist is marked invisible, return without drawing. Only one file is touched and no existing logic is altered, so algorithmic and architectural complexity are minimal. The required insight is simply that the draw routine should honor the visible flag—knowledge any developer familiar with Matplotlib’s Artist API would have. Because the problem statement explicitly says that set_visible(False) is ignored for 3-D axes and the patch shows the straightforward conditional, an automated system could identify the missing visibility check by pattern-matching against 2-D axes implementations or generic artist behavior. Therefore the task is low in complexity and highly solvable by AI with basic codebase scanning capabilities."
matplotlib__matplotlib-23412,15,easy,65,"The fix consists of a 1-line change in a single file: removing the hard-coded dash offset of 0 that patches were previously forcing and forwarding the user-supplied (offset, pattern) tuple instead. There is no algorithmic work, refactoring, or multi-module impact—just the deletion of special-casing logic. Understanding the bug does require some knowledge of Matplotlib’s dash pattern representation, but once identified, the correction is trivial. An AI supplied only with the problem statement would see that the offset component is ignored and, by grepping for code that zeroes it out, could infer that the override should be removed. Therefore the task is low in complexity and should be moderately easy for automated repair systems to solve, yielding a relatively high solvability score."
matplotlib__matplotlib-23476,30,medium,65,"The bug is isolated to pickling/unpickling of Figure objects where the dpi is affected by HiDPI pixel–ratio adjustments. The actual fix is a three-line change in a single file that resets the value stored in the pickle to the original dpi. No new algorithms or cross-module refactors are needed, but the developer must understand the life-cycle of dpi, the meaning of _original_dpi, and why macOS backends alter dpi on high-resolution screens. This requires moderate domain knowledge of Matplotlib internals yet only small code edits, so overall complexity is low-to-moderate. Given a clear bug report and narrow change surface, an AI with access to the codebase could feasibly identify that the state dict should use _original_dpi, making the task reasonably solvable though not trivial."
matplotlib__matplotlib-24026,30,medium,70,"The change touches a single file and replaces a property-cycle manipulation with a local color iterator. The algorithmic adjustment is straightforward: if a colors list is supplied, create an iterator that cycles through those values; otherwise use the axes line color generator. No deep redesign, data structures, or performance considerations are involved.

Complexity is modest (≈30%) because the developer must understand why set_prop_cycle rejects 'C*' color aliases and how to avoid altering the global axes cycler, but the required code diff is small and localized.

It is classified as ""medium"" since the fix requires some domain knowledge of Matplotlib’s color handling and property cyclers, yet the solution logic is simple once that knowledge is applied.

Solvability is fairly high (≈70%): the exception message in the problem description points directly to set_prop_cycle, and the desired behavior (do not touch the axes cycler, just use the provided colors) is clearly stated. An AI with moderate familiarity with Matplotlib could infer that using itertools.cycle or similar iterator is the correct approach. There is little ambiguity and no extensive integration testing needed, increasing the likelihood an automated system could generate the correct patch."
matplotlib__matplotlib-24149,20,easy,85,"The bug trace clearly points to StopIteration escaping from _safe_first_finite inside _convert_dx. The fix simply adds an additional except StopIteration branch (mirroring existing error-handling) and falls back to the first element. Only one file is touched, with a handful of lines inserted; no new algorithms or architectural changes are involved. While minimal matplotlib internals knowledge helps, following the stacktrace and inspecting the surrounding code is sufficient for an automated system to deduce the missing exception handling. Therefore the technical complexity is low and the task is highly solvable by an AI system once failing tests expose the uncaught StopIteration."
matplotlib__matplotlib-24177,22,medium,55,"The fix consists of a one-line change in a single file: explicitly passing simplify=False to Path.iter_bezier while computing patch limits. Code-wise, this is a very small modification with no algorithmic complexity, so overall technical complexity is low (~22%).

However, arriving at that specific change requires more than trivial pattern matching. One must understand why histograms plotted with histtype='step' get incorrect y-limits: the path representing the step histogram is internally simplified and the simplification removes vertices needed for an accurate bounding-box calculation. Recognizing that the problem lies in the simplify flag of iter_bezier (and not in the histogram routine itself) demands familiarity with Matplotlib’s rendering pipeline and Path utilities, hence the task is not purely ‘easy’ but better classified as ‘medium’.

For an automated system, solvability is moderate (~55%). The problem statement hints that only step histograms are affected and shows that the y-limits are wrong, but it does not directly point to iter_bezier. Without targeted unit tests, an AI would need to trace how histogram patches are added, how axes limits are updated, and notice that simplification drops vertices. This is doable with static analysis and experimentation, yet not straightforward, so the likelihood of an AI generating the exact fix is slightly better than chance but far from certain."
matplotlib__matplotlib-24570,15,easy,70,"The patch touches a single helper function in one file and merely swaps the membership of two string literals in existing if-elif branches. No new logic, data structures, or cross-module interactions are introduced. Understanding that HPacker uses the same vertical orientation semantics as other Matplotlib components and realizing that 'top' and 'bottom' were accidentally swapped is straightforward once the incorrect output is inspected. Therefore the technical complexity is low (≈15%) and the task fits the ""easy"" category.

For an AI, the fix is also fairly attainable: the bug description clearly states that the options are reversed, and the offending code is an obvious if-statement mapping. The solution space is tiny—essentially two possible swaps—so even without exhaustive unit tests an automated repair system could infer the correct change by pattern matching or by running the provided reproduction script and comparing bounding boxes. However, the lack of formal tests and the requirement to understand visual alignment semantics prevents a near-certainty solution, so solvability is estimated at about 70%."
matplotlib__matplotlib-24627,30,medium,70,"The patch touches a single method in one file and adds only a few lines of code. The logic change is straightforward: keep a reference to the children list, clear the Axes’ own list, then iterate over the old list to null-out each child artist’s `axes` and `figure` attributes. No new algorithms, data structures, or cross-module interactions are introduced, so the intrinsic code complexity is low-to-moderate. 

What raises the task above the trivial level is awareness of Matplotlib’s artist/axes relationship and the subtleties of object de-parenting. An implementer must understand that `cla()` should behave consistently with `Artist.remove()` w.r.t. those attributes, and must know where in the code to make the change. This requires reading the Axes clearing logic and noticing that resetting `_children` is not enough. Thus it is more than a pure string replacement but still relatively contained. 

From an automated-repair angle, the symptom is clearly described and the fix is local and deterministic, so an AI with access to the codebase could plausibly synthesize the solution. The absence of an explicit test patch lowers certainty, but the requirements are unambiguous and the change has a single obvious place and pattern. Therefore solvability is fairly high but not guaranteed."
matplotlib__matplotlib-24637,25,medium,60,"The bug fix touches a single method in one file, adding a call to renderer.open_group/close_group around the drawing logic and passing self.get_gid() so the gid is propagated. The code change is only a few lines and contains no algorithmic complexity, keeping overall complexity low. However, it requires knowledge of Matplotlib’s internal rendering workflow—specifically how artist groups are opened and closed and how gids are transferred to backend renderers—so it is more than a trivial pattern-matching change, placing it in the medium category. From the problem statement an AI could infer that the gid is lost during rendering and, by inspecting similar artists in the codebase, discover the missing open_group/close_group pattern, making the task reasonably achievable. Because the scope is tightly limited and the fix follows an established pattern, the likelihood of an AI producing the correct patch is moderate to high, around 60%."
matplotlib__matplotlib-24870,40,medium,65,"The change touches two related modules (cartesian contouring and triangular contouring) but leaves overall architecture intact. Logic added is straightforward: detect boolean dtype and choose specialized default level lists; refactor argument unpacking to pass remaining args and dtype. No advanced algorithms or deep maths, just careful plumbing and dtype inspection. An AI with access to codebase and failing tests/error description could infer need to branch on bool dtype and supply level=.5, but must understand call chains and avoid breaking API, which is moderately challenging. Complexity stems from multiple functions and keeping positional argument handling consistent, but algorithms remain simple. Thus moderate complexity, medium category. Problem statement is clear, expected behaviour well defined; with typical test failing demonstrating wrong defaults, AI could synthesize fix reliably, giving a solvability around two-thirds."
matplotlib__matplotlib-24970,30,medium,75,"Only a single function in one file is modified (~10 lines). The fix consists of moving a dtype cast outside of a conditional block so that unsigned integer arrays get converted to signed ints before sentinel values are assigned. No new algorithms or multi-module interactions are involved, but a correct solution requires understanding NumPy’s deprecation about out-of-bound integer conversions and how Matplotlib’s colormap logic uses negative/large sentinel indices. That demands moderate domain knowledge (NumPy dtypes, errstate context managers) but little architectural knowledge of the rest of Matplotlib. Because the warning message pinpoints the offending lines and suggests casting to another dtype, the required change is clear and localized, making it relatively straightforward for an AI to infer. Hence medium complexity and fairly high solvability."
matplotlib__matplotlib-25122,15,easy,85,"The patch touches a single file and changes only a handful of lines, replacing occurrences of np.abs(window) with window. There is no new algorithm or structural change—just removal of an unnecessary absolute-value operation. The domain knowledge required (understanding that window sums should keep sign for correct power normalization) is minimal and described explicitly in the bug report, including links to the correct SciPy implementation. An AI system can pattern-match the incorrect use of abs(), guided by the failing example in the problem statement, making the task highly solvable. Overall, this is a low-complexity, easy bug fix with a clear and unique solution."
matplotlib__matplotlib-25287,-1,error,-1,Failed to parse response
matplotlib__matplotlib-25311,30,medium,80,"The fix involves a very small code change (removal of one attribute assignment and addition of a property) confined to a single file. There is no algorithmic difficulty, but the developer needs to understand why storing a direct reference to the canvas makes the object un-picklable and how using a property avoids including the canvas in the instance’s __dict__. That requires moderate familiarity with Python pickling mechanics and Matplotlib’s object model, but not deep architectural work. Because the problem statement clearly pinpoints the failure scenario and the traceback reveals the non-picklable FigureCanvas object, an AI could reasonably infer that eliminating the hard reference or replacing it with a weak/derived reference is the correct approach, so the task is highly solvable. However, recognising that a property is the neat solution (versus other options) requires some insight, pushing complexity above the “easy” tier."
matplotlib__matplotlib-25332,30,medium,70,"The change touches a single class in one file (≈15 new lines) and introduces custom __getstate__/__setstate__ methods to translate weak references into strong references during pickling/unpickling. Implementing such a fix is not algorithmically heavy and demands only moderate familiarity with Python’s pickle protocol and weakref module, so overall code complexity is low-to-moderate (≈30%). However, an engineer (or AI) must still trace the pickling failure to the Grouper class used implicitly by align_labels, recognize that weakrefs are unpicklable, and know the correct way to serialize them—knowledge that goes beyond simple pattern matching but doesn’t require deep architectural insight, hence categorized as “medium.” The problem statement is clear, has a concise reproducer, and the root cause is deterministic, so an AI with code-search capabilities and understanding of pickling could plausibly devise this patch; nevertheless, the need to audit the codebase to locate the offending weakrefs and craft proper state conversion makes it non-trivial. Therefore the likelihood an AI produces the correct solution is estimated around 70%."
matplotlib__matplotlib-25479,35,medium,65,"The patch modifies two files with only a handful of lines: it updates the ColormapRegistry.register method to rename the colormap object when it is registered under a different public name, and loosens the Colormap.__eq__ definition by no longer requiring identical names. No new algorithms or data structures are introduced, but the fix demands understanding how matplotlib stores colormap objects, how plt.set_cmap ultimately passes the selected instance around, and why the internal .name attribute matters to subsequent look-ups. Discovering this subtle interplay between registry keys and object attributes requires moderate familiarity with the library, yet the implementation itself is a single assignment and a minor comparison tweak. Therefore the change is of moderate complexity. An AI that can inspect the stack trace and source would likely pinpoint the mismatch and produce a similar fix, but the need for domain reasoning and the absence of explicit tests lowers certainty, resulting in an estimated 65 % solvability."
matplotlib__matplotlib-25775,40,medium,60,"The change spans three files (backend_agg.py, backend_cairo.py, text.py) and adds a new per-artist property (antialiasing) similar to existing color/alpha handling. No new algorithms are introduced; the work is mostly plumbing a boolean flag from Text → draw() → GraphicsContext → backend drawing calls. This requires understanding where text antialiasing was previously hard-coded, modifying those call sites, and exposing getters/setters on both the Text artist and the Cairo graphics context. That is beyond simple pattern replacement but still relatively contained and follows clear design patterns already present in Matplotlib. An AI supplied with the problem description (“Add get/set_antialiased to Text objects … replace rcParams access with GC state”) could likely search for rcParams[""text.antialiased""], replicate existing set/get property patterns, and update the two main backends, giving a moderate chance of success. The absence of provided tests lowers certainty, but the scope is well-defined and the solution is mechanically deducible once the relevant portions of the codebase are located."
matplotlib__matplotlib-25960,40,medium,45,"Although the patch touches only one function and adds roughly fifteen lines, it requires understanding several interacting parts of Matplotlib’s layout system (GridSpec, subfigure transforms, layout engines). The developer had to realise that GridSpec’s wspace/hspace is ignored when the elements stored in the grid are Subfigure objects, then explicitly recompute the bounding boxes and redo the subfigure transform when no constrained-layout engine is present. This demands solid domain knowledge but does not involve a complicated algorithm or multi-file refactor, hence a moderate complexity rating.

For an AI, the problem statement merely says that wspace/hspace in subfigures “do nothing”. Inferring that the issue lies in missing left/right/bottom/top parameters on the GridSpec creation and that an additional manual transform update is needed is non-trivial. With no guiding tests, the search space of possible fixes is large, so the likelihood of automatically arriving at the precise solution is limited, but not impossible if the AI can inspect the surrounding code and notice how regular subplots handle spacing. Therefore the solvability is assessed as below-average but not negligible."
matplotlib__matplotlib-26113,15,easy,90,"The fix consists of a one-character change in a single file, replacing a strict greater-than comparison with a greater-than-or-equal comparison. No new functions, data structures, or cross-module interactions are involved. Understanding the issue only requires recognizing that the intended semantics of the mincnt parameter are inclusive (>=) rather than exclusive (>). The problem statement explicitly points to the offending lines and explains the desired behavior, so an AI system could directly map the requirement to the code alteration. Consequently, the task is low in technical complexity and highly solvable based on the information provided."
matplotlib__matplotlib-26208,20,easy,65,"The fix touches a single file and adds only two straightforward assignments, propagating the existing axis units from the original axis to the twinned one. There are no algorithmic changes, data-structure redesigns, or multi-module interactions—just making sure a property is copied. Hence the technical complexity is low.

For an automated system, the main challenge is locating the root cause (units missing on the secondary axis causes dataLim to go to ±inf). Once identified, the corrective action is trivial. The bug reproduction script in the problem statement is clear and succinct, greatly aiding automated or manual debugging. Although pinpointing the exact attribute responsible (axis units) requires some understanding of Matplotlib’s internals, the small search space and presence of a minimal reproducer make it fairly achievable.

Thus, the change is categorized as “easy,” with low complexity. However, because the underlying cause involves domain-specific knowledge (Matplotlib unit handling) and there are no automated tests provided, an AI repair system might need several iterations or additional heuristic guidance, so solvability is not guaranteed but still above average."
matplotlib__matplotlib-26291,15,easy,85,"The patch touches a single method in one file and adds just two guard lines, turning a None renderer into a valid one by calling the figure’s internal _get_renderer(). No algorithmic work, data structure manipulation, or cross-module coordination is needed. The stack trace in the problem statement clearly pinpoints the failing line and the missing renderer, so an automated system can infer that supplying a renderer when None fixes the issue. Required domain knowledge is minimal—only awareness that a figure can provide its renderer. Because the bug is isolated and the fix is a common pattern, generating the patch is easy and highly likely to be discovered by an AI via pattern matching or minimal code understanding."
matplotlib__matplotlib-26342,15,easy,85,"The patch touches a single file and adds only a couple of very straightforward lines: assigning the new paths list to the instance variable and marking the artist as stale. It also removes a now-redundant override. No algorithms, data structures, or cross-module interactions are involved. The required domain knowledge is minimal—just understanding how Matplotlib artists keep a _paths attribute and a stale flag. Because the change is so localized and the problem statement explicitly describes the desired behaviour (replace existing NotImplementedError with real setter that assigns and sets stale), an automated system can infer the solution with high confidence. Thus the task is low complexity, categorized as easy, and highly solvable by an AI."
matplotlib__matplotlib-26466,20,easy,80,"The bug arises because mutable NumPy arrays supplied to the annotation API are stored by reference; later external mutation propagates to the artist. The fix simply unpacks the array into scalars (or a tuple) at assignment time, thereby copying the values. Only a handful of lines are changed in a single file with no new algorithms, refactoring, or cross-module impact. The required insight—avoid storing a mutable reference—is straightforward for anyone familiar with Python’s object semantics. An AI system given the bug report (which clearly states that a copy should be made) and the offending code (`self.xy = xy`) could reliably infer that a copy is needed and implement the tuple assignment or use `np.copy`; thus the task is highly solvable. Minimal domain knowledge of Matplotlib internals is needed, just general Python mutability rules."
mwaskom__seaborn-3069,35,medium,70,"The patch touches a single file and adds roughly fifteen lines of code, so the raw size is small. However, it requires understanding how seaborn differentiates Nominal (categorical) scales from continuous ones, how axis limits and gridlines are handled in matplotlib, and how seaborn finalizes a figure. Implementing the three behaviors (custom limits, grid suppression, y-axis inversion) is conceptually straightforward but needs knowledge of the correct matplotlib API calls (`axis_obj.grid`, `set_xlim/ylim`, ordering for y). No complex algorithmic work or multi-module refactor is involved, so the overall complexity is moderate (~35%).

From the problem statement, each required behavior is described explicitly, making the task well-defined. An AI with familiarity with matplotlib/seaborn patterns could map those requirements to the API calls used in the patch. Edge cases (e.g., pre-existing user limits) are handled by simple conditionals, not intricate logic. Consequently, while some domain knowledge is necessary, the solution space is narrow and the implementation straightforward, giving a relatively high likelihood (~70%) that an automated system could generate a correct fix, especially with failing tests guiding it."
mwaskom__seaborn-3187,35,medium,65,"The fix touches two files and adds ~15 lines of straightforward defensive code. No new algorithms are introduced; the change simply disables two formatting features (offset and scientific notation) when tick labels are reused inside legends. Implementing this requires familiarity with Matplotlib’s ScalarFormatter API and Seaborn’s legend-building path, but does not demand deep architectural work. The main challenge is diagnosing that the legend relies on the formatter without representing its offset, and knowing which two setter methods to call. Once the cause is identified, the patch is trivial, so the overall technical complexity is moderate (≈35%). Given the clear symptom described in the problem statement, the small scope of the change, and the availability of obvious API calls, an AI system has a reasonable chance (≈65%) of producing the correct fix, but it still needs some domain insight, keeping the task in the “medium” difficulty range."
pallets__flask-5014,12,easy,93,"The change is a straightforward input validation: ensure the 'name' argument passed to Flask Blueprint is not empty. It affects a single constructor in one file and adds only three lines of code with no algorithmic logic or cross-module implications. An AI system only needs to detect that an empty string (or falsy value) should trigger a ValueError, which is explicitly stated in the problem description. There is no need for deep framework knowledge beyond understanding that Blueprint names must be non-empty. Therefore, the task is low-complexity and highly solvable from the clear specification."
psf__requests-1142,18,easy,85,"The patch touches one file and changes only a few lines, adjusting simple conditional logic for when the Content-Length header is added. No new abstractions or cross-module interactions are introduced. The required domain knowledge is basic HTTP semantics (GET/HEAD requests should not send a body by default). Generating the correct fix mainly involves noticing that the unconditional default header is wrong and adding a method check, which is straightforward once the issue is understood. Therefore the change is low in complexity and highly solvable for an automated system given the clear problem statement."
psf__requests-1724,15,easy,85,"The change touches a single file and adds three straightforward lines: it imports builtin_str and casts the incoming HTTP verb to a native str before use. No algorithms or cross-module interactions are introduced. The bug description explicitly calls out that a Unicode method name is the root cause and even points to the line where .upper() is applied, so the required fix (convert to str/bytes before upper-casing) is almost directly stated. Knowledge needed is the basic Python 2 difference between unicode and str, which is common. Therefore the task is simple (low complexity), and an automated system with basic pattern recognition around Unicode issues is highly likely to synthesize the correct patch, leading to a high solvability score."
psf__requests-1766,10,easy,90,"Only one functional change is made: the literal substring 'qop=auth' is replaced with 'qop=""auth""'. No algorithms are modified and no additional files or interfaces are touched. Understanding that RFC 2617 requires quoted qop values is helpful, but the problem description explicitly states this, so minimal domain expertise is needed. An automated system could match the RFC wording or compare with curl’s output and infer the missing quotes; thus the task is highly solvable. The absence of new tests slightly lowers solvability but the change scope is so small and isolated that the correct fix is still straightforward."
psf__requests-1921,12,easy,85,"The bug arises from not fully filtering out headers whose value is None after merging session and request settings. The fix is a one-line comprehension that removes any key where the merged value is None. Only a single file and a few lines are touched, no new logic or algorithm is introduced, and understanding dictionary manipulation in Python is enough. Documentation and the problem statement clearly describe the expected behaviour, so an AI with basic Python knowledge can infer the correct patch quickly. Thus the change is low-complexity ('easy'), yet highly solvable because the scope is small and the desired outcome is explicit."
psf__requests-2317,15,easy,80,"The fix touches a single file and changes only two lines: it swaps out builtin_str for to_native_string and removes the now-unused import. There is no algorithmic work, data-structure change, or cross-module impact. The key insight is recognizing that builtin_str applied to a bytes object in Python 3 yields the literal string “b'…'”, whereas to_native_string properly decodes bytes to text. Discovering to_native_string requires minimal codebase exploration because it already exists in the compat module and is purpose-built for this scenario. Given the clear bug description (Python 3 turns b'GET' into ""b'GET'"" causing 404s) and the obvious behavioural mismatch, an automated system or junior developer could pattern-match the problem and swap in the correct helper. Therefore the task is low complexity (“easy”) and highly solvable, though not 100% since an AI must still locate the appropriate helper and update the import."
psf__requests-2931,15,easy,85,"Only a single file is touched with two small, straightforward changes (removing an unnecessary conversion and adding a safe conversion in a different path). No algorithms are introduced and no cross-module interactions occur. The bug is clearly described—passing binary data fails because `to_native_string` forces a unicode conversion—so the required fix is easy to infer once the offending line is located. An AI system that can search for the call site and understand the type issue could reliably produce this patch, especially with failing tests that exercise a bytes payload. Therefore the change is low-complexity and highly solvable."
psf__requests-5414,10,easy,85,"The fix consists of a single‐line modification in one file, expanding an existing conditional to also catch hosts that start with a dot. No new logic or algorithm is introduced; it is essentially a guard clause extension. Understanding the surrounding code is minimal because the intention is clearly stated in the problem description and the related code is easy to locate (search for the existing InvalidURL check for '*'). An AI system can pattern-match the failure case from the stack trace and reproduction steps, recognize that a leading dot should be treated similarly to a leading asterisk, and modify the startswith condition accordingly. The simplicity of the change, coupled with the clear expected/actual behavior, makes the task highly solvable with limited domain knowledge. Thus, complexity is low and solvability high."
psf__requests-6028,20,easy,60,"The patch touches a single function in one file and adds only four straightforward lines. There is no intricate algorithm or multi-module interaction; it merely re-attaches the user-info component (auth) to the netloc string when rebuilding a URL. Understanding that 407 errors stem from credentials being dropped and knowing how URL parsing separates auth from host is basic HTTP/URL knowledge, so the technical complexity is low. The main challenge is diagnosing that the auth part is lost after parse_url and knowing where in the code this reconstruction occurs, but once located, the fix is trivial. Therefore the task rates as ""easy"" with low complexity. For an AI, discovering the exact location still requires some codebase search and reasoning about URL components, so solvability is moderate rather than extremely high, yielding roughly a 60% chance."
pydata__xarray-2905,20,easy,85,"The patch touches a single file and only replaces one generic coercion statement with a conditional that limits the coercion to specific pandas types. No new algorithms or data structures are introduced; the change is essentially a guard clause. While a small amount of domain knowledge (understanding that many arbitrary Python objects expose a .values attribute and that only pandas objects should be coerced) is required, this is clearly described in the problem statement itself. Because the bug source line is explicitly pointed out and the desired behavior is easy to infer, an AI system has a high likelihood of producing the correct fix once it recognizes the need to restrict the coercion. Therefore, the change is low-complexity, falls into the ""easy"" category, and has a high probability of being solvable automatically."
pydata__xarray-3095,35,medium,70,"The change touches two core files (indexing.py and variable.py) and introduces roughly 30 lines of new or modified code. No new algorithms are added; instead, the fix revolves around correctly delegating deep/shallow copy semantics for a custom wrapper class (PandasIndexAdapter) so that NumPy unicode dtypes are preserved instead of being cast to object. 

Complexity is moderate because the developer must understand how xarray wraps pandas.Index objects, how dtype information is propagated, and why a naive use of array.copy(deep=True/False) alters dtype. Yet the actual implementation is straightforward: define a copy method that respects the deep flag and update the variable-level copy routine to use it. There is no intricate algorithmic logic, concurrency, or large-scale refactor involved.

An AI with access to the problem statement could infer that the issue lies in the missing copy method on PandasIndexAdapter and that unicode dtypes must be preserved. The required fix is localized, and the behavior can be verified with the simple reproduction snippet in the description. However, crafting the exact solution does demand awareness of pandas’ deep copy semantics and xarray’s internal adapter pattern, so solvability is not trivial but still well within reach, hence 70%."
pydata__xarray-3151,25,easy,70,"The fix touches a single file and replaces iteration over all dataset dimensions with iteration over only the concatenation dimensions. No new algorithms or data structures are introduced—just a narrower validation scope. Understanding the distinction between `concatenated.dims` and `concat_dims` requires some knowledge of xarray’s combine logic, but this is straightforward once the bug (erroneous monotonicity check) is identified. Because the required change is small and localized, an AI that parses the error message in the problem statement and reads surrounding code could likely infer the correct loop variable, giving a fairly high solvability estimate. The task is therefore low-complexity and falls in the “easy” category, though not trivial enough for a near-automatic pattern replacement."
pydata__xarray-3305,35,medium,70,"The fix touches two core files (dataset.py and variable.py) and introduces a new optional argument that must flow through the call-chain. Although this requires understanding of xarray’s attribute-handling convention (use of _get_keep_attrs) and the relationship between Dataset/Variable methods, no new algorithms or heavy refactoring are involved—just parameter plumbing and conditional copying of attrs. An AI with access to the codebase could locate the bug by searching for keep_attrs in quantile implementations, notice it is ignored at the Variable level, and add the necessary logic. The change set is small (~30 lines) and conceptually straightforward, yielding moderate complexity. Because the problem statement is explicit, the scope is narrow, and the implementation pattern already exists in other reduction methods, the task is quite achievable, though it still needs some domain awareness of xarray’s internal helpers and attribute policy."
pydata__xarray-3677,20,easy,85,"The bug manifests when Dataset.merge() receives a DataArray instead of another Dataset, leading to an AttributeError inside generic merge code that expects .items(). The fix is a single-line guard that converts a DataArray to a Dataset before delegating to the existing merge routine. Only one file is touched and no new algorithms or broad refactoring are required; the solution relies on recognizing the appropriate helper method (to_dataset). Because the stack-trace clearly pinpoints that a DataArray lacks .items(), an engineer or an AI can deduce the need to coerce the type, making the task straightforward. Thus the change is low-complexity (≈20%), falls in the ""easy"" category, and is highly solvable (≈85%) given the explicit error and minimal code surface affected."
pydata__xarray-3993,15,easy,90,"The patch touches only two files and roughly a few dozen lines. No new algorithms are introduced; the change is largely API housekeeping—renaming a parameter from `dim` to `coord`, adding a deprecation path, input validation, and updated docstrings. All functional logic is a thin wrapper that forwards to existing functionality. The biggest technical step is emitting a `FutureWarning` when the old parameter is used, which is straightforward. Therefore, the task demands minimal domain knowledge (understanding xarray’s coordinate vs. dimension distinction) and virtually no algorithmic complexity. With a clear problem statement that explicitly says what is wrong and what the fix should be, an AI system has a high likelihood of producing the correct patch."
pydata__xarray-4075,20,easy,85,"The bug is localized to a single function call where a boolean weight array is used in a dot-product; NumPy’s behavior of returning a boolean result instead of an integer causes the weighted sum to be wrong. Fixing it only requires detecting a boolean dtype and casting to int before the reduction. The patch touches one file and adds ~7 lines, no new algorithms or cross-module interactions. Understanding NumPy’s bool arithmetic is basic numerical-Python knowledge and the change is logically straightforward. Because the problem statement includes a minimal reproducer, a clear explanation of the root cause, and even hints at the necessary cast, an AI system could reliably generate the correct conditional dtype check. Therefore the task is low in complexity and highly solvable."
pydata__xarray-4094,12,easy,78,"Only one file and a single line are modified: an extra keyword argument (drop=True) is passed to the sel() call before squeezing. No algorithms or data structures are introduced, and the fix is a straightforward parameter tweak to remove the now-superfluous coordinate that caused a merge conflict. Understanding the need for drop=True requires moderate familiarity with xarray’s selection semantics, but the bug report explicitly points to a MergeError after stacking/unstacking, making it clear that an unwanted coordinate remains. An AI with access to the code and the failing example could identify that dropping the coordinate resolves the conflict, so the task is largely pattern-based and highly solvable despite the small amount of domain knowledge required."
pydata__xarray-4356,15,easy,95,"The fix touches a single function in one file, removing a small guard clause and adjusting the calculation of the null-mask with a one-line change. No new algorithm or deep architectural knowledge is required—just replacing direct indexing with a product over selected axes and eliminating an unnecessary error. The problem statement even points to the exact line and suggests the replacement expression, so an automated system or a developer with minimal context could implement it reliably. Therefore the change is low in complexity and highly solvable."
pydata__xarray-4629,10,easy,95,"The bug arises because the ""override"" branch returns the original attrs dictionary by reference instead of a copy, causing later mutations to affect the source dataset. Fixing it only requires wrapping the dictionary in dict() to create a shallow copy. The patch touches a single line in one file with no algorithmic complexity or cross-module interactions, so technical complexity is minimal (≈10%). The problem statement explicitly pinpoints the faulty line and even suggests the exact replacement, making it straightforward for an AI system to synthesize the correct change; test coverage would be trivial to add. Hence the task is categorized as ""easy"" with a very high solvability likelihood (≈95%)."
pydata__xarray-4687,35,medium,65,"The change is localized to a single function in one file (~15 new lines). It extends the public API with an optional keep_attrs parameter and forwards that option to the existing apply_ufunc machinery. No new algorithm or data structure is introduced, but some knowledge of xarray conventions (_get_keep_attrs, attribute–propagation semantics, default behaviour matching DataArray.where) is required. The patch mainly consists of modifying the function signature, setting appropriate defaults, and passing the flag downstream. An AI with access to the codebase and issue description could infer that attribute loss is caused by keep_attrs defaulting to False in apply_ufunc and would identify forwarding keep_attrs as the fix. This requires understanding of xarray internals but no complex logic; thus moderate complexity and reasonable solvability."
pydata__xarray-4695,15,easy,80,"The bug arises because a dimension called ""method"" is forwarded as a keyword argument to DataArray.sel, colliding with sel's own ""method"" parameter that controls interpolation. The fix is a one-line change: stop unpacking the user-supplied dict as **kwargs and instead pass it positionally, so dimension names are treated purely as labels. Only one file and one line are modified, with no algorithmic changes or cross-module implications, making the task simple (≈15% complexity).

An AI system that reads the error message, inspects sel’s signature, and notices the **key expansion could deduce the conflict and the required adjustment with modest codebase understanding. The clear stack trace and a targeted failing example give strong hints, raising the likelihood that an automated repair tool could synthesize the patch (≈80% solvability). Some xarray/pandas API knowledge is helpful but not deep architectural insight, so the task is classified as ""easy."""
pydata__xarray-4966,35,medium,70,"The fix touches a single module and inserts ~8 lines that mirror existing logic for the inverse case (_Unsigned == ""false""). No new abstractions or multi-file interactions are introduced, so algorithmic complexity is low. However, a developer must understand NumPy dtype kinds, the CF/NetCDF unsigned convention, and the surrounding lazy evaluation utilities in xarray to implement it correctly, which elevates the task above a trivial patch. Requirements are clearly articulated in the issue description and the existing code for the unsigned-to-signed path serves as a template, making the solution discoverable for an AI. Tests are absent in the snippet but the behavioral difference is unambiguous, so an AI with context could reasonably synthesize the change. Hence moderate complexity (35%), medium difficulty, and a reasonably high likelihood (70%) that an AI could generate the correct patch."
pydata__xarray-6461,12,easy,85,"Only one file is modified and the patch is a single-line change that replaces an incorrect lambda. The failure is a straightforward IndexError caused by assuming the presence of a second element in the attrs list when the second where argument is a scalar. Fixing it simply requires returning an empty dict or the scalar’s attrs if they exist, which is accomplished with `getattr(x, ""attrs"", {})`. No algorithmic changes, data-structure redesigns, or multi-module interactions are involved. An AI system can directly infer the cause from the stack trace and implement the guard with basic Python knowledge, leading to a high likelihood of automated repair success."
pydata__xarray-6599,20,easy,80,"The bug affects a single helper function that converts coordinates to a numeric dtype before polynomial evaluation. Originally both datetime64 ('M') and timedelta64 ('m') dtypes were treated the same, sending timedeltas through a datetime-specific conversion routine and producing huge numbers. The fix simply distinguishes the two NumPy dtype kinds and handles timedeltas with a straightforward astype(float). Only one file and a handful of lines are modified; no new algorithm or cross-module refactor is needed. Understanding NumPy dtype kind codes and basic xarray data handling is sufficient, so the conceptual complexity is low. Given the clear symptom, localized cause, and obvious conditional split, an automated system with access to the codebase and failing example has a high likelihood of producing the correct patch."
pydata__xarray-6721,15,easy,80,"The bug is localized to a single place: calling v.data triggered eager loading. The fix simply switches from v.data (a property that converts to NumPy and therefore loads data) to v._data (the stored backend array wrapper). Only one line in one file is changed; no algorithmic changes or cross-module impacts, so complexity is low. The stack trace and problem description clearly show that the issue arises inside hasattr(v.data, ""chunks""), so an automated system that searches for lazy-loading violations could infer the change. Domain knowledge of xarray’s Variable internals (difference between .data and ._data) is helpful but not deep. Therefore the task is easy, and the likelihood that an AI could generate the fix is quite high, though not guaranteed, leading to an 80% solvability estimate."
pydata__xarray-6744,35,medium,70,"The patch touches a single method in one file and adds roughly a dozen lines that adjust start/stop indices when the rolling window is centred. The logic is a modest arithmetic correction (compute offset = (window+1)//2 when centre=True, shift the stops array, update starts, and cap starts for the initial incomplete windows). No architectural refactor or multi-file coordination is required, but the author must understand xarray’s rolling-window semantics, off-by-one issues for odd/even window sizes, and NumPy indexing. That demands some domain familiarity yet remains straightforward once the bug is reproduced. For an AI, deriving this fix from the description is feasible because the symptom (“center kwarg ignored”) clearly points to missing offset logic in the iterator. However, exact index calculations and edge handling still demand careful reasoning, so success is not guaranteed. Hence the task is of medium difficulty, moderately complex (~35%), with an estimated 70% likelihood that an automated system could generate an acceptable patch given adequate testing."
pydata__xarray-6938,35,medium,55,"The change spans two core modules of xarray (dataset.py and variable.py) but only touches ~20 lines. No new algorithms are introduced; the fix consists of ensuring that swap_dims works on copies of Variable/IndexVariable objects instead of mutating the originals. This requires understanding shared-object aliasing inside the Dataset container and minor adjustments to helper methods (to_index_variable, to_base_variable). While the code itself is straightforward, identifying that the root cause is the aliasing returned by to_index_variable demands moderate knowledge of xarray’s variable model and immutability guarantees. An AI with failing tests that detect the unintended in-place mutation could infer that a defensive copy is needed, but choosing the correct place (to_index_variable and swap_dims) is less obvious. Therefore the task is of medium difficulty, with moderate complexity and an estimated 55 % likelihood that an automated system could discover and implement the precise fix."
pydata__xarray-6992,65,hard,30,"The fix touches multiple non-trivial parts of Xarray’s internals (Dataset.set_index, Dataset.reset_index, PandasMultiIndex.keep_levels).  ~110 net lines are added/edited across two core modules, introducing new data-flow (tracking drop_indexes/variables, re-adding base variables, special-casing MultiIndex level removal, preserving coordinate order).  Correctness depends on intimate knowledge of the private invariants between _variables, _coord_names, and the xindexes subsystem and on subtleties of Pandas’ MultiIndex behaviour.  No simple pattern matching can derive these changes; they require reasoning about several edge cases (append vs replace, dropping vs converting coords, single-level MultiIndex collapse, etc.).  Although the bug is reproducible from the given MVCE, the precise adjustments necessary are spread over several call paths and demand deep domain expertise.  Consequently the task rates high in complexity (“hard”) and an AI presented only with the problem statement and failing tests would have a low (~30%) probability of synthesising the full, correct patch."
pydata__xarray-7229,35,medium,60,"The bug fix touches only one file and adds roughly two dozen lines, so the change set is not large. However, the logic concerns xarray’s nuanced attribute-propagation rules for Dataset, DataArray, Variable and coordinate objects when `where` is called with `keep_attrs=True`. Correctly reproducing the intended behaviour requires familiarity with how `apply_ufunc` treats the `keep_attrs` flag, how datasets can be promoted/demoted inside the operation, and how global, variable and coordinate attributes should be handled in each case. This demands moderate domain knowledge but no complex algorithms or refactoring. Given a clear failing test that checks coordinate attributes, an AI could feasibly arrive at a solution by removing the earlier lambda override and then manually copying attributes from the original argument to the result, as done here. Several edge cases (e.g. promotion of a DataArray to a Dataset) still need to be covered, so some reasoning beyond simple pattern matching is required. Therefore the task sits in the middle range for both complexity and solvability."
pydata__xarray-7233,18,easy,80,"The change touches a single file and only alters the computation of one local variable. It replaces an intersection with a union to ensure all original coordinates remain coordinates after the construct operation. No new algorithms are introduced; it is a straightforward logic adjustment (set union). Understanding xarray’s coordinate semantics is useful but not deep domain knowledge. Given the clear problem description and minimal code context needed, an AI system has a high likelihood of deducing that all original coordinates should be preserved and implementing the small one-line fix. Therefore the complexity is low, the task is categorized as easy, and the solvability probability is high."
pydata__xarray-7393,30,medium,80,"The change is confined to a single method in one file (5 new/modified lines) and addresses a clear bug: when converting a stacked (MultiIndex) coordinate to a NumPy array, the dtype argument that NumPy passes into __array__ was being ignored, causing automatic up-casting from int32 to int64. The fix simply forwards the requested dtype to np.asarray. 

Complexity is moderate because it does require understanding how NumPy’s __array__ protocol, pandas’ MultiIndex level extraction, and xarray’s indexing layer interact, but no algorithmic work or large refactor is involved. 

Given the explicit minimal reproducible example in the issue, the root cause (dtype lost) is relatively easy to infer, and the patch is a small, localized change; an AI system with access to the codebase and failing tests would have a good chance of producing this fix. Therefore solvability is high. The problem is not entirely trivial (needs knowledge of dtype propagation and pandas/xarray internals), so the category is “medium,” not “easy.”"
pylint-dev__pylint-4551,60,hard,35,"The patch spans four modules (diagrams, inspector, utils, writer) and adds ~120 lines that introduce new helper functions, extend existing visitor logic, and modify the graph-generation layer. Implementing this fix requires (1) understanding astroid’s internal AST representation, (2) correctly associating annotations coming from either AnnAssign nodes or function‐parameter annotations with class attributes and method signatures, (3) integrating this information into both the type-inference path and the DOT writer, and (4) handling Optional[] when the default value is None. These tasks are intertwined and touch several phases of pyreverse’s pipeline, making the change more than a straightforward bug fix. Although no sophisticated algorithm is needed, the developer must know how astroid inference works and how pyreverse builds UML labels, which raises the conceptual complexity. An AI could deduce the need to propagate annotations, but orchestrating the details across multiple files without explicit, failing tests is challenging, hence a relatively low solvability score."
pylint-dev__pylint-4604,30,medium,55,"The patch touches two files with only a handful of added lines. The actual fix is conceptually straightforward: when a type annotation is an Attribute node (e.g. abc.ABC), recursively record the underlying expression so the import is considered used. Implementing this requires understanding how pylint tracks names referenced from type annotations and knowing the relevant Astroid node classes, but no new algorithm or large-scale refactor is involved. An AI equipped with code-search over the repository and the failing example could likely locate _store_type_annotation_node and infer that Attribute nodes were missing from the handled cases. However, pinpointing this exact helper and introducing the recursive call still demands moderate familiarity with pylint’s internals, so the task is neither trivial nor extremely difficult. Hence complexity is moderate (≈30%), category is ""medium"", and solvability by an automated system is estimated a bit better than even (≈55%)."
pylint-dev__pylint-4661,20,easy,70,"The fix touches only two files and adds fewer than 20 lines of code. No new algorithms are introduced; the change simply replaces a hard-coded home-directory path with the value returned by appdirs.user_cache_dir and updates packaging metadata. Understanding the existing code path requires minimal domain expertise—just knowing where pylint currently stores its cache and how the XDG spec expects it to be stored. The main technical step is to choose a library (appdirs) and wire it in. Because the problem statement explicitly says to move the directory in accordance with the XDG Base Directory Specification, the solution approach (use appdirs or replicate its logic) is straightforward and highly discoverable. An AI supplied with the statement and access to the codebase would likely infer this small refactor and dependency addition successfully, making the task highly solvable. However, some extra lines (dependency list, mypy ignore) require awareness of the project’s build configuration, so solvability is not near 100%."
pylint-dev__pylint-4970,10,easy,90,"The fix consists of adding a two-line guard clause in a single method: if min_lines is 0, immediately return so no similarity computation happens. There are no cross-file interactions, no algorithmic changes, and no need to understand pylint internals beyond recognizing that setting the threshold to zero should disable the check. An AI can pattern-match the requirement ('0 means disabled') and implement an early exit. The search space for possible solutions is tiny and the change is safe and isolated, yielding a high likelihood of automatic generation. Consequently, the task is simple (≈10% complexity), falls in the ""easy"" category, and has a high solvability probability (~90%)."
pylint-dev__pylint-6386,35,medium,65,"The fix touches five files but the actual changes are small and mechanically similar: add a new ""metavar"" attribute to the internal argument wrapper, thread that field through the helper functions, register the short flag ""-v"" in two lookup places, and make the preprocessing routine accept single-dash options. No new algorithm is introduced and no deep refactor is needed, but the developer must navigate several layers of Pylint's custom CLI-parsing abstraction and know how argparse treats flags without arguments (using an empty metavar). That requires moderate understanding of the codebase but not expert-level insight. The problem statement clearly explains the bug and expected behaviour, so an AI with access to the code could localise the issue by grepping for ""--verbose"" and noticing the absence of ""-v"" and the metavar handling. Therefore the task is of medium difficulty with a better-than-even chance (≈65 %) that an automated system could synthesize the correct patch, yet complexity is above trivial thanks to the need to modify several interconnected utility layers."
pylint-dev__pylint-6528,35,medium,60,"The fix touches two source files and introduces ~20 new lines that refactor existing ignore-logic into a helper and reuse it while discovering files during recursive walking. No new algorithms are introduced; the change is a targeted bug fix that requires understanding where directory traversal occurs and ensuring the same ignore rules are applied. This demands familiarity with the project’s flow but not deep architectural refactoring, making the overall complexity moderate.

From an automated-repair standpoint, the requirements are explicit: ignored paths must be skipped in recursive mode. The implementation path (factor out ignore check and call it in the walker) is straightforward and there are few edge cases. Given clear symptoms and the localized nature of the bug, an AI system with code-search and pattern-based reasoning could plausibly derive a similar patch, although identifying the second location (_discover_files) that also needed the check adds some difficulty. Hence the solvability is rated at 60%—achievable but not trivial."
pylint-dev__pylint-6903,15,easy,90,"The change touches a single file and adds a simple guard that sets the computed CPU count to 1 when the previous calculation produced 0. There are no algorithmic or architectural implications, and no interactions with other modules need to be considered. The problem statement explicitly points out the erroneous line and even suggests the exact form of the fix (""append an `or 1`""). Hence, generating the correct patch mainly requires recognizing the edge-case (CPU fraction <1) and ensuring the value passed to multiprocessing is at least 1. Minimal domain knowledge about cgroups and multiprocessing is helpful but not strictly necessary. Given the clarity of the problem description and the straightforward nature of the solution, an AI system has a high likelihood of producing the correct patch."
pylint-dev__pylint-7080,15,easy,70,"Only a single line is added in one file. The fix merely normalises the file path before it is compared against the ignore-patterns list, eliminating Windows/Unix separator mismatches. No new algorithms, data structures, or cross-module interactions are introduced. An AI given the bug report (showing Windows paths not matching regexes with forward slashes) can reasonably deduce that path normalisation is required, making the task highly solvable. The change is simple pattern-matching logic rather than deep architectural work, so complexity is low and the category is marked ""easy""."
pylint-dev__pylint-7277,15,easy,85,"Only a single module is touched and the change consists of adding a basic conditional check before popping the first element of sys.path. No new abstractions or algorithms are introduced—just a guard clause comparing against three literal/obvious values ("""", ""."", current working directory). An AI can directly infer this from the bug description, which explicitly says to check these three cases. Hence the task is straightforward (low complexity) and highly solvable. The main challenge is merely knowing that sys.path[0] can legitimately be any of those three values when Python is executed normally; this is general Python knowledge, not deep domain expertise."
pylint-dev__pylint-8898,40,medium,75,"The change spans three files with ~30 new lines of logic centred on a new helper that tokenises a comma-separated list while ignoring commas that appear inside {...} quantifier blocks. The algorithm is linear, uses a simple state flag, and does not require deep architectural changes, but it is more than a one-line fix, hence moderate complexity (≈40%).

Key challenges include recognising that the naïve split must be replaced, realising that only commas at the top level should delimit items, and implementing a small state machine to track brace depth. This requires understanding of regular-expression syntax and the existing utility layer, but does not demand advanced algorithms or full project knowledge, so the task is categorised as ""medium"".

Given a clear bug description that pinpoints the root cause (commas inside quantifiers) and an obvious direction for the remedy (custom splitting logic or escape mechanism), an AI with access to failing tests could likely derive a correct solution after a few iterations. The required domain knowledge (regex quantifiers) is common, and the patch is self-contained, making the solvability fairly high (≈75%)."
pytest-dev__pytest-10051,30,medium,85,"The patch affects a single file with only a handful of lines. The fix involves recognizing that replacing a list object breaks existing references, whereas mutating the same list preserves them. The solution introduces a new clear() method that performs an in-place .clear() instead of reassigning, and updates the caller accordingly. While small, it requires understanding Python’s reference semantics and Pytest’s logging capture flow, which is slightly beyond trivial string or constant changes. The problem statement is explicit, includes a repro, and precisely points to the offending lines, so an automated system with code insight has a high chance of generating the correct fix. Therefore complexity is moderate (30%), category is ""medium"", and solvability is high (85%)."
pytest-dev__pytest-10081,35,medium,80,"The change touches a single file and modifies only a few lines, so the raw code diff is small. However, it requires awareness of how pytest integrates with unittest, specifically how skip markers on a TestCase class versus on individual test methods are represented internally. The developer needs to know that for pdb sessions pytest postpones tearDown by replacing it with a no-op unless the test is skipped, and must now consider the skip coming from the parent class as well. That demands some domain knowledge of pytest’s collection tree (item.parent) and skip metadata, but no complex algorithmic work. 

Because the failure is deterministic and the problem statement clearly describes the undesired behavior along with a minimal reproducer, an AI with access to the codebase could search for the condition that suppresses tearDown when usepdb is active, realize it only checks the method-level skip, and extend it to also check the class-level skip. This is a simple boolean adjustment, so the likelihood of an automated system generating the correct patch is high. Comprehensive tests are not provided in the prompt, but the bug is narrowly scoped and easy to reproduce manually, further aiding solvability."
pytest-dev__pytest-10356,40,medium,62,"The fix touches only one file and adds roughly 30 lines, so the surface area is limited. However, it must correctly reason about Python’s MRO, differentiate between attributes coming from __dict__ versus getattr, and avoid double-counting when new marks are stored. Those subtleties move the change beyond a trivial patch but still keep it far from a large architectural refactor.

To implement the solution an engineer (or an LLM) must:
1. Understand how pytest stores marks on classes and functions.
2. Realize that simple attribute lookup loses information in multiple-inheritance cases because MRO stops at the first hit.
3. Design logic that walks obj.__mro__, collects each class’s local pytestmark, normalises list vs single entry, and preserves ordering.
4. Ensure store_mark keeps only the marks defined directly on the class to prevent duplication.

All of this requires moderate domain knowledge of pytest internals and Python class mechanics, but no complex algorithmic work. The problem statement is clear about the bug and gives a minimal reproducer, so an AI with knowledge of Python introspection should be able to reach the same solution with a reasonable success rate, though the need to handle edge cases like list vs single mark and duplicate prevention lowers that probability slightly."
pytest-dev__pytest-5262,20,easy,85,"Only one file is touched and just four new lines are added. No new algorithm or deep architectural change is required; the fix is to expose a corrected `mode` property that strips the character `b`. This is essentially a small logic/attribute override once the root cause (external libraries checking for ""b"" in mode) is understood. An AI seeing the stack-trace in the problem statement can infer that EncodedFile must stop advertising binary mode, and implementing a `mode` property that removes `b` is straightforward. Therefore the change is low-complexity, falls in the ""easy"" category, and is highly solvable with clear guidance provided in the description."
pytest-dev__pytest-5631,18,easy,82,"The change affects a single helper function (num_mock_patch_args) in one file and only replaces a list-membership test with identity checks against two sentinel objects. No new algorithms or cross-module refactors are introduced; the logic remains linear and straightforward. The main insight is understanding that `in` triggers equality comparison, which is unsafe for NumPy arrays, while `is` avoids that by checking identity—the subtle bug spelled out clearly in the issue description. An AI system can directly trace the stack-trace lines referenced in the report, see the problematic `p.new in sentinels`, and substitute an `is` comparison, so the likelihood of generating the correct patch is high. Required domain knowledge is limited to Python object identity and how `unittest.mock.DEFAULT` works, which is common knowledge for a language-level model."
pytest-dev__pytest-5787,60,hard,35,"The patch touches only one file but introduces ~140 new lines and removes a comparable amount, replacing ad-hoc serialization logic with two full helper functions that convert complex nested data structures (pytest’s exception representations) to and from JSON.  Correctly handling ExceptionChainRepr requires awareness of pytest’s internal classes, attribute layout, and xdist’s worker-master communication protocol.  While the algorithms themselves are straightforward tree traversals, the developer must know which attributes matter, preserve ordering, and maintain backwards compatibility—knowledge that is non-obvious from the symptom alone.  Therefore the change is moderately complex and categorized as hard.

For an AI starting only from the problem description, the task is difficult: the description states that chained exceptions are lost under xdist, but it does not specify where serialization happens or what shape the data has.  Discovering the right location, understanding the serialization format, and implementing symmetric encode/decode logic for the “chain” field requires non-trivial codebase exploration and domain knowledge.  This makes the chance of automatically producing the exact patch relatively low (~35%), though not impossible because the fix is still mostly mechanical once the correct place is found."
pytest-dev__pytest-5809,10,easy,90,"The fix consists of replacing the lexer parameter from a version-dependent value (""python3""/""python"") to the constant ""text"" in a single place. Only one file and a handful of lines are touched with no algorithmic change or side effects elsewhere. Understanding required is limited to reading the error description and adjusting a hard-coded constant; no deep domain knowledge of pytest internals is necessary. An automated system can accurately infer the change directly from the problem statement, so the task is highly solvable. The small scope and trivial logic place this in the low-complexity, easy category."
pytest-dev__pytest-5840,40,medium,60,"The patch touches two files in pytest’s core configuration/path-handling area, removes an auxiliary helper that lower-cases paths, and replaces it with Path.resolve() to preserve original casing on Windows. Although the logical change is concise (~30 modified lines), it requires understanding how pytest deduplicates and imports conftest modules and how case-insensitive filesystems interact with Python imports. An engineer (or AI) must locate where the lower-casing occurs (unique_path -> normcase) and ensure all call sites are updated while keeping import-deduplication semantics intact. This calls for reasonable knowledge of py.path, pathlib, and Windows path semantics, but no complex algorithms or large-scale refactoring. The problem statement clearly hints at casing being the culprit, helping to narrow the search space, so an automated system with code-analysis capabilities has a fair chance to generate the fix. However, navigating the sizable pytest codebase and confidently adjusting multiple related sites still presents moderate difficulty."
pytest-dev__pytest-6197,45,hard,35,"The fix touches only one file and around 20 lines, so raw code volume is modest, but it involves subtle interactions inside pytest’s core collection machinery (PyobjMixin, Module collector, marker handling). Understanding why __init__.py was unintentionally imported requires knowledge of pytest’s lazy object mounting and marker propagation. The patch refactors the lazy-loading logic, removes a special-case constructor, and changes when own_markers are extended. This is conceptually tricky: the change must preserve all other collection semantics while preventing accidental collection of package __init__ files. Generating such a fix from the external symptom (regression when a failing __init__.py exists) demands insight into pytest’s internal data flow, which an AI system without deep context is unlikely to infer reliably. Therefore the task is of moderate code complexity but high conceptual difficulty, leading to a “hard” rating and a relatively low automatic solvability probability."
pytest-dev__pytest-6202,15,easy,90,"The change removes an unnecessary string replacement that was corrupting test identifiers containing ""..["". The fix touches a single line in one file, involves no algorithmic complexity, and requires only recognizing that the replacement corrupts the output. The problem statement already pinpoints the exact offending line, so locating the change is trivial. Given clear symptoms, explicit file/line references, and a straightforward modification, an AI system would have a high likelihood of generating the correct patch. Overall complexity is low, categorizing the task as easy, with high solvability."
pytest-dev__pytest-7205,12,easy,80,"The change touches a single file with only two added lines: an import and replacement of a plain string format with a saferepr-based format. No new algorithms or structural modifications are introduced; the fix is straightforward once the root cause (str() on bytes triggers BytesWarning with -bb) is understood. The specific remedy—using pytest’s existing saferepr helper—is discoverable through simple code search, so an AI with repository context could likely find and reuse it. The main challenge is recognizing that saferepr is preferred over repr() or decoding, but similar patterns exist elsewhere in the codebase, making the patch largely pattern-based. Hence, low complexity and high solvability."
pytest-dev__pytest-7236,35,medium,60,"Only one file is touched and fewer than 20 lines are changed. The fix consists of extracting a helper that detects the @unittest.skip attribute and re-using it in three strategic spots, plus tightening one condition so tearDown is suppressed for skipped tests when --pdb is active. No new algorithms are introduced, but understanding pytest’s test-collection, fixture-injection, and pdb interaction requires moderate domain knowledge. An AI with access to the bug description, the regression example, and the codebase could likely trace the use of __unittest_skip__ and identify the missing guard, but it still needs familiarity with pytest’s internal flow, so success is not trivial. Hence moderate complexity and a roughly 60 % chance an automated system would synthesize the correct patch."
pytest-dev__pytest-7324,35,medium,60,"The change touches a single file and adds roughly a dozen lines, so the code-volume impact is small. However, the bug involves knowledge of how pytest converts its custom mark-expression language into a Python AST and the fact that, starting with CPython 3.8 debug builds, the compiler asserts if the identifiers 'True', 'False', or 'None' are used as variable names. Fixing it requires recognizing the root cause (illegal identifiers in an AST), devising a safe workaround (prefixing them when building the AST and stripping the prefix when they are looked up), and updating two separate code paths accordingly. This goes beyond a simple typo but does not demand deep architectural changes or complex algorithms. An experienced developer—or an AI with adequate context about Python's AST rules—could reason out the solution given the crash message and the offending code, but it still requires pinpointing where identifiers are created/consumed. Hence the task is of medium difficulty, moderate complexity (~35%), and reasonably solvable by an automated system (~60%) if the problem description and failing assertion are provided."
pytest-dev__pytest-7432,15,easy,85,"The bug is localized to a single conditional statement in one file and is fully described in the problem statement (including a direct hint and the precise undesired/desired behavior). Fixing it only requires changing an `elif` to an independent `if`, a classic control-flow mistake that does not involve complex algorithms or deep architectural knowledge. Because the scope is tiny, the required domain knowledge (understanding how pytest distinguishes skip and xfail in `pytest_runtest_makereport`) is minimal and can be inferred from the description. An automated system armed with the hint and failing test output could readily pattern-match the erroneous `elif`, making the task highly solvable. Therefore the change is low in complexity, falls in the ""easy"" category, and has a high likelihood (≈85%) of being generated correctly by an AI system."
pytest-dev__pytest-7490,40,medium,65,"The change is confined to a single module with roughly a dozen altered lines, so the raw code delta is modest. However, fixing it correctly requires understanding pytest’s hook order (setup → call → report), the semantics of skip/xfail markers, and the interaction between the --runxfail option and dynamically-added markers. The bug’s symptom is simple (xfail added during the test is ignored) but the root cause is subtle: xfail evaluation happened only before the test ran, so any markers added later were lost. The solution involves (1) always caching the xfail evaluation, (2) re-evaluating after the test in case a new marker was added, and (3) simplifying duplicated logic. This demands some internal knowledge of pytest but no complex algorithms or data structures, placing complexity in the lower mid-range. An AI with access to the failing behaviour and code could feasibly find the missing post-call evaluation step, yet it must reason about hook timing and state caching, which is non-trivial but not extremely hard, leading to an estimated 65% solvability."
pytest-dev__pytest-7521,15,easy,70,"Only one file and one line were changed; the fix consists of adding the `newline=""""` argument to the `io.TextIOWrapper` call so carriage-return characters are preserved instead of being translated to newlines. No algorithms or architectural changes are involved—just knowledge that the default `newline=None` enables universal-newline translation in Python. An AI system that inspects the traceback, reads the capture implementation, and knows (or searches) how `TextIOWrapper` handles newlines can infer that disabling translation is necessary, so the task is fairly solvable. The main challenge is recognizing the relation between the missing `\r` and `TextIOWrapper`'s default behavior, which requires moderate familiarity with Python I/O internals, but overall the change is straightforward."
pytest-dev__pytest-7571,20,easy,85,"The bug is isolated to a single fixture method in one file. Fixing it requires recognizing that the handler’s log level, not just individual logger levels, must be saved and restored. The patch adds a new instance variable, stores the original handler level when set_level is called, and restores it in _finalize. No new algorithms or cross-module impacts are involved; only a few lines are changed. An engineer (or an AI) with basic knowledge of Python’s logging module and pytest fixtures can infer the solution directly from the failing behaviour described, so solvability is high. The task is straightforward and largely mechanical, hence low complexity and an “easy” category."
pytest-dev__pytest-7982,12,easy,90,"The fix touches a single line in one file, simply removing the follow_symlinks=False argument so that os.DirEntry.is_dir follows symlinks again. No new logic or algorithm is introduced. Understanding the issue only requires basic knowledge of how os.DirEntry.is_dir behaves with its follow_symlinks parameter and of pytest’s directory collection process. The problem statement directly points out the incorrect argument and instructs that it should be removed, making the correct solution obvious. Because the change scope is minimal and clearly defined, an automated system has a high chance of generating the correct patch. Rich domain expertise or architectural insight is not necessary, keeping complexity low and solvability high."
pytest-dev__pytest-8399,12,easy,88,"The patch only adds a leading underscore to the automatically-generated fixture names in five places across two files. No algorithms or structural changes are involved—just string-literal edits. Required domain knowledge is limited to knowing that pytest hides fixtures whose names start with an underscore. Because the problem statement explicitly points out the regression and the expected fix (""this fixture's name would start with an underscore""), an AI system could directly map the description to the necessary code modifications. Therefore the change is simple (low complexity) and highly solvable given the clear, narrow scope."
scikit-learn__scikit-learn-10297,20,easy,85,"The change is limited to a single file, adds one optional boolean parameter to the RidgeClassifierCV constructor, updates the docstring, and forwards the value to the parent class. No algorithms or deep architectural knowledge are involved; it is essentially plumbing a missing flag already supported by the underlying base class. The problem statement clearly identifies the missing argument and its intended behaviour, so an automated system with codebase context could infer the fix with straightforward pattern matching and minimal reasoning. Hence, low complexity, easy category, and high likelihood of automated solvability."
scikit-learn__scikit-learn-10844,20,easy,85,"The change touches a single file with only a handful of lines modified. It replaces a numerically unstable formula with an algebraically equivalent, overflow-safe expression and ensures 64-bit integer casting. No deep algorithmic redesign or architectural knowledge is required—only awareness of integer overflow and basic algebra. Because the problem statement explicitly describes both the symptom and the proposed fix, an automated system with code-base search ability could confidently generate the patch. Hence the task is low-complexity and highly solvable."
scikit-learn__scikit-learn-10908,15,easy,85,"The patch touches a single method in one file and adds only three straightforward lines that mirror logic already present in another method (transform). No new algorithms or data structures are introduced; the change is a guard that calls an existing helper to initialise a cached attribute when it is missing. Understanding the bug only requires basic familiarity with how CountVectorizer defers vocabulary validation. An AI system can infer the needed fix by comparing behaviour between transform (which works) and get_feature_names (which fails) and noticing that transform calls _validate_vocabulary. The scope is small, constraints are clear, and no complex edge cases are involved, so the likelihood of automated generation of the correct patch is high."
scikit-learn__scikit-learn-11310,20,easy,90,"The change affects a single module with just a few lines added: import time, record start and end timestamps around the refit, store the delta, and update class docstrings. No intricate algorithm, threading, or architectural modification is involved. Understanding the code flow of BaseSearchCV.fit and where refitting happens is straightforward, and timing with time.time() is a common idiom. The problem statement explicitly asks for a new attribute carrying the refit duration, so the required solution is clear and unique. Consequently, an AI with access to the codebase and description could reliably insert these minimal modifications, making solvability high. Overall complexity remains low due to limited scope and minimal dependencies."
scikit-learn__scikit-learn-11578,20,easy,85,"The required change is a one-line modification in a single file, merely forwarding the multi_class parameter when constructing a LogisticRegression object inside a helper. No new algorithm or multi-module interaction is involved. The main challenge is recognizing that the probabilistic scorer internally instantiates a model with default parameters, ignoring the user-supplied option; once seen, the fix is straightforward. Therefore the code complexity is low. Because the bug is localized, the patch is minimal, and the problem statement itself already points to the line needing change, an automated system or AI guided by tests would likely succeed, yielding a high solvability estimate."
scikit-learn__scikit-learn-12585,15,easy,90,"The change touches a single file and adds a straightforward condition (an `isinstance(estimator, type)` check) to an existing `elif` branch. No algorithms are modified and no additional interactions across modules are introduced. The core challenge is recognizing that estimator classes have a `get_params` attribute defined on the class, which causes `clone` to treat them like instances; once this is understood, the fix is obvious. The problem statement clearly describes the failure and even proposes the exact one-line solution, so an automated system or a developer can implement it with minimal effort. Therefore the complexity is low, the task is classified as easy, and the likelihood that an AI could generate the correct patch is very high."
scikit-learn__scikit-learn-12682,40,medium,60,"The change spans one core module and an example file, introduces several new keyword arguments, updates doc-strings, and threads the new parameters through a chain of helper functions and public estimators. Although many lines are touched, the edits are largely mechanical (adding default parameters, passing them down, and updating documentation). No new algorithms are implemented and no existing ones are conceptually altered. The main challenge is understanding the call stack of dictionary-learning helpers so that the max_iter value reaches the final Lasso/LassoLars objects, which requires moderate familiarity with scikit-learn’s decomposition utilities, but little deep mathematical knowledge.

From an automated-repair standpoint, the objective (""expose max_iter for Lasso/LassoLars from SparseCoder and related estimators"") is fairly clear, and the solution mostly involves boilerplate propagation of a value. An AI system that can trace parameter flow and modify signatures consistently could likely achieve this, although touching many public APIs (and their unit tests) increases surface area for mistakes. Hence the solvability is above average but not trivial. No complex algorithmic reasoning or intricate refactoring is required, keeping the overall complexity in the moderate range."
scikit-learn__scikit-learn-12973,18,easy,92,"The patch touches a single method in one file, changes fewer than 10 lines, and introduces no new algorithms or dependencies. It simply changes the default value of an argument from True to None, adds a conditional to fall back to the instance attribute, and updates the docstring. The logic is straightforward and requires minimal domain knowledge beyond understanding Python default arguments and class attributes. Because the problem statement explicitly describes both the bug and the desired behavior, and even outlines the solution strategy, an automated system could reliably generate the fix. Therefore, the task has low complexity, falls into the 'easy' category, and is highly solvable by an AI system."
scikit-learn__scikit-learn-13124,30,medium,70,"The fix touches one file with only a couple of lines: it updates the docstring wording and, more importantly, converts the random_state attribute to a RandomState instance with check_random_state before using it. Detecting this requires understanding scikit-learn’s convention that all RNG-related code should operate on a RandomState object; missing that conversion caused shuffling to ignore the seed. While the code change itself is small (hence low complexity), an agent must grasp why passing an int instead of a RandomState breaks the intended behavior, which is beyond mere pattern matching but still well within common library-specific knowledge. Therefore the task rates medium difficulty, around 30 % complexity, and is quite solvable (~70 %) by an AI given the clear bug description and established design patterns in the codebase."
scikit-learn__scikit-learn-13135,20,easy,85,"The fix touches a single file and adds only two straightforward lines: a comment and a call to centers.sort(). The underlying issue—k-means cluster centers are returned in arbitrary order, which breaks np.digitize that expects sorted bin edges—is clearly described in the problem statement. Solving it requires minimal algorithmic change and no deep architectural knowledge beyond recognizing the need for sorting. Because the bug and remedy are explicitly spelled out, an AI system with basic code-understanding capabilities is very likely to generate the correct patch, yielding a high solvability score. Overall complexity remains low due to the small scope and simplicity of the modification."
scikit-learn__scikit-learn-13142,-1,error,-1,Failed to parse response
scikit-learn__scikit-learn-13328,20,easy,85,"The bug is localized: HuberRegressor.fit fails with boolean input because subsequent operations expect numerical arrays. The fix only requires adding the dtype parameter to check_X_y so that boolean arrays are cast to float, matching behaviour of other regressors. This involves a two-line change in a single file with no algorithmic complexity or cross-module impact. Understanding scikit-learn’s validation helper and basic numpy casting is sufficient; no deep domain expertise or architectural knowledge is necessary. Given the clear error trace and analogous behaviour in LinearRegression, an AI system could infer the solution with high probability, hence the high solvability score and low complexity rating."
scikit-learn__scikit-learn-13439,8,easy,95,"The required change is a single, self-contained addition of a __len__ method that simply returns the length of the existing steps attribute. No algorithmic work, no interaction with other modules, and no deep understanding of scikit-learn internals are needed—just awareness that Pipeline stores its elements in self.steps. The problem statement is explicit (len(pipe) should work), so the solution is obvious. Therefore the task is very simple (low complexity), easily solvable by an AI or a human with minimal context, and falls into the 'easy' category."
scikit-learn__scikit-learn-13496,20,easy,90,"Only one source file is touched and fewer than 20 lines are added or modified. No new algorithmic logic is introduced; the change simply exposes an existing feature (warm_start) by adding it to the constructor, forwarding the argument to the superclass, and documenting it in the docstring. Understanding the inheritance hierarchy of BaseBagging is trivial once the developer reads the problem statement, which explicitly describes what to do. Therefore, the task requires minimal domain expertise and no intricate system changes. An AI system could reliably generate this patch because the instructions are explicit, the required edits are mechanical, and there is no need for nuanced reasoning about algorithm correctness. Lack of new tests slightly lowers certainty but does not hinder patch generation."
scikit-learn__scikit-learn-13779,12,easy,90,"The change touches a single file and adds only two lines that perform an early-continue when an estimator is None. No new algorithms or structural changes are introduced; it is a straightforward guard clause to prevent an AttributeError. Understanding the bug requires minimal domain knowledge: realizing that iterating over a list containing None will break when the code assumes every element has a fit method. The problem statement is clear, demonstrates a reproducible error, and points directly to the offending code path. Consequently, an automated system with basic static reasoning could infer that a None check resolves the issue, making the task highly solvable while maintaining very low intrinsic complexity."
scikit-learn__scikit-learn-14053,15,easy,90,"Only one file is touched and the change is a single conditional expression altering how feature names are selected in export_text. The bug arises from attempting to index a user-supplied feature_names list with the sentinel value TREE_UNDEFINED (-2) that marks leaf nodes. Fixing it merely requires mapping that sentinel to None instead of indexing the list. No algorithmic work, no cross-module interaction, and minimal domain knowledge (understanding that ‑2 is a sentinel) are needed. The clear stack trace in the problem statement pinpoints the faulty line, so an automated system can reliably propose the if-else guard. Hence low complexity and high likelihood of AI generation."
scikit-learn__scikit-learn-14087,30,medium,70,"Only a handful of lines in a single file are touched, so the code-change scope is limited. The bug is an incorrect array indexing pattern that surfaces only when refit=False (the cross-validation path). Fixing it needs familiarity with the 4-D shape of coef_paths in LogisticRegressionCV and with how folds and parameter grids are laid out, but does not require redesigning algorithms or interacting with other modules. An engineer (or an AI that can run the failing example) can quickly reproduce the IndexError, inspect the offending indexing (fold and parameter axes swapped), and patch it. Additional small logic is added to skip l1_ratio handling when the penalty is not elastic-net. Because the failure is deterministic and the correction localized, the task is reasonably approachable, but still demands understanding of numpy broadcasting and the estimator’s internal data layout—hence a “medium” rating with moderate complexity and a ~70 % likelihood that an automated system could infer and generate the correct fix from a failing test."
scikit-learn__scikit-learn-14141,5,easy,90,"The change involves adding a single literal (""joblib"") to an existing list of dependency names. No additional logic, cross-file interactions, or algorithmic considerations are required. Understanding the fix only demands recognizing that show_versions should include joblib, which is clearly stated in the problem description. Therefore, the task is trivial in scope and implementation. An automated system or simple pattern-matching rule could readily insert the missing dependency, leading to a very high likelihood of successful generation. The absence of a test patch slightly reduces solvability (there is no immediate automated signal of success), but the requirement is unambiguous and isolated, keeping the probability of correct AI output high."
scikit-learn__scikit-learn-14496,18,easy,87,"The bug is localized: when min_samples is given as a float (fraction), the code multiplies by n_samples but forgets to cast to int, causing a downstream TypeError. Fixing it only requires wrapping the result with int() in two locations and adjusting docstrings. Only one file is touched and no algorithmic changes are introduced. Understanding the fix mainly involves basic Python typing and knowledge of how OPTICS parameters propagate to NearestNeighbors, which is straightforward. Therefore the change is simple, with low code churn, and can be readily inferred from the stack trace in the problem statement. An automated system could detect that min_samples must be an integer and add the cast, making the task highly solvable."
scikit-learn__scikit-learn-14629,30,medium,70,"The bug arises because cross_val_predict expects every classifier to expose a classes_ attribute, but MultiOutputClassifier did not. The fix simply adds an overridden fit method that, after fitting each sub-estimator, collects their individual classes_ lists and stores them in self.classes_. Only one file is touched and around 25 lines are inserted, with no new algorithms or structural refactors, so code complexity is low-to-moderate (~30%). Nevertheless, the developer must understand scikit-learn’s estimator API and how cross_val_predict accesses attributes, making it more than a trivial typo fix; hence the ‘medium’ category. For an AI, the problem statement clearly pinpoints the missing attribute and even hints at the needed solution (use estimators_[i].classes_), so generating the correct patch is quite feasible; test coverage would quickly confirm success. Therefore the solvability likelihood is high but not guaranteed (~70%)."
scikit-learn__scikit-learn-14710,30,medium,70,"The patch touches a single internal helper in one file and adds only a few lines, but it requires understanding how HistGradientBoosting encodes targets, when early-stopping scorers are called, and the classifier/regressor distinction. Those concepts are common to developers familiar with scikit-learn but not obvious from syntax alone, so the task is more than a trivial edit yet far from an architectural change. The problem statement clearly pinpoints the failure scenario and even proposes a near-final diff, making the solution fairly straightforward for an AI: identify that encoded integer y must be mapped back to original classes when scoring and guard with is_classifier. Hence the overall complexity is moderate, and the likelihood that an AI could generate the fix is relatively high, though not certain."
scikit-learn__scikit-learn-14894,15,easy,90,"The change touches one file and adds a straightforward guard clause. The bug is a direct ZeroDivisionError due to n_SV being zero, and the fix is simply to handle that special case by returning an empty sparse matrix. No deep algorithmic understanding or architectural impact is required—just a simple conditional check. The problem statement explicitly pinpoints the error location and desired behavior, making it highly solvable for an AI system. Minimal domain knowledge about SVM internals is helpful but not necessary to implement the guard. Hence low complexity, easy category, and high likelihood an AI could generate the correct patch."
scikit-learn__scikit-learn-14983,15,easy,85,"The bug is a missing __repr__ implementation for two cross-validator classes. The fix adds a 3-line __repr__ that proxies to the existing helper and tweaks the helper with two additional lines, all within a single file. No new algorithms or deep architectural knowledge are needed—just awareness of existing utility functions. The change is patterned after other classes in the same module, making it straightforward for an automated system to infer. Given the clear expected/actual outputs in the problem statement and the minimal, isolated code touch, an AI has a high likelihood of generating the correct patch."
scikit-learn__scikit-learn-15100,20,easy,85,"Only one function in a single file is modified with a small change: replace a faulty early-exit condition with a try/except that checks ASCII-compatibility, then always perform NFKD normalization and strip combining characters for non-ASCII input. No new algorithms or architecture are introduced; lines changed are <15. Although some Unicode knowledge is needed, the bug and its fix are clearly described in the problem statement, making it straightforward for an AI to infer that the early return should be based on ASCII compliance, not on the NFKD test. Given the limited scope and explicit description, the task is easy and highly solvable, hence low complexity (20%) and high solvability (85%)."
scikit-learn__scikit-learn-25102,45,medium,35,"The change affects two core modules of scikit-learn. It introduces a new optional parameter (cast_to_ndarray) to the generic _validate_data helper in sklearn/base.py and threads this option through feature_selection/_base.py so that DataFrame inputs keep their original pandas dtypes when the user has configured pandas output. 

Complexity assessment:
• Only two files are touched and fewer than 40 lines are added/modified, but the altered code is in central, widely-used utilities. Any mistake could break many estimators. This raises the conceptual complexity even though the diff is small. 
• No new algorithms are implemented; the work is mainly conditional logic and routing, so algorithmic complexity is moderate. Overall complexity ≈45 %. 

Category:
• The task requires an understanding of scikit-learn’s internal validation pipeline, the set_output API, and how pandas dtypes propagate. That is deeper than ordinary bug fixing but still localized, so “medium” best fits. 

Solvability by an LLM:
• The problem statement explains the desired behaviour but not the exact internal mechanics needed. It suggests modifying _wrap_in_pandas_container, whereas the final patch changes _validate_data and the FeatureSelector mixin—an alternative design choice. 
• Choosing the right integration points (deciding not to cast to ndarray, keeping iloc indexing, using _safe_indexing) requires familiarity with scikit-learn internals that an LLM may not deduce from the description alone. 
• No dedicated tests are provided to guide the repair, reducing feedback for automated trial-and-error. 
• Therefore, while an experienced human could craft the fix, an AI relying only on the description has a low-moderate chance. Estimated solvability ≈35 %."
scikit-learn__scikit-learn-25232,20,easy,85,"Only one file is touched and fewer than 20 lines are added. No new algorithms are introduced; the change simply threads an existing SimpleImputer argument (fill_value) through IterativeImputer’s API and passes it to an internal SimpleImputer instance. This is standard parameter-plumbing with minimal risk of side-effects. The required domain knowledge is limited to knowing that SimpleImputer already handles fill_value, and understanding IterativeImputer’s initialization path—both are straightforward from the docs. Because the problem statement explicitly says to add fill_value and describes its semantics, an AI can map the request directly to the needed code edits. Therefore the task is low-complexity (“easy”) and highly solvable with automated code generation."
scikit-learn__scikit-learn-25747,18,easy,68,"The patch touches a single file and removes only two functional lines plus a minor docstring update. No new logic or algorithm is introduced; the fix simply stops overwriting the index of an already-constructed pandas DataFrame. Understanding that the error stems from a length mismatch when reassigning the index is straightforward once the stack trace is inspected. While some familiarity with scikit-learn’s output wrapping helper is useful, the change is local and does not require deep architectural knowledge. An AI system that parses the exception and follows the code path could deduce that eliminating the index reassignment resolves the issue, making the task reasonably achievable. Therefore, the change is low in complexity, categorized as easy, with a moderately high likelihood that an automated system could generate the correct patch."
scikit-learn__scikit-learn-25931,35,medium,65,"The patch touches a single file with ~15 added/modified lines, so code churn is low. The change, however, requires understanding how IsolationForest.fit internally calls score_samples, how score_samples performs input validation, and why that validation strips feature names and triggers the warning. Crafting the fix therefore needs knowledge of scikit-learn’s validation utilities and the convention of providing a private helper that bypasses validation. No new algorithm is introduced, and the overall control flow remains intact, but domain insight into scikit-learn’s fit/predict pipeline is necessary. An AI system with access to the codebase and the clear bug report could reasonably deduce that a second validation pass is the root cause and introduce a private _score_samples method; thus the task is achievable but not trivial. Hence a moderate complexity (“medium”) and a solvability estimate of roughly two-thirds."
scikit-learn__scikit-learn-25973,35,medium,70,"The change is confined to a single module with roughly a dozen modified lines. The bug stems from treating an iterator of splits as a reusable cv object; once consumed in the first feature-selection iteration, later calls to cross_val_score see an empty list and raise an IndexError. Fixing this only requires validating the user-supplied cv with sklearn.model_selection.check_cv (which turns an iterator or any accepted spec into a fresh, reusable splitter) and then passing that validated object around. No new algorithms or broad refactoring are needed, but some understanding of scikit-learn’s cross-validation utilities and how SequentialFeatureSelector repeatedly evaluates feature subsets is necessary, making it more involved than a simple typo fix. Given the clear error trace, the limited scope of the fix, and the well-documented check_cv helper, an AI with knowledge of scikit-learn’s conventions could plausibly infer the solution, though recognizing iterator exhaustion and the need to reuse splits adds some non-trivial reasoning. Therefore the task is of medium difficulty, with moderate complexity and a fairly high likelihood of successful automated repair."
scikit-learn__scikit-learn-26194,20,easy,85,"Only one function in a single file is touched; fewer than 10 lines are changed and no new logic branches or data structures are introduced. The fix simply replaces the artificial threshold value `max(y_score)+1` with `np.inf` and adjusts accompanying documentation. While understanding ROC semantics helps, the required domain knowledge is minimal and the change is straightforward once the bug is observed. An AI system can locate the offending line via the test that asserts thresholds must stay within [0,1] and deduce that an out-of-range initial value is the cause. Replacing it with an infinite sentinel is a common pattern and easy to implement, so the probability an AI can generate the correct patch is high."
scikit-learn__scikit-learn-26323,30,medium,85,"The patch touches a single method in one file and adds only a few lines: after iterating over the named sub-transformers, it now explicitly calls _safe_set_output on the remainder transformer when it is an estimator. Algorithmically nothing new is introduced; the fix is a conditional followed by an existing helper call.

Complexity is moderate because the developer must understand how ColumnTransformer propagates set_output, what values 'remainder' can take, and how _safe_set_output behaves. Nevertheless, no deep refactoring or algorithmic work is needed, so complexity is around 30% and classified as medium.

The problem description is explicit: it states that set_output ignores the remainder when it is an estimator, shows the line responsible, and provides a minimal reproducible example. From this the logical remedy (apply set_output to the remainder) is straightforward, leading to a high solvability score of roughly 85% for an AI system equipped with the codebase and failing test example."
scikit-learn__scikit-learn-9288,30,medium,60,"The fix touches a single file with only a handful of lines, so code-change volume is small. However, identifying the root cause requires understanding how KMeans initialisations use the RandomState differently when n_jobs==1 versus >1, and recognising that generating an explicit seed list for the sequential path restores determinism. This demands some familiarity with scikit-learn’s parallelisation utilities and random-state handling, but no deep algorithmic rewrite. An AI with access to the codebase and the bug description could plausibly trace the discrepancy and apply the same seed logic to both branches, so solvability is better than even but not trivial. Overall, a moderate-complexity, medium-difficulty bug fix with a reasonable likelihood an automated system could generate the patch."
sphinx-doc__sphinx-10323,-1,error,-1,Failed to parse response
sphinx-doc__sphinx-10435,30,medium,60,"The fix touches a single file and changes only a few lines, so the code-change footprint is small; no new algorithms or data structures are introduced. However, the developer must understand how Sphinx wraps inline code for LaTeX, how Pygments emits Verbatim blocks, and how TeX whitespace rules work. Correctly inserting a trailing % to swallow spaces and adjusting the rstrip slice length (-15 instead of ‑14) are subtle LaTeX details an uninformed developer or rule-based AI might miss. Nevertheless, the problem statement clearly points out that leading/trailing spaces are the issue and shows the desired output, so an AI equipped with context and tests could likely converge on a solution with targeted string manipulation. The task is thus moderately complex (30%) and solvable with a fair probability (60%), warranting a “medium” difficulty rating."
sphinx-doc__sphinx-10449,35,medium,60,"The fix touches a single module (sphinx/ext/autodoc/typehints.py) and adds ~10 lines plus a small refactor for a new flag. No new data structures or algorithms are introduced; the change is predominantly conditional logic that suppresses generation of an rtype field when documenting classes. Implementing it requires understanding the call flow of Sphinx’s type-hint merge logic but not deep algorithmic work. The main challenge is knowing where in the pipeline the annotation list is converted into docutils nodes, which demands some familiarity with the Sphinx autodoc extension. Once located, the correction itself is straightforward (skip adding a 'return' type of None for classes). That puts the task above “easy” but well below “hard.”  Given the clear bug description—including steps to reproduce, expected vs. actual output, and the key configuration parameter—the likelihood that an AI could localize and implement the fix is moderate. The lack of an accompanying test suite reduces guidance, but the scope is small and behaviorally well-defined, yielding an estimated 60 % solvability."
sphinx-doc__sphinx-10466,18,easy,82,"The fix touches a single file and replaces one list-comprehension with a set-comprehension followed by sorting. The algorithmic change is simply deduplication of (source, line) tuples to prevent repeated positions in gettext output. This requires minimal domain knowledge (understanding that a set removes duplicates and sorting gives deterministic order) and no wider architectural impact. The problem description explicitly points to the buggy code and even proposes a nearly identical solution, making the task straightforward for an automated system. Because the change is localized, clear, and only a couple of lines long, overall complexity is low. Given the clarity of the bug report and the simplicity of the patch, an AI system stands a good chance (≈80%) of generating the correct fix with basic reasoning about duplicate removal."
sphinx-doc__sphinx-10614,30,medium,70,"The patch touches a single file and changes only a handful of lines: it removes the hard-coded ""../"" prefix that was prepended to every link when Graphviz produced SVG, and adjusts how the dictionary key is chosen for external references. No new algorithms or data structures are introduced, and the fix is essentially string manipulation.

What adds some complexity is domain knowledge: the developer must understand how Sphinx embeds SVG diagrams (via an <object> tag) and why relative links inside that SVG are resolved relative to the nested page rather than the build root. The contributor also needs to know the difference between internal and intersphinx (external) references and what keys the graphviz URL map expects.

For an automated system, the bug report is clear, gives a minimal reproduction, and explicitly points to the incorrect ""../"" behaviour. A search in the codebase for that prefix in the inheritance_diagram extension quickly reveals the offending lines, and the corrective action (remove the prefix, keep current_filename for refid) is straightforward. Therefore the likelihood that an AI could generate the correct fix is relatively high, though not trivial, yielding a solvability estimate of about 70%."
sphinx-doc__sphinx-10673,58,hard,38,"The fix touches three different subsystems inside Sphinx (directive parsing, toctree resolution during HTML generation, and figure-number collection).  About 50 lines are added/changed across three files, introducing new conditional flows that weave into existing, non-trivial data structures (environment domains, label maps, document trees).  Implementing the solution requires knowing that the special pages genindex/modindex/search are stored only as labels, not as regular documents, and understanding how each build phase handles toctree entries so that warnings are suppressed yet HTML output is still generated correctly.  No complex algorithms are added, but the patch demands intimate domain knowledge of Sphinx internals and the interplay between parsing, environment bookkeeping, and output builders.  An AI given only the warning message and problem description would need to infer several hidden requirements (e.g., figure numbering skips, hidden docs in globbing) and coordinate changes in multiple locations, making correct generation unlikely.  Therefore complexity is moderate-high (58%) and category is ""hard""; solvability for an automated system is correspondingly low-medium (38%)."
sphinx-doc__sphinx-11445,35,medium,65,"The change is limited to a single utility module and touches roughly a dozen lines, so the overall code modification is modest. However, to diagnose the bug one must understand how Sphinx prepends `rst_prolog`, how docinfo lines are detected, and how re-StructuredText field markers differ from interpreted-text roles like `:mod:`. The fix involves replacing an overly-broad handcrafted regex with the canonical `docutils` regex for field markers, which requires specific domain knowledge of the `docutils.parsers.rst.states.Body.patterns` table. An AI that can read the problem statement, grep for the offending regex, and notice that it mistakenly matches `:mod:` lines could reasonably craft this fix, but it still needs awareness of docutils internals or to deduce the correct regex from documentation. Therefore the task is of moderate difficulty (medium) with a complexity of about one-third, and the likelihood that an automated system could derive the correct patch is roughly two-thirds."
sphinx-doc__sphinx-11510,55,hard,35,"The change touches only one file but introduces ~30 lines of nuanced logic that patches Docutils’ StateMachine at runtime. Solving the bug demands understanding of three interacting subsystems: Sphinx events, the Include directive implementation, and Docutils’ parsing pipeline. The fix must 1) intercept the text lines coming from an include, 2) fire the existing ""source-read"" event, 3) accept potential in-place modifications, 4) re-inject the modified lines while preserving Docutils’ sentinel markers, and 5) avoid infinite recursion. Crafting such a wrapper and carefully calling the class-level insert_input requires intimate framework knowledge rather than simple pattern matching. Although the problem statement clearly describes the symptom, it gives no hint about the internal cause, so an AI would need to explore the codebase, reverse-engineer the event flow, and devise a safe monkey-patch—feasible but non-trivial."
sphinx-doc__sphinx-7440,20,easy,85,"The fix touches a single file with only two small changes: it stops lower-casing glossary term identifiers and removes the lowercase flag from the corresponding XRefRole. No new logic or algorithms are introduced; the solution is essentially deleting two occurrences of case-normalization. The problem statement clearly points to the root cause (duplicate glossary entries differing only in case), making it straightforward to reason that the unwanted lower-casing is the culprit. An AI system that scans for where glossary terms are registered or compared could quickly locate the `.lower()` call and the `lowercase=True` parameter, so the likelihood of generating the correct patch is high. Minimal domain knowledge is required beyond understanding that preserving case sensitivity resolves the duplication warning."
sphinx-doc__sphinx-7454,30,medium,80,"The actual code change is very small (one function, ~5 added/modified lines in a single file) and does not involve any intricate algorithmic work. However, correctly fixing the bug requires awareness of Sphinx’s Python-domain cross-reference types (""class"" vs ""obj"") and how autodoc_typehints renders annotations, which goes beyond pure pattern matching. An engineer (or an AI) must trace why the link for `None` is missing, locate the helper that converts annotation strings to xrefs, and realize that `None` must be treated as a plain object constant, not a class. This domain insight bumps the task out of the “easy” bucket into “medium”. Because the problem statement is clear, the scope is tiny, and the fix is essentially a conditional switch on one string, an automated system with modest knowledge of Sphinx internals has a high likelihood of producing the correct patch, hence a solvability estimate of roughly 80%."
sphinx-doc__sphinx-7462,20,easy,85,"The patch touches two files with a total of roughly a dozen added lines and minimal control-flow changes. The bug is a straightforward edge-case: the existing tuple-unparse logic assumes at least one element and performs a final pop(), causing an IndexError on empty tuples. The fix simply checks for the presence of elements and handles the empty case by returning the literal ""()"". No algorithms or deep architectural knowledge are involved; the unparser structure is clear and the stack trace pinpoints the failing line. An AI system only needs to recognize the empty-tuple condition and add a guard, which is a common pattern. Therefore, complexity is low, the task is categorized as easy, and the likelihood of an AI generating the correct patch from the description and error message is high."
sphinx-doc__sphinx-7590,65,hard,35,"The patch spans three modules (cfamily.py, c.py, cpp.py) and introduces new regular expressions, extends existing literal-parsing logic, creates a brand-new ASTUserDefinedLiteral node, alters signature rendering, and adds a new description mode (""udl"").  Supporting C++ user-defined literals requires knowledge of the C++ grammar (distinguishing between numeric/character suffixes and a true UDL, handling word boundaries, float/int suffixes, name lookup rules, ID mangling, etc.) as well as the internal architecture of Sphinx’s C/C++ domain: its tokenizer, recursive-descent parser, AST hierarchy, symbol table, and the HTML rendering pipeline.  The changes must remain compatible with all other literal kinds and not break cross-referencing, so subtle interactions need to be considered.  Although the problem statement is clear (“add UDL support”), the concrete implementation details are not specified; an AI would have to discover where in the parser to hook, craft correct regexes, manage suffix vs UDL ambiguity, modify AST IDs, and update the rendering path—all non-trivial tasks.  Consequently, the task is complex (≈65 %) and falls into the “hard” category.  Because of the open-ended nature, the absence of guiding tests, and the need for deep domain expertise, the likelihood that an AI could autonomously synthesize the exact solution is modest (≈35 %)."
sphinx-doc__sphinx-7748,45,medium,60,"The change is confined to a single file but touches several connected methods that cooperate inside Sphinx’s autodoc extension. Roughly 70 lines are added/modified, introducing new instance variables, altering control flow, handling multiline signatures, and concatenating multiple discovered signatures. The algorithmic work is straightforward looping and string/regex handling—no advanced data structures—but the developer must understand Sphinx’s documenter life-cycle, the existing signature-extraction regex, and how return values propagate to the final rendered signature list. That domain understanding pushes the task above a simple bug-fix but below a large architectural refactor. 

From an AI’s perspective, the requirement (“support all overloaded signatures appearing at the top of the docstring”) is explicit enough to reason about; the surrounding code provides clear hooks (_find_signature, format_signature). However, edge-cases such as backslash-continued lines and ensuring only relevant names are matched add subtlety. Without exhaustive tests an AI might miss those nuances, yet the solution space is limited and boilerplate heavy, so a competent model could reach a correct patch with some probability. Hence the solvability estimate is moderate-high (≈60%), while the overall complexity remains in the middle range."
sphinx-doc__sphinx-7757,40,medium,55,"The patch modifies a single utility file, touching roughly 20 lines to correctly align default values with positional-only parameters introduced in Python 3.8. The logic added is limited in scope but requires understanding of Python’s AST structure, inspect.Parameter kinds, and the way Sphinx builds function signatures. This puts it above trivial fixes but well below large-scale refactors, leading to a moderate complexity score.

Key challenges include: 1) realising that positional-only arguments change the offset between the defaults tuple and the argument list, 2) recreating an explicit list of defaults padded with Parameter.empty to keep indices consistent, and 3) handling both pos-only and regular positional parameters while preserving annotations.

Because the bug report is precise, provides a minimal reproducer, and narrows the issue to signature rendering, an experienced developer (or an AI with code search) can localise the faulty logic quickly. However, crafting the correct index arithmetic and ensuring no regressions demands careful thinking, so the solvability, while better than chance, is not near-certain."
sphinx-doc__sphinx-7889,15,easy,85,"Only one small method needed editing. The bug stemmed from assuming the __getitem__ key is always a string; generic-type parameters can be TypeVar objects, causing string concatenation to fail. Fixing it just required (1) widening the type annotation to Any and (2) converting the key to str before passing it on. No new algorithms or architectural knowledge is necessary—just awareness of Python's typing module and Sphinx’s mock helper. An AI system with access to the traceback and a minimal understanding of the code flow could easily infer that the key should be str-ified, hence high solvability. The change touches one file and a few lines, so overall complexity is low."
sphinx-doc__sphinx-7910,20,easy,85,"The fix touches a single file and adds only two small edits: importing sphinx.util.inspect and replacing obj.__globals__ with inspect.unwrap(obj).__globals__. No new algorithms or cross-module interactions are introduced. While one must understand Python decorators and the need to unwrap a wrapped function to access the original globals, this is routine introspection knowledge, not deep architectural work. Because the problem statement already pinpoints the offending line and explains the exact issue (decorated __init__ lacks the proper globals), an AI system could infer that inspect.unwrap is the correct remedy with high likelihood. Thus the change is simple, the category is easy, and the chance of automated generation is high, though not perfect because it still requires awareness of the inspect.unwrap utility."
sphinx-doc__sphinx-7985,35,medium,70,"The fix touches a single module (linkcheck builder) and adds ~15 lines that introduce a simple regular-expression test for URI schemes and a filesystem existence check for relative links. No intricate algorithm or cross-module refactoring is involved; the change is essentially a conditional branch with path.exists logic. Understanding Sphinx’s build context and link classification rules is helpful but not deep domain expertise. Because the desired behaviour (treat local paths as working/broken) is clearly stated, an AI with access to the code can infer that it needs to detect the absence of an http/https scheme and verify the file on disk. The main challenge lies in distinguishing unsupported schemes (e.g., ftp) from true local paths and in keeping existing ignore logic intact, which is moderate complexity. Given the clarity of the requirement and the small, isolated change, an automated system stands a good chance of producing a correct patch, though edge cases (Windows paths, odd schemes) add some uncertainty."
sphinx-doc__sphinx-8035,40,medium,55,"The change touches a single core file (~40 modified lines) and introduces a small helper, type-changes for option parsing, and some conditional logic updates. It requires understanding how Sphinx autodoc merges member options, how the ALL sentinel is treated, and how the filtering loop decides whether to keep a member. No new algorithms are added; the work is mainly plumbing existing mechanisms to a new option value type and ensuring backward compatibility. That puts it above a trivial fix but below a large architectural change.

An AI must locate where the private-member option is declared, swap its validator from bool to list, integrate the list with the main members list, and adjust the keep/skip logic. The overall behaviour is well described in the feature request, but correctly updating every decision point (merging, filtering, inheritance, deprecation warnings) needs moderate codebase familiarity and careful reasoning to avoid regressions. Given Sphinx’s extensive test suite, feedback cycles would help, so the probability of a competent AI solving it is slightly better than even but far from certain."
sphinx-doc__sphinx-8056,30,medium,70,"The fix touches only one file and adds fewer than 15 lines, so the change set itself is small. However, it requires understanding how Napoleon parses docstring fields, how the parser’s `_consume_fields` function is used in different contexts, and how the `napoleon_use_param` configuration influences rendering. The core algorithmic change—splitting a comma-separated parameter list and emitting individual entries—is straightforward string processing, but knowing exactly where to insert this logic and guarding it behind a flag (`multiple=True`) demands moderate familiarity with the codebase. An AI system supplied with the bug report and code context could likely infer that splitting on commas is the solution, giving a relatively high solvability score. Nonetheless, the need to propagate the new parameter through call sites and to avoid breaking other sections elevates the task above “easy,” placing it in the medium category."
sphinx-doc__sphinx-8120,30,medium,70,"The change affects two files with a total of roughly ten new/modified lines, no new classes or algorithms, and only reorders the search path for localization files while adjusting a type annotation. Understanding the fix requires some knowledge of how Sphinx resolves message catalogs (project-specific vs. built-in) and awareness that earlier directories in the list take precedence. This is more involved than a typo but far from a large architectural refactor, placing it in the lower-middle complexity range. An AI given the bug report could infer that the custom catalog is being shadowed and that the search priority must be adjusted, making the task reasonably achievable, especially because the bug description explicitly points to where the user’s .mo file sits and that it is ignored. Therefore, the likelihood an automated system can generate the correct patch is fairly high, though not guaranteed, leading to a 70 % solvability estimate."
sphinx-doc__sphinx-8265,35,medium,65,"The bug manifests as incorrectly rendered default argument values (tuples lose their surrounding parentheses). The fix touches only one file (sphinx/pycode/ast.py) and changes ~20 LOC, mainly enclosing tuple output in parentheses and adding special-case logic for tuple slices. While knowledge of Python’s AST and Sphinx’s unparser is needed, the algorithmic work is straightforward string formatting—no deep refactor or multi-module impact. An experienced developer or an AI that inspects the existing visit_Tuple implementation could infer that the missing parentheses cause the observed output. Adding a helper for tuple slices is a small extension of the same idea. Therefore the change is moderately complex, falls into the ""medium"" category, and is reasonably discoverable from the bug description, giving it a 65 % likelihood of being automatically generated correctly."
sphinx-doc__sphinx-8269,10,easy,90,"The change consists of a single-line addition in one file: invoking response.raise_for_status() immediately after performing the HTTP GET. No algorithms or cross-module interactions are affected, and the intent is clearly described in the bug report (return HTTP error instead of anchor-not-found). Implementing this fix requires only basic familiarity with the requests library and the existing code flow; no deep Sphinx internals are touched. Given the clarity of the problem statement and the minimal patch size, an AI system should reliably infer the correct solution, yielding a high solvability score and low complexity classification."
sphinx-doc__sphinx-8459,15,easy,85,"The change modifies a single line in one file, switching a call from inspect.signature(obj) to inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases). No new algorithms or architectural changes are introduced; it is a straightforward parameter-passing fix. Understanding the issue mainly requires awareness that Sphinx wraps inspect.signature to accept a type_aliases argument and that this argument must be supplied when autodoc_type_aliases is configured. The problem statement is clear about the undesired behavior, and the location of the fault is easy to trace by searching where signatures are generated. Given the focused scope, minimal code delta, and explicit symptom, an AI system has a high likelihood of proposing the correct adjustment once it inspects the function call, hence the high solvability percentage."
sphinx-doc__sphinx-8475,15,easy,90,"Only two small code edits in a single file: import an additional exception class and expand an existing except clause to also catch TooManyRedirects. No algorithmic changes, no interaction with other modules. The problem statement explicitly explains the symptom and desired behaviour, practically describing the required patch, so an AI can map it to the code with simple pattern matching. Minimal domain knowledge is needed (knowing requests library exception hierarchy). Therefore complexity is low and likelihood of an AI producing the correct fix is very high."
sphinx-doc__sphinx-8548,45,medium,40,"The change spans two files and roughly 40 lines, introducing a new traversal over the MRO and per-class ModuleAnalyzer creation. It requires understanding how Sphinx autodoc stores attribute docstrings, how ModuleAnalyzer.attr_docs is keyed, and why inherited attributes were previously skipped. The algorithmic work is straightforward list/dict handling, but domain knowledge of Sphinx internals and Python introspection is needed, pushing it above a simple patch but well below an architectural overhaul. From the brief problem statement an AI must deduce that attribute docs for each base class need to be searched and integrate that into get_class_members without breaking existing behaviour; this is non-trivial, especially without explicit tests, so likelihood of an AI producing the exact fix is moderate to low."
sphinx-doc__sphinx-8551,30,medium,45,"The patch touches two files and adds only a handful of lines, so the code-change footprint is small. However, the bug involves Sphinx’s internal cross-reference resolution, which requires understanding how reference nodes store contextual attributes (py:module, py:class) and how docfield helpers call make_xref. An implementer must know that explicit roles already set these attributes and that passing the env plus copying ref_context into the new reference node will align the behaviour. This is domain-specific knowledge but not algorithmically complex. An AI could discover the missing attributes by diff-ing behaviour between explicit and implicit xrefs or by reading surrounding code, but the solution is not a simple pattern substitute; it needs insight into Sphinx’s resolution logic. Therefore complexity is moderate (≈30%), the task category is ""medium"", and the likelihood an AI produces the exact fix from the description without additional hints is under 50% but still plausible (≈45%)."
sphinx-doc__sphinx-8593,40,medium,35,"The change touches two files with roughly 60 new lines and some removals. It introduces a new helper method to gather module members while preserving per-member docstrings so that the "":meta public:"" field can be interpreted. No sophisticated algorithms are added, but understanding Sphinx’s autodoc internals (ModuleDocumenter, ObjectMember, analyzer.attr_docs interaction, underscore-prefixed name filtering, etc.) is required. The developer must notice that the old get_module_members() discarded docstrings and therefore meta information, devise a replacement that keeps this data, and update call sites while deprecating the old utility. This goes beyond a trivial fix yet is still contained and conceptually straightforward, placing the complexity around 40% and the task in the ""medium"" category. For an AI, inferring this root cause from the brief bug report without explicit tests or deep documentation is challenging; it must navigate multiple layers of Sphinx internals, so the likelihood of producing the exact patch is relatively low, estimated at 35%."
sphinx-doc__sphinx-8595,10,easy,80,"The patch is a one-line logical change within a single function. The issue is that the old condition conflated a missing __all__ attribute (None) with an explicitly empty list. Changing the check to `is None` distinguishes the two cases and fulfills the stated expectation. No algorithms or multi-module interactions are involved; only basic Python truthiness semantics. The problem statement is explicit, shows a minimal reproduction, and makes the required behavior obvious. An AI needs only recognize the difference between None and an empty list, making the task highly solvable with minimal codebase understanding. Hence low complexity, easy category, and high likelihood of automatic repair success."
sphinx-doc__sphinx-8621,18,easy,72,"The fix touches a single file and alters just one regular-expression pattern. No additional logic, state management, or multi-module interaction is involved, so the intrinsic code complexity is low. The only knowledge required is understanding how look-behind and look-ahead assertions in regex can prevent matching separators that appear at the beginning or end of the string; this is standard regex fluency rather than deep architectural insight. Generating the correct patch is therefore largely pattern-matching: recognize that the existing pattern splits on every occurrence of '-', '+', or '^', and modify it so it only splits when those characters are surrounded by other characters. An AI supplied with failing test cases (or the descriptive examples in the bug report) could deduce that adding `(?<=.)` and `(?=.)` or equivalent boundaries solves the issue, making the task reasonably achievable. Because the requirements are explicit and the search space of correct regexes is small, the solvability is above average even without extensive context, but it still requires some trial-and-error, so it is not near 100%."
sphinx-doc__sphinx-8638,20,easy,65,"The fix touches a single file with a one-line change that merely removes the ""rolename='obj'"" argument from the PyTypedField definition for variables. There are no new algorithms, data structures, or cross-module interactions introduced, so the inherent code complexity is low.      

What makes the bug tricky is mostly domain knowledge: understanding that Sphinx treats any field with a rolename as an internal reference target, causing automatic cross-linking. Identifying that this single flag is responsible for the incorrect links requires familiarity with Sphinx’s autodoc/linking mechanics, but once the cause is known, the modification itself is straightforward.      

Because the patch is so small and isolated, an automated system that can correlate “variables are being auto-linked” with “field definition sets rolename” has a reasonable chance of producing the same fix, even by simple pattern search in the domain code. However, some conceptual insight into Sphinx internals is still necessary, so the solvability is not near certain but above average."
sphinx-doc__sphinx-8721,12,easy,88,"The fix touches a single function in one file and adds two straightforward guard clauses totaling four lines of code. No intricate algorithm or deep architectural knowledge is required—just awareness of builder names and an existing config flag. The problem statement clearly describes the undesired behavior and names the relevant configuration option, so an AI can locate the collect_pages hook and insert the missing checks with minimal exploration. Therefore, technical complexity is low, and the likelihood an AI system could generate the correct solution is high."
sphinx-doc__sphinx-9229,40,medium,55,"The change touches only one file and about 25-30 lines, so the code volume is modest, but it requires understanding how Sphinx autodoc decides whether to show the docstring for attributes that are actually type aliases. The developer must know about the `doc_as_attr` flag, how variable comments are stored in `ModuleAnalyzer.attr_docs`, and how `add_content` injects the default ""alias of …"" text. The solution entails introducing a helper (`get_variable_comment`) and using its result in two places to suppress the default behaviour only when an explicit comment exists. This demands some insight into Sphinx internals but no complex algorithm or large-scale refactor, hence a medium difficulty (~40% complexity). 

From an automated-repair standpoint, the observable bug (“some alias docstrings disappear”) provides a clear hint, and the required patch is localized and pattern-driven once the relevant property (`doc_as_attr`) is discovered. An advanced AI with access to the codebase could plausibly trace the early return that hides the docstring and adjust it, giving a moderate chance of success (~55% solvability)."
sphinx-doc__sphinx-9230,15,easy,75,"Only a single line in one file is modified: the call to string.split is replaced with rsplit. This is a straightforward bug fix once the root cause (splitting on the first rather than the last whitespace) is understood. No additional algorithms or structural changes are required, and no cross-module interactions are affected. The problem statement clearly describes the incorrect rendering and implicitly points to the need to parse the parameter name correctly, making the scope narrow and well-defined. An AI system that can trace the parsing logic and notice the improper split direction would likely arrive at this solution, leading to a fairly high solvability score. Minimal domain knowledge of Sphinx internals is needed; general string-processing insight is sufficient."
sphinx-doc__sphinx-9258,15,easy,70,"The change touches a single file and alters only one line by extending an existing regular-expression pattern so that it treats the vertical bar (|) as an additional separator when splitting a type string. No new logic, data structures, or interactions across modules are introduced. The task mainly requires identifying where Sphinx currently tokenises type annotations and adding an obvious alternate delimiter. This is straightforward once the correct location is found and only basic regex knowledge is necessary.

While locating the precise regex inside the large Sphinx codebase demands some codebase familiarity, it can be found quickly by searching for the existing delimiters (e.g. ', or ') mentioned in the problem statement. Because the adjustment is purely additive and does not risk breaking other behaviour, the solution space is narrow and an AI equipped with code-search heuristics is likely to propose the same patch. Lack of explicit tests lowers confidence slightly, but the scope is so contained that the likelihood of an AI generating the right fix remains high."
sphinx-doc__sphinx-9281,15,easy,85,"The change touches a single utility function (object_description) in one file, adding an explicit branch that recognizes enum.Enum instances and formats them as ""ClassName.MemberName"". Only a handful of lines are modified; no new algorithms or cross-module interactions are introduced. Understanding Enum’s repr format and Sphinx’s desire for cleaner signatures is straightforward, requiring minimal domain knowledge beyond basic Python introspection. The problem statement is clear (shows the undesirable and desired output) and pinpoints the relevant function, so an AI with code-search and pattern-matching abilities could reliably insert this special case. Therefore, the patch is low complexity (“easy”) and highly solvable, though not trivial enough to be scored at 100% because it still requires knowing where Sphinx formats defaults and ensuring the change does not break other cases."
sphinx-doc__sphinx-9320,15,easy,85,"The change affects a single file with only a handful of lines added. No new algorithm or data structure is introduced; the fix simply relaxes input validation by accepting an empty string. Understanding the existing helper function `is_path`, duplicating it into `is_path_or_empty`, and changing one call site is straightforward. The problem statement clearly explains the undesired behavior and the expected outcome, so the correct modification is obvious. Little domain-specific knowledge is needed beyond recognizing that an empty input should bypass validation. Hence, complexity is low and an AI system has a high likelihood of generating the patch."
sphinx-doc__sphinx-9367,15,easy,90,"The fix touches a single method in one file and only adds a simple conditional branch for a well-known Python syntax rule (tuples with one element require a trailing comma). No complex algorithms or deep knowledge of the Sphinx architecture is needed—just awareness of Python tuple formatting. The problem statement is explicit, gives an example, and even points to where the change should be applied, so an AI with basic AST/printer understanding could infer the required patch quickly. Therefore the task is low-complexity and highly solvable."
sphinx-doc__sphinx-9461,60,hard,35,"The patch spans three core modules of Sphinx (domains/python.py, ext/autodoc/__init__.py, util/inspect.py) and alters several intertwined subsystems: directive option handling, member discovery, object import logic, and docstring resolution. It introduces new detection logic for the special case where a descriptor is wrapped by both @classmethod and @property, updates the rendering prefix, propagates a new :classmethod: option through the documentation pipeline, and enhances generic “isclassmethod” and “getdoc” utilities to work through the MRO.

This requires solid understanding of Python’s descriptor protocol, the subtle behaviour of classmethod(property) combinations introduced in Python 3.9, and the internal flow of Sphinx’s autodoc machinery. The solution is not algorithmically heavy, but its correctness depends on knowing exactly where the introspection and formatting break, and on coordinating changes in multiple layers so that everything lines up.

From an AI-generation standpoint, the problem statement highlights the symptom (undocumented members) but does not spell out precisely which Sphinx components must change. An AI would need non-trivial knowledge of the Sphinx codebase and of Python 3.9 descriptor edge-cases to craft this coordinated fix. Hence the task is classified as hard and the likelihood of an AI arriving at the exact patch without guidance is relatively low (~35%)."
sphinx-doc__sphinx-9591,35,medium,60,"The patch touches a single function in one file and adds only two logical operations: it calls an existing helper (_parse_annotation) and constructs a desc_annotation node with parsed children so that the annotated type is cross-referenced. The code change itself is small and contains no new algorithms, keeping overall complexity low-to-moderate. 

However, crafting this fix requires awareness of Sphinx’s internal node structures, how type annotations are normally parsed elsewhere in the codebase, and why a plain text string prevents cross-referencing. An implementer must locate the correct place in the domain logic and know that _parse_annotation already performs the desired conversion. This pushes the task above “easy”, into the “medium” tier.

From an AI standpoint the problem statement is clear (type annotations in @property are not cross-referenced) and the fix is localized, but selecting the correct helper function and assembling the node arguments in the right order is non-trivial. Without tests, the AI must still run or reason about Sphinx to verify the behaviour. Given available code patterns (other parts of Sphinx call _parse_annotation in similar contexts), the solution is discoverable, so solvability is moderate—around 60%."
sphinx-doc__sphinx-9602,35,medium,60,"The change touches a single module (sphinx/domains/python.py) and adds roughly 15 lines, so the surface area is limited. However, it requires understanding how Sphinx converts Python AST nodes to docutils nodes, how nitpicky cross-reference resolution works, and why literal constants like True should not be treated as class references. The fix involves three coordinated tweaks: using repr() for Constant values, wrapping subscript arguments of typing.Literal in nodes.literal, and then skipping x-ref conversion for those wrapped nodes. This demands moderate domain knowledge of both the Sphinx codebase and docutils node hierarchy but no complex algorithms or data structures. Given a failing test that highlights the error and knowledge of the Sphinx internals, an AI could reasonably infer the need to prevent cross-referencing of Literal arguments; still, selecting the proper docutils node types and insertion points is non-trivial. Therefore the task is medium in difficulty with a moderate likelihood of automated resolution."
sphinx-doc__sphinx-9658,30,medium,40,"Only one file is touched and fewer than 10 lines are modified; there are no new APIs or algorithmic changes. The fix simply adds a __name__ attribute to the mock object and ensures __qualname__ and the dynamically-generated subclass carry it forward so autodoc can display the correct base-class name. Implementing the change is straightforward once the root cause is known, but discovering that the absence of __name__ inside the mock hierarchy is the culprit requires understanding how Sphinx inspects class metadata and how mocking alters those attributes. An AI system would have to reason about Python’s introspection rules and Sphinx’s documentation generation, with little guidance from tests, so while the code delta is small, pinpointing the precise attributes to patch is non-trivial. Hence the change is of moderate conceptual complexity and medium difficulty, with an estimated 40 % likelihood that an AI could derive the exact solution from the description alone."
sphinx-doc__sphinx-9673,15,easy,85,"The change touches only one file with two very small conditional adjustments—adding the word ""returns"" as an accepted synonym for ""return"" in two if-statements. No new algorithms, data structures, or cross-module interactions are introduced. Understanding the bug just requires noticing that Google-style/Napoleon docstrings use the plural heading ""Returns"", so the existing singular check misses it. An AI seeing the problem description (which explicitly mentions that return types are dropped) and the surrounding code (which already handles ""return"") can infer that extending the condition to include ""returns"" will fix the issue. The scope is isolated, the logic is straightforward string comparison, and there are no side effects elsewhere, leading to a low complexity score and a high likelihood that the fix could be generated automatically."
sphinx-doc__sphinx-9698,10,easy,92,"Only one line in a single file is modified, replacing the format string '%s()' with '%s' for the property case. No algorithmic work or deep knowledge of Sphinx internals is needed—just recognizing that properties should not display parentheses. The problem statement explicitly describes the undesired behavior and the expected fix, making it straightforward for an AI to identify the exact change. Edge cases are minimal and no inter-module dependencies are affected, so the task is low-complexity and highly solvable."
sphinx-doc__sphinx-9711,30,medium,75,"The change affects a single function in one file and adds roughly a dozen lines of code. The algorithmic update is straightforward: switch from lexicographic string comparison to semantic version comparison by leveraging packaging.version.Version, with a fallback for unparsable versions. While the patch is short, it does require understanding why string comparison fails for dotted version numbers and knowing an appropriate library to perform PEP-440-compliant comparisons. That domain knowledge elevates it above a purely ‘easy’ typo fix, but there are no intertwined modules, data structures, or intricate algorithms involved, keeping overall complexity low-moderate. The problem statement clearly explains the faulty behavior and implies the correct approach, making it quite solvable by an AI; the primary challenge is recognizing and applying the packaging.version helper. Absence of explicit tests reduces feedback signals but the determinism of the bug keeps solvability high."
sympy__sympy-11618,30,medium,78,"The fix is confined to a single method in one file and consists of ~15 added lines that extend the current Euclidean-distance formula to handle points of unequal dimension by padding the shorter point with zeros before performing the sum of squared differences. This requires understanding why Python’s zip truncates to the shorter iterable and how that leads to the third coordinate being ignored, but no sophisticated algorithms, data structures, or cross-module interactions are involved. Hence the change is moderately complex rather than trivial.

From an AI-generation standpoint the task is highly solvable: the bug is fully described, the failing case is explicit, and the affected code is small and easy to locate. The main challenge is deciding on the desired behaviour for unequal dimensions (pad with zeros vs. raise an error); once that design choice is made, the implementation is straightforward. Because the scope is narrow and the objective is clear, an automated system has a good chance of synthesizing a correct patch, pushing the solvability estimate to the upper-mid range."
sympy__sympy-12096,15,easy,85,"Only one line in a single file is modified. The fix consists of mapping evalf(prec) over the arguments before passing them to the implemented Python function. No new algorithms, data structures, or cross-module interactions are introduced. The problem statement clearly describes the failing behavior and points to the exact function that needs adjustment, so an automated system can infer that the arguments must be numerically evaluated first. Minimal domain knowledge of SymPy’s evalf mechanism is needed; general familiarity with lazy evaluation and numeric conversion suffices. Consequently, the change is straightforward (low complexity) and highly discoverable for an AI, resulting in a high solvability score."
sympy__sympy-12419,20,easy,75,"Only one file is changed and the modification is limited to a handful of lines (≈10). The fix simply refines Identity._entry so that, when the equality of the two symbolic indices cannot be decided at construction time, it returns a KroneckerDelta instead of prematurely assuming zero. No new algorithms or architectural changes are involved; the solution is a direct application of symbolic-logic principles already present elsewhere in SymPy. The main challenge is recognising that the failure arises from using boolean equality on symbolic indices and that KroneckerDelta is the correct symbolic representation. This requires some domain knowledge of SymPy’s symbolic evaluation model but is still quite straightforward. Therefore the task rates low in complexity, falls into the “easy” category, and should be reasonably solvable by an AI given the clear bug description and the small, localized change needed."
sympy__sympy-12481,15,easy,88,"The patch alters a single conditional in one file, removing an unnecessary error for duplicate elements when cycles are intentionally reused. No new algorithms or cross-module interactions are introduced; only a simple logic condition is changed. The problem statement is explicit about the desired behavior (permit non-disjoint cycles), so an AI only needs to locate the duplicate-check and adjust it. Required domain knowledge is minimal (understanding permutations and cycle notation). Therefore the change is low-complexity, falls in the 'easy' bucket, and is highly solvable given the clarity of the specification."
sympy__sympy-12489,40,medium,55,"The change is confined to a single file but spans dozens of individual edits that must be applied consistently. The core issue is conceptual rather than algorithmic: ensuring that helper routines use the dynamic class (cls) instead of the hard-coded Permutation type so that subclasses are instantiated correctly. Solving it requires good knowledge of Python’s object-creation flow (interaction between __new__, staticmethod, classmethod, and Basic.__new__) and awareness of how SymPy’s Permutation utilities are internally chained. However, no new algorithms are introduced and the modifications are largely systematic replacements and method-decorator adjustments. An AI could deduce the solution by tracing where Permutation instances are produced and noticing hard-coded class references, but it must propagate the fix to every internal call site, which adds moderate difficulty. Hence the task is of medium complexity and moderately achievable automatically."
sympy__sympy-13031,30,medium,65,"The change touches a single file and adds only a few lines, targeting a corner-case bug in matrix stacking. No new algorithms or data structures are introduced, so the intrinsic code complexity is low. However, fixing the bug requires understanding SymPy’s matrix shape rules and why the previous early-return logic was incorrect when the left operand is a null matrix with mismatched dimensions. An AI system must reason about these dimension checks and craft the conditional fall-back that rebuilds an empty matrix with the correct shape before performing the join. This requires some domain knowledge of linear-algebra semantics but no large architectural insight, putting the task in the lower-middle range of difficulty. The problem statement is clear (old vs new behaviour) and the patch is tightly scoped, so solvability is better than average, though not trivial because tests are absent and the AI must infer the exact shape logic."
sympy__sympy-13091,40,medium,80,"Although more than 20 files are touched, every individual edit is straightforward: (1) replace an explicit boolean False return with NotImplemented in several __eq__ methods, and (2) update all complementary __ne__ (and a few comparison-helper) methods to use the higher-level operator form `self == other` instead of directly calling `self.__eq__` so that a NotImplemented result is correctly propagated. No new algorithms, data structures, or deep refactors are introduced—just consistent, repetitive mechanical changes based on Python’s rich-comparison protocol. An AI system that understands the requirement to return NotImplemented for unsupported comparisons and can grep for `return not self.__eq__` patterns could systematically apply the fix, so the solvability is high. The main challenge is breadth (ensuring every such occurrence across the codebase is updated) rather than conceptual difficulty, hence a moderate overall complexity."
sympy__sympy-13372,18,easy,90,"The patch modifies a single function in one file, adding two simple `else: raise NotImplementedError` branches. No algorithms are changed and only four lines are added. Detecting that an `UnboundLocalError` stems from missing assignments is straightforward Python debugging; no deep SymPy knowledge or algorithmic reasoning is required. Therefore the change is low-complexity. Because the problem statement itself already hints at the exact fix, an automated system or developer can implement it with high confidence, yielding a high solvability percentage. The main challenge is merely locating where `reprec` and `imprec` should be assigned or an exception raised when they cannot be set, which is a simple control-flow fix rather than an architectural change."
sympy__sympy-13480,8,easy,90,"The bug is caused by a simple typographical error: the code creates a variable named `cothm` and later references `cotm`, leading to a NameError. Fixing it only requires changing one identifier in a single file, with no algorithmic or architectural implications. An AI system can reliably detect the mismatch from the stack trace and surrounding code context, making the task highly solvable. Minimal domain knowledge of hyperbolic functions is needed; general debugging skills are sufficient."
sympy__sympy-13551,30,medium,45,"The actual fix is confined to a two-line change in a single file, so code-wise it is small. Nevertheless, it corrects a mathematical algorithmic error: a product of an additive expression was previously expanded incorrectly by summing the sub-products, whereas the mathematically sound approach is to rewrite the product as exp(Sum(log(..))) so that symbolic evaluation works. Implementing this requires understanding of SymPy’s `Product` evaluation strategy and of the log-sum identity, but no large architectural work. Thus the change is moderately complex rather than trivial. From an automated-repair perspective, the faulty code is short and the incorrect logic is local, yet discovering the precise mathematical replacement (and the need to import `Sum`, use `log`, wrap with `exp`) demands domain insight that is unlikely to arise from generic pattern matching. With no dedicated tests supplied, an AI must infer the right behaviour from the description alone, reducing solvability. Hence moderate complexity, “medium” category, and a below-average likelihood that an AI could generate the exact fix without human guidance."
sympy__sympy-13615,35,medium,60,"The change is confined to a single private helper method and adds roughly ten lines of logic, so the raw code-change complexity is moderate. The key difficulty is recognising that the old implementation treated the three-valued result of `contains` (True / False / None) as binary. Correct behaviour requires separating the ambiguous `None` case, returning those elements in a symbolic `Complement` rather than silently keeping or discarding them. Implementing this fix demands familiarity with SymPy’s tri-state logic and set API but does not require deep algorithmic work or architectural refactoring. For an AI, the spec and failing example clearly point to the `contains` ambiguity, and only a small amount of new code (a ternary sift and a union) is needed, making the patch reasonably attainable, though still non-trivial because the AI has to know about SymPy’s `sift` utility and how to construct the symbolic complement expression correctly."
sympy__sympy-13647,15,easy,85,"The patch is a one-line change in a single file, correcting an incorrect column offset when inserting another matrix. No new algorithms are introduced; only subtraction of an erroneous variable (pos) from an index expression. Understanding the bug requires noticing that after the inserted block, columns were shifted twice, so removing `pos` yields correct indexing. This is straightforward once the symptom (shifted identity rows) is observed. Minimal domain knowledge (matrix column mapping) is needed and no extensive architectural understanding is required, making the task easy for an AI given the example failing behaviour. Therefore complexity is low and solvability is high."
sympy__sympy-13757,10,easy,70,"Only one file is modified and the functional change consists of adding a single attribute (_op_priority) to the Poly class so that SymPy’s mixed-type multiplication dispatches to Poly’s methods even when the Poly instance is on the right-hand side. No algorithms are altered; no additional logic is introduced. Understanding why the bug occurs requires some knowledge of SymPy’s operator-precedence mechanism, but once that is known the fix is straightforward. Therefore the patch is low in code complexity and is classified as easy. An AI system given the symptom (as shown in the problem statement) and access to the codebase could plausibly discover that Poly lacks _op_priority and infer an appropriate value slightly above Symbol’s 10.0, so the solvability is fairly high though not trivial because it demands familiarity with SymPy internals."
sympy__sympy-13798,30,medium,80,"The change is confined to a single constructor in one file (sympy/printing/latex.py) and consists of fewer than 25 added/modified lines. No new algorithms are introduced; the patch simply replaces strict dictionary look-ups with a try/except fallback so a user-supplied string is accepted. The only subtle addition is a small whitelist of whitespace-like symbols to preserve the previous behaviour for numeric multiplication, which is straightforward conditional logic. 

Complexity is therefore low–moderate: some understanding of SymPy’s LaTeX settings is required but no deep architectural knowledge or cross-module changes. Generating this fix mainly involves noticing that a KeyError should be tolerated and choosing sensible defaults, something an AI could derive from the problem statement and a quick scan of the existing code. Because the requirement is explicit (“allow arbitrary mul_symbol while keeping backwards compatibility”) and the code change is localized, the task is highly solvable. The absence of an accompanying test patch slightly reduces confidence, but overall the solution space is narrow and unambiguous."
sympy__sympy-13852,35,medium,60,"The change touches a single module, alters roughly two dozen lines, and mostly adds explicit special-case evaluations plus a small correction to an existing expansion rule. No new algorithms or data structures are introduced, so structural complexity is moderate. However, the fix requires mathematical insight into branch cuts and known closed-form values of the polylog function, which is domain-specific but not algorithmically heavy. An AI system could infer the needed constants directly from the problem statement, and the required code modifications are straightforward pattern edits, making the task reasonably achievable, though the mathematical context raises the difficulty above a trivial patch."
sympy__sympy-13877,40,hard,45,"Although the patch touches only ~20 lines over two files it changes a core routine (matrix determinant computation) that is highly sensitive to symbolic-math corner cases. To arrive at the correct fix one must  1) realise that the Bareiss determinant code was using a naïve pivot finder that fails on expressions whose zero-ness is not detected by simple truth testing,  2) know that SymPy already provides _find_reasonable_pivot together with an overridable zero-testing function, and  3) craft a new zero test based on expand_mul that works for multivariate polynomials/rationals yet is fast enough.  This demands non-trivial knowledge of SymPy internals, Bareiss algorithm constraints, and symbolic expression simplification.  An AI working only from the symptom 'Invalid NaN comparison' would need to inspect the stack trace, locate the faulty pivot logic and design a safe replacement—difficult but possible because the change is localised and there is a clear existing helper.  Hence the task is moderately complex but not enormous in scope, yielding a complexity score of 40%.  Given clear failing tests an AI could eventually reproduce the fix but there are many plausible alternative patches (e.g., bypass Bareiss, switch to LU) so the chance of hitting the exact acceptable change is below even, estimated at 45%."
sympy__sympy-13878,60,hard,35,"Although the change touches only a single file, it introduces or corrects CDF implementations for more than a dozen continuous distributions. Roughly 400 new/modified lines appear, each encoding a mathematically-correct closed-form expression (often piecewise) involving special functions such as lowergamma, uppergamma, erf, hypergeometric and factorial sums. Producing these formulas requires solid probability/statistics knowledge and careful symbolic-math manipulation so that SymPy can simplify and differentiate them correctly. No sophisticated algorithms are added, but the breadth of domain knowledge and the need for syntactically perfect SymPy expressions make this patch substantially harder than a routine bug fix. An AI system would have to retrieve correct CDF formulas for many distributions, translate them into SymPy constructs, handle edge cases, and keep the overall file consistent (imports, sympify, S.One, Piecewise ordering, etc.). While the problem statement clearly describes the goal and lists failing examples, it does not supply the actual formulas, so the model must supply them itself, lowering solvability. Hence complexity is rated at 60% (upper mid-range), category ""hard"", and solvability at 35% because, despite clear intent, accurately encoding all these mathematical expressions without human expertise is challenging for current automated code-generation systems."
sympy__sympy-13974,40,medium,55,"The change is confined to a single module (tensorproduct.py) with roughly 40 new/modified lines.  It introduces a helper (tensor_product_simp_Pow) and extends existing simplification routines to recognise Pow objects whose base is a TensorProduct.  While the algorithms added are straightforward iterations over arguments, the developer must understand SymPy’s non-commutative multiplication handling (args_cnc, nc_part, c_part) and TensorProduct semantics, which adds some domain complexity.  No architectural refactor is required and no other files are touched, keeping overall complexity moderate.  The problem statement gives concrete failing examples and clearly indicates the missing capability (evaluation of powers), so an automated system could deduce the need to intercept Pow cases and distribute exponents, but it still needs familiarity with SymPy internals.  Hence, solvability is moderate: not trivial, yet achievable with systematic code inspection and targeted changes."
sympy__sympy-14248,35,medium,70,"The patch touches three printer modules (latex, pretty, str) introducing about 40 new/modified lines. The new logic mostly involves simple string manipulation: splitting terms, detecting a leading '-', and reassembling the expression so that negative matrix terms render with a subtraction sign instead of an explicit -1 coefficient. It also handles MatMul with a negative scalar factor by pulling the sign out front.

Complexity is moderate: the change spans multiple files and printer back-ends, and requires familiarity with SymPy’s internal representation (MatAdd/MatMul, as_coeff_mmul, _keep_coeff, precedence). However, no advanced algorithms or deep architectural refactoring are needed; the solution is largely straightforward formatting logic.

An AI supplied only with the problem statement could feasibly generate this patch because the requirement is clear (replace “+ (-1)*B” with “- B” across printers) and the fix is localised. The main challenge is knowing where in the codebase the printing functions live and handling edge cases such as the first term’s sign, but SymPy’s code is quite readable and similar patterns already exist for scalar Add/Mul printing. Therefore the solvability is reasonably high but not trivial."
sympy__sympy-14531,35,medium,60,"Only one file is modified and no new logic is introduced – every change simply replaces raw use of the object (implicit str()) with a recursive call to self._print so that the active printer settings propagate into nested expressions. About two-dozen call sites are updated, which is more than a trivial typo fix but still localized and repetitive, so the overall complexity is moderate (≈35%).

To solve this, the developer/AI must understand that StrPrinter options are honoured only when every sub-expression is printed through the same printer. Spotting all places where str(expr) or implicit conversion is used and systematically replacing them with self._print(expr) requires familiarity with SymPy’s printing conventions, but does not demand complex algorithms or deep architectural changes – hence the ""medium"" classification.

Given the clear examples in the problem statement, the root cause (bypassing the printer in nested formatting) is explicit. An automated system could grep for pattern like "" %s"" % expr or "", %s"" % expr inside StrPrinter and patch them, so the probability that an AI produces the correct patch is reasonably high (≈60%) but not trivial: it must avoid breaking other formatting paths and cover all affected methods."
sympy__sympy-14711,10,easy,85,"The patch touches one method in a single file and adds a straightforward guard for the special case where the operand equals the scalar zero. No algorithmic changes, data-structure modifications, or cross-module interactions are involved. The bug is clearly demonstrated in the problem statement, and the fix directly follows from the failing example (treat 0 as the additive identity). An AI system only needs to inspect the error message, notice that __add__ rejects non-Vector operands, and insert the early return. Because the scope is well-defined and the fix is a two-line conditional, the task is highly solvable. Minor domain knowledge—that 0 acts as the additive identity for vectors—is sufficient but not specialized. Therefore complexity is low, category is easy, and solvability is high though not absolute, leaving room for alternate interpretations of equality with zero."
sympy__sympy-14976,20,easy,88,"The fix consists of adding a single helper method (_print_Rational) to one file so that Rational constants are converted into high-precision mpmath.mpf objects when lambdify is called with modules='mpmath'. Only ~8 lines are inserted, no existing logic is altered, and no new algorithms or cross-module interactions are introduced. The required insight is simply to mirror the existing _print_Float implementation and divide the numerator and denominator mpf objects. This is a straightforward pattern once the symptom (plain 232/3 in generated code) is understood. Because the problem statement clearly pinpoints the defect and shows the incorrect output, an automated system can readily infer that Rationals need special handling similar to Floats, making the task highly solvable. The minimal code change, absence of architectural complexity, and explicit guidance in the example keep overall complexity low."
sympy__sympy-15017,10,easy,90,"The fix is a one-line change in a single file: replace a conditional special-case with functools.reduce(..., 1) so that the product of an empty shape becomes 1 instead of 0. No deep algorithmic insight or architectural understanding is needed—just recognition that the neutral element for multiplication should be used. The problem statement is explicit, reproducible, and points directly to the incorrect behavior. An AI system can map the description to the simple code adjustment with high likelihood, so solvability is high. The limited scope and trivial logic keep complexity very low."
sympy__sympy-15345,15,easy,80,"The change touches a single file with only a few lines added. It simply extends an existing mapping so that the SymPy Mathematica printer recognises Min and Max, and re-uses the generic function printer for the MinMaxBase class. No new algorithms or structural refactoring are involved and no deep domain expertise (beyond knowing Mathematica uses square brackets for function calls) is required. An AI seeing the wrong output ('Max(2, x)') versus the expected ('Max[x,2]') could locate the mapping table and notice the missing entries, making the fix straightforward. The subtle step of aliasing _print_MinMaxBase to _print_Function is still discoverable by searching for how other printers delegate. Overall, low complexity and high likelihood that an automated system could produce the patch."
sympy__sympy-15349,15,easy,80,"Only a single line in one file is modified, changing a plus to a minus. The bug is a sign error in the quaternion-to-rotation-matrix conversion. While some domain knowledge of quaternion rotation formulas is helpful, the problem statement already demonstrates the incorrect behaviour and implies that one of the sine terms must be negative. An automated system can search the function, compare it with the standard formula or observe the asymmetric sign pattern and infer the fix. Because the change is minimal and localized, with no side-effects elsewhere, the overall complexity is low. Given the clear example in the report and the simplicity of the edit, an AI has a high likelihood of producing the correct patch, hence a high solvability percentage."
sympy__sympy-15599,30,medium,70,"The change is limited to a single file (sympy/core/mod.py) and adds roughly twenty lines, primarily inserting an extra reduction pass that takes integer factors in a product and reduces them modulo q when q is an Integer. No new algorithms or deep refactoring are introduced; the logic is a straightforward extension of existing code paths. However, the maintainer must understand SymPy’s expression tree (Mul, Mod, Symbol, etc.) and idiosyncrasies such as S.One, integer_types, and the guard against negative remainders. This domain knowledge places it above a trivial fix but well below a complex architectural change. 

From an AI-generation perspective, the desired behaviour is clearly stated (Mod(3*i,2) -> Mod(i,2)), and the original diff in the issue even hints at the solution approach, so an automated system with code context would likely find an acceptable patch. Edge cases (e.g. not reducing when q==1, preserving non-integer factors, avoiding zero remainders) do require attention, but the scope is narrow and well-defined by existing code and tests, yielding a relatively high likelihood of success."
sympy__sympy-15809,10,easy,90,"The change affects a single file with the removal of two lines that raised an exception when Min() or Max() were invoked without arguments. No new logic is added; the fix simply allows existing downstream logic to handle the empty-argument case, resulting in the desired mathematical identities (oo and -oo). This requires minimal domain expertise (understanding that removing the guard lets the identity elements propagate) and no algorithmic work. An AI system could readily map the problem statement ('stop raising, return identities') to removing the offending check, making the task highly solvable. Overall complexity is low because the patch is trivial, touches only one localized spot, and has no broader architectural impact."
sympy__sympy-15875,15,easy,85,"The patch modifies a single conditional in one file, adding an extra clause so that Add._eval_is_zero returns None when there are no definitively non-zero terms. This is a one-line logic fix with minimal algorithmic impact and no inter-module ripple effects, so overall complexity is low. The problem statement clearly identifies the erroneous behaviour and provides a concrete failing example, which makes it straightforward to reason about the cause. Fixing it only requires understanding that is_zero must not incorrectly return False; adding the guard is an intuitive solution once the internal variables (z, nz) are examined. Consequently an automated system that can trace the failing example through the code could likely produce the change, giving a high solvability score. Domain knowledge of SymPy’s truth value triad (True/False/None) is useful but not deep, keeping the task in the ‘easy’ category."
sympy__sympy-15976,35,medium,55,"Only one function in a single file is touched. The change mainly restructures element creation so that the returned MathML node is the actual <mi>, <msub>, <msup>, or <msubsup> element instead of an <mi> that incorrectly contains other MathML elements as children (which is invalid and made the symbol disappear). No new algorithms are introduced; it is a small, local DOM-building fix requiring basic understanding of MathML structure.

What raises the complexity from trivial to moderate is the need to know that nesting <msub> etc. inside <mi> is illegal and causes rendering issues. An implementer must recognize that the root element should change depending on whether subscripts/superscripts are present, and must preserve the bold attribute logic. This requires some domain knowledge of MathML but not deep architectural changes.

For an AI, the bug is slightly tricky: the symptom (symbol invisibility) does not directly reveal the invalid markup cause. However, the code size is small and there are clear clues (creation of an <mi> and then appending complex elements to it). With adequate static analysis or reference to MathML docs, the correct refactor is achievable, though not guaranteed. Missing automated tests lowers the solvability score because an AI must reproduce the problem and verify the fix manually or via external rendering behavior.
"
sympy__sympy-16450,15,easy,80,"The fix involves a one-line modification in a single file: when `posify` replaces a Symbol with a Dummy it now passes through the original symbol’s `assumptions0`. No new algorithm or cross-module interaction is needed; the developer only had to notice the missing assumptions and forward them. Understanding SymPy’s assumption system is helpful but not deep domain knowledge. Because the bug and its solution are both clearly described in the problem statement, an automated system could infer that preserving assumptions is required and apply the simple keyword-argument change. Therefore the task is low-complexity (≈15 %), classified as “easy,” and highly solvable (≈80 %)."
sympy__sympy-16597,-1,error,-1,Failed to parse response
sympy__sympy-16766,15,easy,92,"The change consists of adding a single helper method (_print_Indexed) to one file in SymPy’s printing module. The logic is straightforward string formatting: extract the base and remaining indices, recursively print the indices, and join them with commas. No deeper algorithmic work or cross-module interaction is required. The problem statement explicitly supplies the exact method body, so an AI system only needs to insert it in the correct class. Domain knowledge of SymPy’s printer naming convention (_print_<Class>) is minimal and easily inferred from existing code patterns. Therefore, the task is low in complexity and highly solvable with simple pattern matching or template insertion."
sympy__sympy-16792,35,medium,60,"The fix touches a single file and adds roughly a dozen lines, mainly to ensure that dimension metadata is attached to array-like arguments even when they do not appear in the generated expression. No new algorithms or large structural changes are introduced; it is essentially a conditional path adjustment plus a small helper function. Implementing this requires understanding how SymPy distinguishes scalars from arrays (Indexed, IndexedBase, MatrixSymbol) and how the codegen ‘Routine’ uses metadata to build the C signature, but those are moderate domain concepts, not deeply complex. 

From an AI-generation standpoint, the problem statement is clear, includes an MWE that pinpoints the failure, and explicitly states that the bug is in `codegen`. An AI with repository access could search for where argument metadata is constructed and notice that paths missing array usage default to scalar arguments. The required code change is local and pattern-driven, so the likelihood of a correct automated repair is better than average, though not trivial because it still demands inspection of SymPy’s internal representations and careful manipulation of metadata."
sympy__sympy-16886,5,easy,95,"The fix is a single-line change that corrects a typo in a constant dictionary used for Morse code look-ups. No algorithmic logic, control flow, or multi-file interactions are involved; only the literal string mapped to the digit 1 is updated. The problem statement explicitly names both the incorrect and correct values, so an AI system merely needs to perform a straightforward substitution. There is almost no domain expertise required beyond recognizing standard Morse code. Because the scope is limited, side effects are minimal, and the required change is unambiguous, the task is highly solvable with a very small complexity footprint."
sympy__sympy-17139,15,easy,85,"The patch touches a single file and adds only two guard lines that exit early when the exponent is non-real. No algorithms are rewritten, no additional functions are introduced, and the fix is a straightforward conditional check. The main challenge is recognizing from the traceback that the illegal comparison stems from attempting to order a complex exponent; once identified, the solution is obvious. An AI system that can parse the error message and inspect the comparison site can reliably insert this guard, so the solvability is high. Overall, the change is simple, localized, and requires minimal domain expertise beyond knowing that complex numbers are unordered."
sympy__sympy-17318,35,medium,75,"The bug manifests as an IndexError deep in the sqrtdenest recursion when split_surds receives an empty tuple. Fixing it involves understanding that split_surds (and the underlying _split_gcd routine) assume every term’s square is a positive rational. A single-line logical guard was added so _sqrt_match only forwards expressions that satisfy this assumption, plus accompanying docstring clarifications. Although the code change is tiny, identifying the precise precondition violation requires moderate familiarity with SymPy’s denesting algorithm and number property inference, hence a medium-level complexity (~35%). From an AI-generation standpoint the stack trace points directly to the failing path, the guard condition is straightforward, and multiple reasonable fixes (checking list length, filtering arguments, etc.) could solve the issue, so the task is fairly achievable with clear cues, giving a ~75% solvability likelihood."
sympy__sympy-17630,30,medium,55,"The patch touches only one file and adds two functional lines, so the code change itself is small and not algorithmically complex. However, discovering the correct place to intervene (the _postprocessor that SymPy uses for automatically simplifying matrix expressions) requires a non-trivial understanding of SymPy’s internal expression construction, in particular how MatAdd/MatMul mix scalar and matrix terms. That pushes the task beyond a trivial bug fix into the ""medium"" range. 

From the problem description an AI can reproduce the failure and see that zeros turn into plain scalar Zero objects. With some code search (looking for where ZeroMatrix could be converted to Zero during addition) the _postprocessor function is a logical suspect. The actual fix—special-casing MatAdd so that it keeps matrix information by calling doit directly—is concise once the culprit is found. Because the change is conceptually straightforward once the correct location is identified, an AI system with search and test feedback has a better-than-even chance of producing the fix, but it is far from guaranteed; it needs sufficient context of SymPy internals and a passing familiarity with its simplification pipeline. Hence the solvability percentage is moderate (55%)."
sympy__sympy-17655,10,easy,90,"The bug is caused by the absence of the __rmul__ method on Point, preventing scalar * Point from delegating to the existing __mul__. The fix is to add a four-line wrapper that calls __mul__. Only one file and a few lines are touched, no algorithms are involved, and no deep domain expertise is needed—just awareness of Python’s reflected operator methods. Therefore the change is simple (≈10% complexity) and highly discoverable by an AI from the stack trace and problem description, resulting in a high solvability estimate (~90%)."
sympy__sympy-18189,18,easy,65,"The fix touches a single file and changes only one function call, simply passing through an existing argument (permute) during a recursive call. No new algorithms are introduced, no data structures altered, and there is minimal risk of side-effects. Understanding that the lost argument causes inconsistent results only requires tracing one code path and recognizing that the default value of permute is False. While some domain knowledge of SymPy’s diophantine solver helps, the bug is essentially a missed parameter propagation—common and straightforward. Therefore the change is low complexity and classified as easy. For an AI system, once the inconsistent behaviour is observed, a static search for internal calls to diophantine without the permute argument would likely reveal the culprit, so the probability of automatically generating the fix is reasonably good but not guaranteed, leading to a mid-high solvability estimate."
sympy__sympy-18199,40,medium,85,"Only one file is touched, but ~50 new lines introduce an auxiliary routine (_nthroot_mod_composite) and modify control flow.  The new routine relies on CRT, Hensel lifting and factorisation, demanding some number-theory background, so the overall patch is more than a trivial typo fix.  Still, the change is confined to a single well-scoped function and adds no new external dependencies.  

From the standpoint of the stated defect (missing the root x = 0 when a ≡ 0 (mod p)), the essential fix is the two-line guard that returns [0].  That logic is straightforward and could be produced by recognising the mathematical fact that 0^n = 0.  Given the clear problem description, an automated system or junior developer could reliably add that condition, so solvability is high.  

The additional composite-modulus support raises code volume and theoretical depth but is not required to satisfy the bug report; its inclusion increases complexity but not to the level of a major architectural overhaul.  Hence a moderate (40%) complexity rating, the ""medium"" category, and a high (85%) likelihood that an AI could generate a correct minimal fix."
sympy__sympy-18211,15,easy,90,"The change touches a single method in one file and adds fewer than 10 lines. It simply wraps an existing function call in a try/except to convert a NotImplementedError into the correct fallback object (ConditionSet). No new algorithms or data structures are introduced, and no interactions with other parts of the codebase are required beyond one extra import. An AI system can infer the solution directly from the problem statement, which explicitly says that when NotImplementedError occurs a ConditionSet should be returned. Therefore complexity is low, the task is easy, and the probability that an automated system could generate the fix is high."
sympy__sympy-18698,35,medium,70,"The change touches a single function in one file and adds only a handful of lines. The required fix is conceptually simple: group factors that share the same multiplicity when the method ""sqf"" is requested. Implementing this needs modest knowledge of SymPy’s factor-list representation and basic Python (reduce, operator.mul). No deep algorithmic redesign or cross-module work is needed, but the developer must realise that grouping by multiplicity is the mathematical definition of a square-free factorisation, so some domain understanding is involved. An AI given the inconsistency description and access to the code could plausibly infer that the solution is to aggregate factors by exponent, making the task moderately achievable. Hence moderate complexity and a reasonably high solvability percentage."
sympy__sympy-18763,12,easy,82,"Only a single string in one function needed modification to insert additional LaTeX parentheses. No algorithmic changes, no cross-module impact, and the required fix is directly implied by the incorrect vs. expected output shown in the problem statement. Any AI that can locate the _print_Subs method and understand basic string formatting could apply the fix, so solvability is high. The task remains simple despite being in a large library because it is fully localized and requires minimal SymPy or LaTeX expertise."
sympy__sympy-19040,30,medium,80,"The fix touches a single line in one file, so the code change itself is small. However, the function is part of SymPy’s multivariate polynomial factoring machinery, which requires some familiarity with square-free decomposition and normalization steps. An AI needs to reproduce the failing example (factor with extension=[I]) and trace where the extra factor is lost. Once located, the root cause is straightforward: dmp_sqf_norm must operate on the original polynomial F, not on the already-modified f. Swapping the argument is a simple edit, hence low code-complexity (~30%). Still, identifying that specific call demands understanding the data flow in the algorithm, pushing the task above the purely “easy” label into “medium”. Because the bug is deterministic, the failure is easy to assert, and the correct fix is unique and concise, an AI system with access to the test case and codebase would have a high likelihood (~80%) of generating the correct patch."
sympy__sympy-19346,15,easy,92,"The change touches one file with ~10 new lines, adding straightforward handling for dict and set in the srepr printer. No algorithmic work, no cross-module interactions, and the desired output is explicitly shown in the problem statement, so a solution is readily inferred by simple pattern matching. An AI only needs to locate where list/tuple printing is done and mimic it for dict/set, which is direct and highly likely to be produced correctly. Hence low complexity, “easy” category, and high solvability."
sympy__sympy-19495,35,medium,60,"The change is confined to a single method (_eval_subs) in one file with roughly a dozen lines touched. No new algorithms are introduced and no cross-module refactorings are needed, so the intrinsic code complexity is moderate (≈35%).

However, understanding why the old branch `if cond is S.true:` was incorrect requires domain knowledge of SymPy’s substitution semantics for bound variables in sets. The developer has to realize that when the condition becomes `True` after substitution we must *not* swap the set’s bound symbol with the substitution target (`new`), otherwise the bound variable is lost, producing the wrong result shown in the issue. This conceptual nuance pushes the task beyond a trivial fix but still keeps it in the “medium” band because the actual implementation is just deleting the special-case branch and deferring to the generic constructor.

From an AI/automated repair standpoint, the bug is detectable by running the user’s failing example, and the minimal patch (remove the special case) is relatively small search space. Yet choosing this exact fix instead of other possibilities (e.g., trying to replicate `Contains` logic) requires recognising the semantic error, which is non-trivial but doable with targeted tests. Therefore the solvability is assessed at about 60%.

In sum: modest code change, requires moderate conceptual insight, and is realistically discoverable by an AI with test-based feedback."
sympy__sympy-19637,12,easy,85,"The bug is a straightforward scoping/indentation issue: the variable `kern` is only defined inside the preceding `if` block, yet it is referenced afterwards, causing an UnboundLocalError. The fix simply moves the assignment of `hit` under the same indentation as the initialization of `kern` and adds an `else` clause to set `hit` when the `if` does not execute. Only one file and a handful of lines are touched; no algorithms or cross-module interactions are involved. An AI seeing the error message ('kern' referenced before assignment) and the surrounding code can quickly deduce that `kern` must be created before use or the reference must be guarded. Therefore the task is low-complexity and highly solvable by pattern recognition and basic Python knowledge."
sympy__sympy-19783,20,easy,85,"The bug is localized: when a Dagger operator is multiplied by an IdentityOperator, the expression should simplify to the Dagger itself. The fix involves adding a handful of lines (≈10) across two files: (1) overriding Dagger.__mul__ to recognize IdentityOperator and return self, and (2) slightly broadening an existing isinstance check in Operator.__mul__. No algorithms, data structures, or deep architectural knowledge are required—only a basic understanding of SymPy’s class hierarchy and operator overloading. Therefore the change is low-complexity. 

Given the clear symptom in the problem statement (""Dagger() * IdentityOperator() is not simplified"") and SymPy’s pattern of handling A * I → A with ordinary Operator, an AI system can infer that an analogous rule is missing for Dagger. The implementation is short, deterministic, and testable, making the task highly solvable with straightforward pattern matching or minimal reasoning."
sympy__sympy-19954,35,medium,70,"The bug stems from mutating several parallel lists (blocks, num_blocks) while iterating, leading to mis-aligned indices and an IndexError. The fix adds a boolean mask to postpone deletions until the loop ends, then filters all related lists simultaneously. Only a handful of lines in a single file are modified; no new algorithms or major refactoring is involved, but the developer must recognize the mutation-during-iteration hazard and ensure all lists stay in sync. That requires a working understanding of Python list semantics and the specific data relationships in SymPy’s block-finding routine—more intricate than a simple typo but far from architectural complexity. Because the traceback clearly points to the faulty lines and the logic error is a common programming pattern, an AI with static analysis capabilities and context of the function could likely propose a similar fix, giving a relatively high solvability score."
sympy__sympy-20154,15,easy,85,"The required fix is confined to a single function: instead of yielding the same mutable dictionary object repeatedly, the code must yield a shallow copy (ms.copy()). That only involves adding .copy() in two yield statements and adjusting the docstring. No algorithmic changes, data-structure redesign, or cross-module effects are involved. Understanding the issue merely requires recognizing the dangers of mutable aliasing—basic Python knowledge. Because the problem statement explicitly points out the undesired behaviour and the desired correction (""copy the dictionary before yielding it""), an AI system can directly translate this into the patch with minimal inference. Therefore, complexity is low, the task is categorized as easy, and the likelihood of an AI producing the correct patch is high."
sympy__sympy-20428,20,easy,85,"Only one file is touched with a single-line modification. The change replaces a strict equality test (f.ex != 0) with SymPy’s semantic zero test (not f.ex.is_zero). No algorithms or data structures are added or modified; the fix is purely logical. While it helps to know that `Expr` objects have an `is_zero` attribute and why `EX(0)` should evaluate as False in a boolean context, this is routine SymPy domain knowledge rather than deep architectural insight. Because the bug manifestation (zero polynomial behaving inconsistently) and the faulty condition (boolean evaluation in ExpressionDomain) are clearly described in the problem statement, an AI system could infer that `is_zero` must be used. Therefore the task ranks low in complexity and high in solvability."
sympy__sympy-20438,40,medium,55,"The fix spans three files and touches different subsystems (relational simplification, generic set equality, and subset handling).  The actual code changes are small and algorithmically simple—early-exit guards to avoid invalid arithmetic on non-Expr objects and a straightforward dispatch rule for ProductSet ⊆ FiniteSet—but they require awareness of SymPy’s multiple-dispatch mechanism and its internal type hierarchy.  Understanding the stack-trace, identifying where set objects were being treated like Exprs, and knowing that `is_subset` ultimately feeds into fuzzy logic for `==` demands moderate domain knowledge.  An AI with access only to the failure example could reasonably infer that a specialized subset handler is missing and that relational simplification needs a type check, but it would still need to understand SymPy’s dispatch decorators and fuzzy logic helpers.  Therefore the task is of medium complexity (~40%) and moderately solvable (~55%) by an automated system."
sympy__sympy-20590,30,medium,70,"The fix touches a single file and adds one simple line (__slots__ = ()) but identifying the root cause requires understanding Python’s multiple-inheritance slot rules. The developer had to realize that Symbol inherits from the Printable mix-in and that Printable lacking __slots__ implicitly adds a __dict__ to all subclasses, defeating the purpose of slots. This demands some knowledge of Python data-model internals but no algorithmic work, large refactor, or multi-module coordination, so the intrinsic change is low-complexity. An AI given the symptom (Symbol unexpectedly has a __dict__) and the codebase could likely grep for base classes without __slots__ and infer the small patch, making the task reasonably achievable, though not trivial pattern matching. Hence moderate complexity (30%), medium category, and a relatively high solvability (70%)."
sympy__sympy-20801,30,medium,75,"Only a few lines in one file are modified, so the code change is small in size and affects a single, well-isolated method (Float.__eq__). Nevertheless, the bug involves subtle interaction between SymPy’s numeric truth-testing and Boolean objects. The developer must understand that the early-return ""if not self"" branch fires for zero floats and inadvertently treats BooleanFalse like the builtin False, producing an asymmetric equality result. Fixing it requires moving that branch below the explicit Boolean type check so that Boolean objects are handled first.

The required insight is modest but non-trivial: the solution is not a simple typo but a logical reordering based on knowledge of SymPy’s internal bool/number behaviour. No complex algorithms or multi-module changes are needed, which keeps overall complexity low-to-moderate (≈30%).

From an AI standpoint the task is fairly solvable because the symptom is easy to reproduce, the erroneous line is short and unique, and the correct fix is to reposition it. However, the AI must reason about Python truthiness and SymPy’s Boolean class hierarchy, so it is not trivial pattern matching. Given the clear symptom and limited scope, the likelihood that an AI could locate and apply the correct patch is high (≈75%)."
sympy__sympy-20916,15,easy,85,"Only one functional line is modified: the regular-expression that detects a symbol name followed by digits. The change broadens the character class from ASCII letters to any Unicode letter (excluding digits/underscore) and sets the UNICODE flag. This directly fixes the reported issue where Greek letters with numeric subscripts were not detected. No algorithms, data structures, or multi-file interactions are involved; understanding basic Python regex syntax suffices. Because the bug description pinpoints the failing behavior and the fix is a straightforward regex adjustment, an AI system can reliably infer the solution. Required domain knowledge is limited to knowing how Unicode character classes work in Python’s `re` module. Therefore the task is simple, with low complexity, and highly solvable by automated means."
sympy__sympy-21379,30,medium,55,"The fix touches only one file and adds ~10 lines, consisting mainly of importing PolynomialError and wrapping a gcd call in a try/except block. No algorithms are rewritten; the solution is to gracefully ignore a failure case. However, discovering where the PolynomialError originated requires understanding SymPy’s evaluation chain and the interaction between Piecewise expressions, polynomial gcd, and modular simplification. Isolating that the exception occurs inside core.mod.Mod.eval is non-obvious and demands moderate familiarity with SymPy internals and debugging skill, but once located, the remedy is straightforward. Therefore the code change itself is simple, yet the analytical step to identify it pushes the task above “easy” into “medium” complexity. Because the bug is reproducible with a concise example and the fix is a standard defensive pattern, an automated system or knowledgeable developer has a fair (but not certain) chance of generating the patch."
sympy__sympy-21596,45,medium,65,"The change touches a single file (~30 lines added/modified) and does not introduce a new algorithm; it corrects the logical treatment of the index set when intersecting an ImageSet with Reals. The core insight is that the indices satisfying Im(expr)=0 must be kept (intersection) rather than removed (subtraction). Implementing this requires moderate familiarity with SymPy’s ImageSet/ConditionSet machinery, solve_linear, and denominators, but it is localized and conceptually straightforward once the bug is understood. An AI equipped with failing tests or the example scenario could plausibly infer that the sign of the set operation is wrong and craft a fix, hence a >50 % solvability. However, the symbolic-math context and need to preserve performance (use numer, introduce helper _solution_union) add some domain complexity, so the task is not trivial, leading to a mid-range complexity rating and a “medium” category."
sympy__sympy-21612,15,easy,70,"Only one file is touched with a single-line logical change: extending an isinstance check from Mul to (Mul, Pow). No algorithms are introduced or altered; the fix simply broadens a condition so that parentheses are inserted when the base of a power is itself a Pow, preventing mis-grouping in the generated expression. Understanding SymPy’s printing/parsing pipeline helps, but the code around the change is self-explanatory and the problem statement pinpoints the faulty behaviour. An automated system that runs the failing example, inspects the part of the printer that decides on parentheses, and notices the omission of Pow could feasibly propose this fix, so solvability is quite high. However, it still requires minimal source inspection and contextual reasoning, so it isn’t trivial but remains on the easy side."
sympy__sympy-21847,15,easy,85,"The bug fix touches a single function in one file and changes only two expressions, replacing max(powers.values()) with sum(powers.values()). No new logic, data structures, or APIs are introduced and the domain concept (total degree vs. individual variable degree) is straightforward. Understanding the function’s intent from the docstring and matching it to the observed wrong comparison is enough to propose the correct change. Therefore the technical complexity is low (≈15%), falling in the ""easy"" category. Because the problem description clearly states the symptom and pinpoints that total degree must be used, an automated system has a high chance of producing the same fix, yielding a solvability estimate of about 85%."
sympy__sympy-21930,12,easy,90,"The patch modifies only three format strings in a single file, adding surrounding curly braces so that LaTeX superscripts are grouped properly. No algorithms, data structures, or cross-module interactions are involved; it is a straightforward string-formatting fix. The problem statement explicitly pinpoints the faulty output and even hints at the exact solution (add curly brackets), so an automated system can map the symptom to the required one-line changes with simple pattern matching. Consequently, the task is low in complexity and highly solvable by an AI. Minor domain knowledge of LaTeX syntax is useful but not deep, keeping overall difficulty minimal."
sympy__sympy-22080,35,medium,60,"The bug manifests as a precedence error in SymPy’s code printer: when converting expressions like -Mod(x, y) with lambdify(modules=[]), the generated Python code becomes (-x % y). That gives Python’s modulo-with-negative-operand semantics (4 for inputs 3,7) instead of the intended result (-3). Fixing this requires understanding how SymPy assigns numeric precedence levels to its internal classes and how the generic CodePrinter.parenthesize routine makes decisions. The actual patch is small—two files, ~15 lines—so the raw code change is not large. However, identifying the root cause (missing precedence weight for Mod and special-casing unary minus because SymPy lacks an explicit UnaryMinus class) demands knowledge of SymPy’s printer architecture, Python operator precedence, and how lambdify builds source strings. An automated system that merely pattern-matches on failing output is unlikely to guess these subtleties, but one with analysis of precedence tables and the failing example could. Therefore the problem sits in the mid-range for both complexity and solvability: it is more than a typo fix yet far from a deep algorithmic overhaul. AI could plausibly find it with targeted reasoning, but it is not trivial."
sympy__sympy-22456,30,medium,65,"The fix touches a single file and adds fewer than 20 lines, so the pure coding effort is small. However, understanding why the String class must satisfy the SymPy core invariant expr.func(*expr.args)==expr requires familiarity with SymPy’s object model, especially the distinction between Basic, Atom, and Token. The solution—making String inherit from Atom and overriding func/kwargs—comes from domain knowledge rather than simple pattern matching, but it does not involve complex algorithms or large-scale refactoring. Given the clear problem statement that explicitly names the invariant violation, an AI with knowledge of SymPy internals could reasonably infer that inheriting from Atom is the correct move and supply the necessary overrides, yielding a moderate solvability likelihood."
sympy__sympy-22714,30,medium,70,"The patch consists of a one-line logical adjustment in a single file, so the code change itself is small. However, understanding why the original condition fails requires knowledge of SymPy’s evaluation mechanism, the meaning of evaluate(False), how Im/imaginary part is represented symbolically, and why using the raw expression in a boolean context is unsafe. The fix—checking `im(a).is_zero is False`—is conceptually simple once the underlying issue is understood but not entirely obvious by pattern matching alone. An AI system equipped with the stack trace and problem description could likely locate the problematic boolean test and adapt it, giving a fairly high chance of success, yet it still demands some domain reasoning rather than a trivial text substitution. This places the task in the lower-middle complexity range (30%) and a medium category, with an estimated 70% likelihood that an automated system could produce the correct patch."
sympy__sympy-22914,10,easy,95,"The fix consists of adding two key-value pairs to an existing dictionary so that the code printer recognises Min and Max. Only one file is touched and no algorithmic work is required—just mapping names to built-in min/max. The problem statement is explicit about what to add and even gives the intended implementation. Therefore the task is trivial for either a human or an automated system, yielding very low complexity and very high solvability."
sympy__sympy-23262,15,easy,88,"Only one file is touched and the change is three lines long. The bug is a missing comma when printing a 1-element tuple; fixing it just means modifying the tuple delimiters so that a trailing comma is inserted. No algorithms or deep architectural knowledge are required—just awareness of Python’s tuple syntax. The problem statement explicitly pinpoints the incorrect output and therefore clearly guides the patch. An automated system that parses the symptom (difference between (1,) and (1)) and searches for where brackets are assembled could readily produce the fix, so the solvability is high. Overall the task involves simple string-formatting logic, making it low in complexity and easy in category."
sympy__sympy-23413,35,medium,70,"The bug is confined to a single internal function that implements the Hermite normal-form algorithm. Only a handful of lines are touched, but understanding why min(m,n) is incorrect and when k should stop requires familiarity with linear-algebra algorithms and the existing invariant used by the code. The change does not involve multiple modules or extensive refactoring, hence moderate complexity (~35%).

An AI system that sees the symptom (a row disappears when m>n) and inspects the loop would likely detect that the loop prematurely stops at min(m,n) rows, propose iterating over all rows, and add an early exit guard once enough pivots are found. This fix is relatively local and follows the intent already hinted at by the surrounding comments, giving a fair chance of automatic synthesis (~70% solvability). The task is harder than a simple typo (requires algorithmic reasoning) but doesn’t demand deep architectural knowledge, categorising it as ""medium"" difficulty."
sympy__sympy-23534,15,easy,85,"The patch modifies a single line in one file, simply forwarding the `cls` argument when recursively calling `symbols`. No new algorithms or architectural changes are introduced; it is a straightforward parameter-propagation bug fix. While a basic understanding of SymPy’s `symbols` helper is required, the issue is localized and easily detectable by reading the function. Given the clear problem description, reproducible symptom, and the minimal scope of the fix, an AI system has a high chance of discovering the missing argument and generating the correct patch, resulting in a high solvability score."
sympy__sympy-23824,15,easy,85,"The change affects a single function in one file and modifies only two lines of code to correct list-insertion order. The underlying bug is straightforward once the behavior (reversal of leading gamma matrices) is observed: inserting elements one-by-one at index 0 reverses their order. Fixing it merely requires pre-pending the slice in one operation or iterating from the end. No complex algorithms, data structures, or cross-module interactions are involved; only basic list manipulation knowledge is necessary. The problem statement clearly pinpoints both the faulty behavior and its cause, dramatically lowering the search space for an automated system. Consequently, generating the correct patch is highly achievable, though it does require recognizing the order-reversal side effect of repeated insert(0, …), hence the solvability is not absolute."
sympy__sympy-23950,10,easy,90,"The change touches a single method in one file and modifies only one line, replacing a NotImplementedError with a simple return of an existing argument. No new algorithms, data structures, or multi-file interactions are introduced. The bug is clearly described in the problem statement, and the expected behavior (return the set argument) is intuitive once the signature of Contains(arg, set) is known. Minimal domain knowledge beyond recognizing that Contains stores its set in args[1] is required, and the fix involves straightforward attribute access. Therefore, the task is low in complexity, categorized as easy, and highly solvable by an automated system given the explicit description of the issue."
sympy__sympy-24066,35,medium,65,"The change touches a single function in one file and only alters a few lines, so the raw code complexity is low. However, it requires an understanding of SymPy’s unit/dimension system and how mathematical functions (like exp) should treat their arguments’ dimensions. The bug arises because the original code forwarded the dimensions of the function’s arguments unchanged, failing to collapse dimensionless arguments to Dimension(1). Fixing it means: (1) recursively computing each argument’s factor and dimension, (2) checking with the dimension system whether each dimension is dimensionless, and (3) substituting Dimension(1) where appropriate before returning. That logic is conceptually simple but requires domain knowledge about dimensional analysis and how SymPy encodes it. From an automated-repair standpoint, the reproduction snippet pinpoints the failure and the intended behaviour, and the diff is small and localized, making it reasonably solvable by an AI that analyses the failing assertion. There is no need for large architectural insight, but naïve pattern-matching would not suffice, so it rises above “easy”. Hence, moderate complexity and solvable with better-than-even probability by a capable system."
sympy__sympy-24213,22,easy,85,"Only one line is changed in a single file: the strict equality check between dimensions is replaced by a call to the existing `equivalent_dims` helper, allowing logically equivalent (but not identical) dimensions to be treated as the same. The algorithm itself is unchanged; no new structures or extensive refactoring are required. An AI needs to locate where the failure arises (dimension comparison inside `_collect_factor_and_dimension`) and recognize that a semantic-level comparison is needed rather than raw equality—a straightforward pattern once the error is reproduced. Domain knowledge of SymPy’s units module helps but the codebase clearly exposes `equivalent_dims`, so the change can be inferred from the exception message and function names. Therefore the patch is low in complexity and highly solvable, warranting an ‘easy’ label with a high probability of automated generation."
sympy__sympy-24443,40,medium,60,"The fix spans a single module and roughly 30-40 lines of code, replacing a convoluted loop with a clearer translation of relator words into images. While it touches on abstract-algebra concepts (presentations, relators, array_form) it does not require redesigning multiple components or crafting a new algorithm—just using existing SymPy APIs more appropriately. The key difficulty lies in understanding how permutation group generators are represented (ext_rep) and why the old membership test failed for inverses; once that nuance is grasped the patch is straightforward. An AI with access to the failing example and the code could reasonably infer that the image computation for relators must iterate over array_form symbols irrespective of inversion. Test coverage is implicit (the given example) but not exhaustive, so multiple correct rewrites are possible, keeping solvability moderate rather than high."
sympy__sympy-24539,15,easy,90,"The bug is localized to a single method and stems from a simple control-flow mistake: the provided symbols are overwritten because the else branch executes even when the correct number of symbols is supplied. The fix only requires reordering the condition so that the overwrite happens only when no symbols are given, and raising an error when an incorrect count is supplied. This affects one file and about half a dozen lines with no algorithmic changes or cross-module impacts, reflecting low complexity. An AI system can readily infer the needed fix from the clear bug description and minimal contextual code, so the likelihood of automatically generating the correct patch is high."
sympy__sympy-24562,35,medium,60,"The patch touches a single file and only adds or changes about half-a-dozen lines, so the code delta itself is small. However, understanding why Rational('0.5', '100') produced 1/100100 instead of 1/200 requires familiarity with the internal representation of Rational numbers in SymPy and how numerators/denominators are accumulated when the inputs aren’t plain integers. The underlying mistake—over-writing the q variable while it is still needed and thereby compounding denominators—has to be reasoned out. Discovering that a separate accumulator (Q) is required is not just a typo fix; it needs logic tracing, but no deep algorithmic overhaul or multiple-module refactor. Therefore the task is moderately complex and falls into the ""medium"" category. Given the clear symptom/reproduction in the issue report and the localised nature of the bug, an automated system with code-analysis capability has a reasonable (≈60%) chance of finding the faulty lines and applying a fix similar to introducing an independent denominator accumulator."
sympy__sympy-24661,35,medium,65,"Only one file is touched and about 20 new lines are added. The fix is conceptually simple: intercept Python AST Compare nodes during the ""evaluate=False"" transformation and wrap them in the appropriate SymPy relational constructor with evaluate=False. Implementing this requires moderate familiarity with Python’s ast module and knowledge of SymPy relational classes, but no deep algorithmic work or multi-module refactor. An experienced developer—or an AI model that understands the pattern used elsewhere in the transformer—can derive the change from the concise bug report and the existing EvaluateFalseTransformer design. Therefore the task sits in the lower-mid complexity range and is quite solvable, though not trivial pattern-matching, pushing it into the ""medium"" category."
